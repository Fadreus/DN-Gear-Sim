(function () {
'use strict';

angular.module('dnsim').config(['$routeProvider', config]);

function config($routeProvider) {

  $routeProvider.
  
    when('/about', {
      templateUrl: 'ui/about/about.html',
      controller: 'AboutCtrl as about'
    }).
    
    when('/setup', {
      templateUrl: 'ui/nav/setup.html',
      controller: 'SetupCtrl'
    }).
    when('/test', {
      templateUrl: 'ui/nav/test.html',
      controller: 'TestCtrl'
    }).
    
    when('/items', {
      templateUrl: 'ui/secrets/items.html',
      controller: 'ItemsCtrl as items'
    }).
    
    when('/', {
      templateUrl: 'ui/welcome.html',
    }).
    when('/builds', {
      templateUrl: 'ui/builds/build-list.html',
      controller: 'BuildListCtrl as buildList'
    }).
    when('/build/:buildName*', {
      templateUrl: 'ui/builds/build-list.html',
      controller: 'BuildListCtrl as buildList'
    }).
    when('/view-group/:region?', {
      templateUrl: 'ui/builds/view-group.html',
      controller: 'ViewGroupCtrl'
    }).
    when('/edit-build/:buildName*', {
      templateUrl: 'ui/builds/edit-build.html',
      controller: 'EditBuildCtrl as editGroup',
      // reloadOnSearch: false,
    }).
    when('/new-build', {
      templateUrl: 'ui/builds/edit-build.html',
      controller: 'EditBuildCtrl as editGroup',
      // reloadOnSearch: false,
    }).
    when('/delete-build/:name*', {
      templateUrl: 'ui/builds/delete-build.html',
      controller: 'DeleteBuildCtrl as deleteBuild',
      // reloadOnSearch: false,
    }).
    
    when('/search/:cat?', {
      templateUrl: 'ui/search/item-search.html',
      controller: 'ItemSearchCtrl as ctrl'
    }).
    
    when('/item', {
      templateUrl: 'ui/item/item.html',
      controller: 'ItemCtrl',
      // reloadOnSearch: false,
    }).
    when('/item/:region?/:i*', {
      templateUrl: 'ui/item/item.html',
      controller: 'ItemCtrl',
      // reloadOnSearch: false,
    }).
    
    when('/export', {
      templateUrl: 'ui/nav/export.html',
      controller: 'ExportCtrl',
    }).
    
    when('/talismans', {
      templateUrl: 'ui/builds/build-talismans.html',
      controller: 'BuildTalismansCtrl as ctrl',
    }).
    
    when('/publish', {
      templateUrl: 'ui/online/publish.html',
      controller: 'PublishCtrl as ctrl',
    }).
    
    when('/profile/:uid?', {
      templateUrl: 'ui/online/profile.html',
      controller: 'ProfileCtrl as ctrl',
    }).
    
    when('/published', {
      templateUrl: 'ui/online/published.html',
      controller: 'PublishedCtrl as ctrl',
    }).
    
    when('/import', {
      templateUrl: 'ui/builds/build-import.html',
      controller: 'BuildImportCtrl as ctrl',
    }).
    
    when('/published/:uid/:buildName*', {
      templateUrl: 'ui/online/published.html',
      controller: 'PublishedCtrl as ctrl',
    }).
    
    when('/build-search/:jobId?', {
      templateUrl: 'ui/online/build-search.html',
      controller: 'BuildSearchCtrl as ctrl',
    }).
    
    otherwise({
      redirectTo: '/'
    });
}

})();
(function () {
'use strict';
angular.module('dnsim')
.controller('AboutCtrl', 
  ['$window',
  function($window) {
    'use strict';
    document.body.className = 'default-back';
    $window.document.title = 'DN Gear Sim';
  }]
);
})();
(function () {
'use strict';
angular.module('dnsim').filter('escape', [function() {
  'use strict';

  function escapeFilter(input) {
      if(input) {
          return window.encodeURIComponent(input);
      }
      return '';
  }

  return escapeFilter;
}]);

})();
(function () {
'use strict';
angular.module('dnsim').filter('percentage', [function() {
  'use strict';

  function percentageFilter(input) {
    if(typeof input == 'number') {
      return (Math.round(input * 100 * 100) / 100) + '%';
    }
    else {
      return input;
    }
  }
  percentageFilter.$stateful = false;

  return percentageFilter;
}]);

})();
angular.module('dnsim').controller('buildActionsCtrl',

['$timeout','$location','hCodeValues','statHelper','itemCategory','saveHelper','exportLinkHelper','groupHelper','translations','dntData','dntReset',
function($timeout,$location,hCodeValues,statHelper,itemCategory,saveHelper,exportLinkHelper,groupHelper,translations,dntData,dntReset) {
  'use strict';
  
  var vm = this;
  
  this.deleteGroup = function() {
    $location.path('/delete-build/' + vm.buildName);
  }
  
  this.editGroup = function() {
    $location.path('/edit-build/' + vm.buildName)
  }
  
  this.copyGroup = function() {
    var newGroupName = saveHelper.importGroup(vm.buildName, vm.build.items);
    
    saveHelper.renameSavedGroup(
      newGroupName, 
      newGroupName,
      vm.build.enemyLevel,
      vm.build.playerLevel,
      vm.build.heroLevel,
      vm.build.job,
      vm.build.damageType,
      vm.build.element,
      vm.build.secondaryElement,
      vm.build.enemyStatCaps, 
      vm.build.playerStatCaps, 
      vm.build.conversions, 
      vm.build.baseStats, 
      vm.build.heroStats);
    
    $location.path('/build/' + newGroupName);
  }
  
  this.reloaded = false;
  this.reloadGroup = function() {
    dntReset();
    vm.reloaded = false;
    
    translations.init(progress, tryInit);

    var files = groupHelper.getDntFiles(vm.build);
    angular.forEach(files, function(columns, fileName) {
      dntData.init(fileName, columns, progress, tryInit);
    });
    
    vm.onChange();
  }

  function tryInit() {
    if(vm.reloaded) {
      return;
    }
    
    var allLoaded = true;
    var files = groupHelper.getDntFiles(vm.build);
    angular.forEach(files, function(columns, fileName) {
      if(!dntData.isLoaded(fileName)) {
        allLoaded = false;
        return;
      }
    });
    
    if(allLoaded && translations.isLoaded()) {
      var newItems = groupHelper.reloadGroup(vm.buildName, vm.build);
      saveHelper.updatedSavedItems(vm.buildName, newItems);
      vm.build.items = newItems;
      
      vm.reloaded = true;
      $timeout(vm.onChange);
    }
  }
  
  function progress() {
  }
  
  this.createShortUrl = function() {
    exportLinkHelper.createShortUrl(vm.buildName, vm.build);
  }
    
  this.setShortUrl = function() {
    if(vm.build) {
      var longUrl = exportLinkHelper.createGroupLink(vm.buildName, vm.build);
      vm.build.shortUrl = sessionStorage.getItem(longUrl);
    }
  }
  
  this.setShortUrl();
}])
.directive('dngearsimBuildActions', function() {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build',
      onChange: '&onChange'
    },
    controller: 'buildActionsCtrl',
    controllerAs: 'buildActions',
    templateUrl: 'ui/builds/build-actions.html'
  };
});
angular.module('dnsim').controller('buildExportActionCtrl',

['$timeout','$location','hCodeValues','statHelper','itemCategory','saveHelper','exportLinkHelper','groupHelper','translations','dntData','dntReset',
function($timeout,$location,hCodeValues,statHelper,itemCategory,saveHelper,exportLinkHelper,groupHelper,translations,dntData,dntReset) {
  'use strict';
  
  var vm = this;
  
  vm.export = exportBuild;
  
  function exportBuild() {
    var blob = new Blob([JSON.stringify(vm.build, null, 1)], {type: "text/plain;charset=utf-8"});
    saveAs(blob, 'dngearsim-' + vm.buildName + '.json');
  }
}])
.directive('dngearsimBuildExportAction', function() {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build'
    },
    controller: 'buildExportActionCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/builds/build-export-action.html'
  };
});
angular.module('dnsim').controller('BuildImportCtrl',

['$timeout','$location','hCodeValues','statHelper','itemCategory','saveHelper','exportLinkHelper','groupHelper','translations','dntData','dntReset',
function($timeout,$location,hCodeValues,statHelper,itemCategory,saveHelper,exportLinkHelper,groupHelper,translations,dntData,dntReset) {
  'use strict';
  
  var vm = this;
  
  vm.onFileChange = onFileChange;
  vm.copyLocally = copyLocally;
  
  function onFileChange(event) {
    var files = event.target.files;
    console.log('importing files', files);
    if(files && files.length) {
      
      var fileName = files[0].name;
      var reader = new FileReader();
      reader.readAsText(files[0]);
      reader.onload = function() {
        vm.build = JSON.parse(reader.result);
        if(fileName && fileName.length > 5) {
          vm.buildName = fileName.substr(0, fileName.length-5);
          vm.buildName = vm.buildName.replace('dngearsim-', '')
        }
        else {
          vm.buildName = 'imported build';
        }
        $timeout();
      }
    }
  }
  
  function copyLocally() {
    var newGroupName = saveHelper.importGroup(vm.buildName, vm.build.items);
    
    saveHelper.renameSavedGroup(
      newGroupName, 
      newGroupName,
      vm.build.enemyLevel,
      vm.build.playerLevel,
      vm.build.heroLevel,
      vm.build.job,
      vm.build.damageType,
      vm.build.element,
      vm.build.secondaryElement,
      vm.build.enemyStatCaps, 
      vm.build.playerStatCaps, 
      vm.build.conversions, 
      vm.build.baseStats, 
      vm.build.heroStats);
      
    $location.path('/build/' + newGroupName);
  }
}]);
angular.module('dnsim').controller('buildItemCtrl',

['$timeout','statHelper','saveHelper','hCodeValues',
function($timeout,statHelper,saveHelper,hCodeValues) {
  'use strict';
  
  var vm = this;
  
  vm.updateItem = setFullStats;
  vm.gemSlots = hCodeValues.gemExchanges;
  vm.getGemSlotName = getGemSlotName;
  
  function getGemSlotName(item) {
    if(item.gemSlot) {
      for(var i=0;i<vm.gemSlots.length;++i) {
        if(vm.gemSlots[i].id == item.gemSlot) {
          return vm.gemSlots[i].name;
        }
      }
    }
  }
  
  function setFullStats() {
    // full stats are cleared when publishing builds
    vm.item.fullStats = vm.item.stats;
    
    if(vm.item.enchantmentStats != null && vm.item.enchantmentStats.length > 0) {
      vm.item.fullStats = hCodeValues.mergeStats(vm.item.enchantmentStats, vm.item.fullStats);
    }
    
    if(vm.item.sparkStats != null && vm.item.sparkStats.length > 0) {
      vm.item.fullStats = hCodeValues.mergeStats(vm.item.sparkStats, vm.item.fullStats);
    }
  }
  
}])
.directive('dngearsimBuildItem', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      editMode: '=editMode',
      onChange: '&onChange',
      cancelEdit: '&cancelEdit'
    },
    controller: 'buildItemCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/builds/build-item.html'
  };
});
angular.module('dnsim').controller('BuildListCtrl', 
  [ '$window','$location','$routeParams','$timeout','saveHelper',
  function($window,$location,$routeParams,$timeout,saveHelper) {
    'use strict';
    
    var vm = this;
    document.body.className = 'saved-back';
    this.setupBuilds = function() {
      vm.savedItems = saveHelper.getSavedItems();
      vm.buildNames = Object.keys(vm.savedItems).sort();
      vm.builds = [];
      for(var i=0;i<vm.buildNames.length;++i) {
        vm.builds.push({
          name: vm.buildNames[i],
          build: vm.savedItems[vm.buildNames[i]],
        });
      }
    }
    this.setupBuilds();
    
    if('buildName' in $routeParams) {
      if($routeParams.buildName != this.currentGroup) {
        this.currentGroup = $routeParams.buildName;
        saveHelper.saveBuildSelection(this.currentGroup, this.savedItems);
      }
    }
    else if(this.currentGroup && this.currentGroup in this.savedItems) {
      $location.path('/build/' + this.currentGroup);
    }
    else {
      this.currentGroup = null;
    }
    
    if(this.currentGroup) {
      $window.document.title = 'DN Gear Sim | ' + this.currentGroup;
    }
    else {
      $window.document.title = 'DN Gear Sim | BUILDS';
    }

    this.anyItems = function() {
      return Object.keys(this.savedItems).length > 0;
    }

    this.createGroup = function() {
      $location.path('/new-build');
    }
    
    this.handleChange = function() {
      vm.setupBuilds();
      $timeout();
      // console.log('change');
    }
  
    this.toggleGroup = function(buildName) {
      saveHelper.saveBuildSelection(buildName, this.savedItems);
      $location.url('/build/' + buildName);
    }
    
    this.publish = function() {
      $location.url('/publish');
    }
    
    this.search = function() {
      $location.url('/build-search');
    }
  }]
);

angular.module('dnsim').controller('buildStatsCtrl',

['$routeParams','$location','hCodeValues','statHelper','itemCategory',
function($routeParams,$location,hCodeValues,statHelper,itemCategory) {
  'use strict';
}])
.directive('dngearsimBuildStats', function() {
  return {
    scope: true,
    bindToController: {
      stats: '=stats',
      build: '=build',
    },
    controller: 'buildStatsCtrl',
    controllerAs: 'statsCtrl',
    templateUrl: 'ui/builds/build-stats.html'
  };
});
angular.module('dnsim').controller('buildSummaryCtrl',

['$routeParams','$location','hCodeValues','statHelper','itemCategory',
function($routeParams,$location,hCodeValues,statHelper,itemCategory) {
  'use strict';
  
  var vm = this;
  
  this.stats = statHelper.getBuildStats(this.build);
  this.itemsByCategory = itemCategory.getItemsByCategory(this.build.items);
  
  this.getSaveDate = function(group) {
    if(vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleDateString();
    }
  }
  
  this.getSaveTime = function(group) {
    if(vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleTimeString();
    }
  }
  
  this.getBuildSummary = function(group) {
    var summary = '';
    
    var typeCounts = {};
    var cashItems = 0;
    var titles = 0;
    angular.forEach(vm.itemsByCategory, function(itemsByType, type) {
      if(itemsByType.length > 0) {
        if(summary.length > 0) {
          summary += ', ';
        }
        summary += itemsByType.length + ' ' + type;
      }
    });
    
    return summary;
  }
}])
.directive('dngearsimBuildSummary', function() {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build'
    },
    controller: 'buildSummaryCtrl',
    controllerAs: 'buildCtrl',
    templateUrl: 'ui/builds/build-summary.html'
  };
});
angular.module('dnsim').controller('BuildTalismansCtrl',

['$window','$location','$routeParams','$timeout','saveHelper','statHelper','jobs','hCodeValues','itemColumnsToLoad','character',
function($window,$location,$routeParams,$timeout,saveHelper,statHelper,jobs,hCodeValues,itemColumnsToLoad,character) {
  'use strict';
  
  var vm = this;
  
  $window.document.title = 'DN Gear Sim | TALISMANS';
  $window.scrollTo(0, 0);
  
  this.savedItems = saveHelper.getSavedItems();
  this.groupNames = Object.keys(this.savedItems);
  if(!this.groupNames) {
    this.groupNames = [];
  }
  if(this.groupNames.length > 0) {
    this.groupName = saveHelper.getCurrentBuild();
  }
  else {
    this.groupName = null;
  }
  
  if(!this.groupName || !(this.groupName in this.savedItems)) {
    if(this.groupNames.length > 0) {
      this.groupName = this.groupNames[0];
    }
  }
  
  if(!this.groupName) {
    // console.log('cannot find build');
    return;
  }
  
  this.getGroupCalcStats = function() {
    if(this.groupCalcStats == null) {
      var group = vm.savedItems[vm.groupName];
      if(group) {
        this.groupCalcStats = statHelper.getCalculatedStatsFromItems(group, group.items);
      }
    }
    
    return this.groupCalcStats;
  }
  
  this.getBuild = function() {
    return vm.savedItems[vm.groupName];
  }
  
  this.pickup = function(index) {
    vm.selectedIndex = index;
    
    vm.replaceHPAffectAmount = [];
    vm.replaceMDmgAffectAmount = [];
    vm.replacePDmgAffectAmount = [];
    vm.replaceAvgDmgAffectAmount = [];
  }
  
  function saveGroup() {
    saveHelper.saveBuildSelection(vm.groupName, vm.savedItems);
  }
  
  this.headers = [
    '+100%',
    '+75%',
    '+25%',
    '+0%',
    ];
  
  this.summaryStatIds = [];
  for(var id in hCodeValues.stats) {
    if(hCodeValues.stats[id].summaryDisplay) {
      this.summaryStatIds.push(id);
    }
  }
  
  this.pcIndexes = {};
  this.pcIndexes['100'] = 0;
  this.pcIndexes['75'] = 1;
  this.pcIndexes['25'] = 2;
  this.pcIndexes['0'] = 3;
  
  this.selectedIndex = -1;
  
  this.rows = [];
  
  this.updateRows = function() {
    vm.rows = [];
        
    angular.forEach(vm.savedItems[vm.groupName].items, function(item, index) {
      if(item.typeName == 'talisman') {
        var pcIndex = vm.pcIndexes[item.enchantmentNum];
        if(!pcIndex && pcIndex != 0) {
          pcIndex = 3;
        }
        
        var rowIndex = 0;
        for(;;) {
          if(!vm.rows[rowIndex]) {
            vm.rows[rowIndex] = vm.makeFakeCells();
          }
          
          if(vm.rows[rowIndex][pcIndex].index < 0) {
            if(!item.enchantmentNum) {
              item.enchantmentNum = 0;
            }
            
            var data = vm.makeCell(item, index);
            vm.rows[rowIndex][pcIndex] = data;
            break;
          }
          else {
            rowIndex++;
          }
        }
      }
      
    });
    
    if(vm.rows.length < 3) {
      vm.rows[vm.rows.length+1] = vm.makeFakeCells();
    }
  };
  
  this.makeFakeCells = function(num) {
    return [vm.makeCell({enchantmentNum:100},-1),vm.makeCell({enchantmentNum:75},-2),vm.makeCell({enchantmentNum:25},-3),vm.makeCell({enchantmentNum:0},-4)];
  };
  
  this.makeCell = function(item, index) {
    return { item: item, index: index };
  };
  
  this.click = function(col) {
    if(vm.selectedIndex == -1) {
      if(col.index >= 0) {
        vm.pickup(col.index);
      }
    }
    else {
      vm.move(col);
    }
  };
  
  this.move = function(col) {
    
    var items = vm.savedItems[vm.groupName].items;
    if(col.index >= 0) {
      var swapEnchantmentNumber = col.item.enchantmentNum;
      
      vm.setTalisman(col.item, items[vm.selectedIndex].enchantmentNum);
      vm.setTalisman(items[vm.selectedIndex], swapEnchantmentNumber);
      items[col.index] = items[vm.selectedIndex];
      items[vm.selectedIndex] = col.item;
    }
    else {
      var item = items[vm.selectedIndex];
      vm.setTalisman(item, col.item.enchantmentNum);
      items.splice(vm.selectedIndex, 1);
      items.push(item);
    }

    vm.groupCalcStats = null;
    vm.selectedIndex = -1;
    vm.updateRows();
    vm.replaceAffectAmount = {};
    $timeout();
  };
  
  this.setTalisman = function(item, newEnhancementNum) {
    var extraStats = [];
    angular.forEach(item.stats, function(stat, index) {
      if(newEnhancementNum) {
        extraStats.push({id: stat.id, max: stat.max * (newEnhancementNum/100)});
      }
    });
    
    item.enchantmentStats = extraStats;
    item.enchantmentNum = newEnhancementNum;
    
    item.fullStats = hCodeValues.mergeStats(item.enchantmentStats, item.stats);
  };
  
    
  this.replaceAffectAmount = {};
  this.getReplaceAffectAmount = function(statId, itemIndex, item) {
    this.initReplaceAffects(itemIndex, item);
    if(this.replaceAffectAmount[itemIndex]) {
      return this.replaceAffectAmount[itemIndex][statId];
    }
  };
  
  this.initReplaceAffects = function(itemIndex, item) {
    if(vm.replaceAffectAmount[itemIndex] || vm.selectedIndex == -1) {
      return;
    }
    this.replaceAffectAmount[itemIndex] = {};
    
    var group = vm.savedItems[vm.groupName];
    var item2 = group.items[vm.selectedIndex];
    
    var extraStats = [];
    var fullStats1 = [];
    if(item.stats) {
      angular.forEach(item.stats, function(stat, index) {
        extraStats.push({id: stat.id, max: stat.max * (item2.enchantmentNum/100)});
      });
      fullStats1 = hCodeValues.mergeStats(extraStats, item.stats);
    }
    
    extraStats = [];
    angular.forEach(item2.stats, function(stat, index) {
      extraStats.push({id: stat.id, max: stat.max * (item.enchantmentNum/100)});
    });
    var fullStats2 = hCodeValues.mergeStats(extraStats, item2.stats);

    var newItems = [{stats: fullStats1}, {stats: fullStats2}];
    angular.forEach(group.items, function(gItem , index) {
      if(item !== gItem && item2 !== gItem) {
        newItems.push(gItem);
      }
    });
    
    var newStats = statHelper.getCalculatedStatsFromItems(group, newItems);
    var origStats = vm.getGroupCalcStats();
    
    for(var id in hCodeValues.stats) {
      if(hCodeValues.stats[id].summaryDisplay) {
        vm.replaceAffectAmount[itemIndex][id] = calcStatPercent(vm.getStat(id, newStats).max, vm.getStat(id, origStats).max);
      }
    }
  };
  
  this.getStatName = function(id) {
    var retVal = '';
    if(hCodeValues.stats[id].element == 'primary') {
      var eleId = 0;
      if(vm.savedItems[vm.groupName].element) {
        eleId = vm.savedItems[vm.groupName].element.id;
      }
      retVal += hCodeValues.elements[eleId].name;
    }
    else if(hCodeValues.stats[id].element == 'secondary') {
      var eleId = 0;
      if(vm.savedItems[vm.groupName].secondaryElement) {
        eleId = vm.savedItems[vm.groupName].secondaryElement.id;
      }
      retVal += hCodeValues.elements[eleId].name;
    }
    return retVal + ' ' + hCodeValues.stats[id].name;
  };
  
  this.getStat = function(id, stats) {
    var len = stats.length;
    for(var i=0;i<len;++i) {
      if(stats[i].id == id) {
        return stats[i];
      }
    }
    return {id: id, max:0};
  };
  
  function calcStatPercent(newVal, origVal) {
    if(newVal && origVal) {
      return Math.round(10000 * (1 - (origVal / newVal))) / 100;
    }
    else {
      return 0;
    }
  }
  
  this.save = function() {
    saveHelper.updatedSavedItems(vm.groupName, vm.savedItems[vm.groupName].items);
    $location.path('/build/' + vm.groupName);
  };
  
  this.updateRows();
  
}]); 
angular.module('dnsim').controller('buildCtrl',

['$timeout','$location','hCodeValues','statHelper','itemCategory','saveHelper',
function($timeout,$location,hCodeValues,statHelper,itemCategory,saveHelper) {
  'use strict';
  
  var vm = this;
  
  this.stats = statHelper.getBuildStats(this.build);
  
  var selectedCategory = localStorage.getItem('selectedItemCategory');
  this.category = itemCategory.byName(selectedCategory);
  if(!this.category) {
    selectedCategory = 'titles';
    this.category = itemCategory.byName('titles');
  }
  
  this.getCategoryItems = function() {
    var itemsByCat = itemCategory.getItemsByCategory(this.build.items);
    if(vm.category.name in itemsByCat) {
      return itemsByCat[vm.category.name];
    }
    else {
      return [];
    }
  }
  
  this.getCategories = function() {
    return itemCategory.categories;
  }
    
  this.setSelectedCategory = function(value) {
    this.category = itemCategory.byName(value);
    localStorage.setItem('selectedItemCategory', value);
  }
  
  this.getSaveDate = function(group) {
    if(vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleDateString();
    }
  }
  
  this.getSaveTime = function(group) {
    if(vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleTimeString();
    }
  }
  
  this.allowMoreItems = function() {
    return !vm.category.maxCat || this.getCategoryItems().length < vm.category.maxCat;
  }
  
  this.getItemCount = function() {
    var itemCountText = '';
    var allItems = vm.build.items;
    
    if(vm.category.name == 'offensive gems') {
      var numOffensiveSlots = 0;
      var numOffensiveGems = 0;
      angular.forEach(allItems, function(item, index) {
        if(item.typeName == vm.category.name) {
          numOffensiveGems++;
        }
        else if(item.offensiveGemSlots) {
          numOffensiveSlots += item.offensiveGemSlots;
        }
      });
      
      itemCountText = numOffensiveGems + ' / ' + numOffensiveSlots;
    }
    else if(vm.category.name == 'increasing gems') {
      
      var totalIncreasingGems = 0;
      var numIncreasingSlots = 0;
      var numIncreasingGems = {};
      angular.forEach(allItems, function(item, index) {
        if(item.typeName == vm.category.name) {
          var gemType = item.sparkTypeId;
          if(!gemType) {
            gemType = 0;
          }
          
          if(!(gemType in numIncreasingGems)) {
            numIncreasingGems[gemType] = 0;
          }
          numIncreasingGems[gemType]++;
          totalIncreasingGems++;
        }
        else if(item.increasingGemSlots) {
          numIncreasingSlots += item.increasingGemSlots;
        }
      });
      
      itemCountText = ''
      angular.forEach(numIncreasingGems, function(number, gemType) {
        if(itemCountText.length > 0) {
          itemCountText += '+';
        }
        itemCountText += number;
      });
      
      itemCountText = totalIncreasingGems + ' (' + itemCountText + ') / ' + numIncreasingSlots;
    }
    else {
      var numItems = 0;
      angular.forEach(allItems, function(item, index) {
        if(item && item.typeName == vm.category.name) {
          numItems++;
        }
      });
      
      itemCountText = numItems;
      var cat = itemCategory.byName(vm.category.name);
      if(cat && 'numItemText' in cat) {
        itemCountText += ' / ' + cat.numItemText;
      }
    }
    
    return itemCountText + ' ' + vm.category.name;
  }
  
  this.newCustom = function() {
    var newCustom = 
    {id: 0, typeName:'custom', name: 'new custom item', stats: []};
    vm.build.items = vm.build.items.concat(newCustom);
    saveHelper.updatedSavedItems(vm.buildName, vm.build.items);
    vm.handleChange();
  }
  
  this.handleChange = function() {
    vm.stats = statHelper.getBuildStats(vm.build);
    vm.onChange();
  }
  
  this.handleItemEdit = function() {
    saveHelper.updatedSavedItems(vm.buildName, vm.build.items);
    vm.handleChange();
  }
  
  this.cancelEdit = function() {
    vm.onChange();
  }
  
  this.canEdit = function(item) {
    return item.typeName == 'custom' || item.typeName == 'weapons' || item.typeName == 'armour' || item.typeName == 'offensive gems' || item.typeName == 'increasing gems';
  }
  
  this.removeItem = function(item) {
    item.removeItem = true;
    var newItemList = [];
    angular.forEach(vm.build.items, function(gItem, index) {
      if(gItem && !gItem.removeItem) {
        newItemList.push(gItem);
      }
    });

    vm.build.items = newItemList;
    saveHelper.updatedSavedItems(vm.buildName, newItemList);
    vm.handleChange();
  }
  
}])
.directive('dngearsimBuild', function() {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build',
      onChange: '&onChange',
      server: '=server'
    },
    controller: 'buildCtrl',
    controllerAs: 'buildCtrl',
    templateUrl: 'ui/builds/build.html'
  };
});
angular.module('dnsim').controller('DeleteBuildCtrl',

['$location','$routeParams','$timeout','saveHelper','dntData','jobs','hCodeValues','itemColumnsToLoad',
function($location,$routeParams,$timeout,saveHelper,dntData,jobs,hCodeValues,itemColumnsToLoad) {
  'use strict';
  
  var vm = this;
  this.newGroup = true;
  if('name' in $routeParams) {
      this.name = $routeParams.name;
  }
  
  this.delete = function() {
    saveHelper.updatedSavedItems(this.name, []);
    $location.path('/builds/');
  }
    
}]); 
angular.module('dnsim').controller('EditBuildCtrl',

['$window','$location','$routeParams','$timeout','saveHelper','dntData','jobs','hCodeValues','itemColumnsToLoad','character',
function($window,$location,$routeParams,$timeout,saveHelper,dntData,jobs,hCodeValues,itemColumnsToLoad,character) {
  'use strict';
  
  var vm = this;
  this.savedItems = saveHelper.getSavedItems();
  this.group = {};
  this.newGroup = true;
  if('buildName' in $routeParams) {
      this.groupName = $routeParams.buildName;
      if(this.groupName in this.savedItems) {
        this.group = this.savedItems[this.groupName];
        this.newGroup = false;
      }
  }
  else {
    this.groupName = '';
  }
  this.oldGroupName = this.groupName;
  this.heroStats = [];
  this.elements = hCodeValues.elements;
  this.damageTypes = hCodeValues.damageTypes;
  
  if(this.group.damageType) {
    this.damageType = this.group.damageType;
  }
  else {
    this.damageType = hCodeValues.damageTypes[0];
  }
    
  if(this.group.element) {
    this.element = this.group.element;
  }
  else {
    this.element = hCodeValues.elements[0];
  }
    
  if(this.group.secondaryElement) {
    this.secondaryElement = this.group.secondaryElement;
  }
  else {
    this.secondaryElement = hCodeValues.elements[0];
  }

  if(this.group.enemyLevel) {
    this.enemyLevel = this.group.enemyLevel;
  }
  else {
    this.enemyLevel = 90;
  }
  
  if(this.group.playerLevel) {
    this.playerLevel = this.group.playerLevel;
  }
  else {
    this.playerLevel = 90;
  }
  
  if(this.group.heroLevel && this.group.heroLevel > 0) {
    this.heroLevel = this.group.heroLevel;
  }
  else {
    this.heroLevel = 1;
  }
  
  this.init = function(vm) {
    var newJobs = jobs.getFinalJobs();
    if(newJobs.length > 0) {
      $timeout( function() {
        
        if('job' in vm.group) {
          angular.forEach(newJobs, function(value, key) {
            if(value.id == vm.group.job.id) {
              vm.job = value;
            }
          });
        }
        
        vm.setHeroStats();
      });
    }
  }
  
  this.setJob = function() {
    $window.scrollTo(0, 0);
  }
  
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
  
  character.init(function() { vm.init(vm) });
  
  this.getStatCap = function(colName, useLevel) {
    return character.getStatCaps(useLevel)[colName];
  }
  this.getJobConversion = function(colName) {
    return character.getConversions(this.job.id)[colName];
  }
  this.getJobBaseStat = function(colName) {
    return character.getBaseStats(this.playerLevel, this.job.id)[colName];
  }
  
  this.invalidGroupName = function() {
    if(!this.groupName) {
      return true;
    }
    
    if(this.groupName in this.savedItems) {
      if(this.newGroup || this.groupName != this.oldGroupName) {
        return true;
      }
    }
    
    return false;
  }
  
  this.ok = function() {
    var enemyStatCaps = character.getStatCaps(this.enemyLevel);
    var playerStatCaps = character.getStatCaps(this.playerLevel);
    var conversions = character.getConversions(this.job.id);
    var baseStats = character.getBaseStats(this.playerLevel, this.job.id);
    var heroStats = character.getHeroStats(this.heroLevel);
    
    if(this.newGroup) {
      this.oldGroupName = this.groupName;
      saveHelper.importGroup(this.groupName, []);
    }
    
    saveHelper.renameSavedGroup(
      this.oldGroupName, 
      this.groupName,
      this.enemyLevel,
      this.playerLevel,
      this.heroLevel,
      this.job,
      this.damageType,
      this.element,
      this.secondaryElement,
      enemyStatCaps, playerStatCaps, conversions, baseStats, heroStats);
    
    $location.path('/build/' + this.groupName);
  }
  
  this.setHeroStats = function() {
    this.heroStats = character.getHeroStats(this.heroLevel);
    // console.log('got ' + this.heroStats.length + ' hero stats');
  }
  
  $timeout(function() {
    var input = document.getElementById('groupNameInput');
    if(input) {
      input.focus();
      input.setSelectionRange(0, 9999);
    }
  });
}]); 
angular.module('dnsim').controller('quickAddCtrl',

['$timeout','statHelper','saveHelper','quickAdd','itemCategory','jobs','dntData','exportLinkHelper',
function($timeout,statHelper,saveHelper,quickAdd,itemCategory,jobs,dntData,exportLinkHelper) {
  'use strict';
  
  var vm = this;
  vm.startedForCat = '';
  vm.stepNumber = 0;
  vm.datas = [];
  vm.options = [];
  
  this.setOptions = function() {
    if(vm.hasStarted()) {
      vm.options = quickAdd.getOptions(vm.category, vm.build, vm.datas);
      if(vm.options.length == 1) {
        vm.selectOption(vm.options[0]);
      }
    }
  }
  
  this.selectOption = function(value) {
    var data = quickAdd.createData(value, vm.category, vm.stepNumber)
    vm.datas.push(data);
    vm.stepNumber++;
    if(!quickAdd.isValidStepNumber(vm.category, vm.stepNumber)) {
      
      var newItem = quickAdd.getItem(vm.datas);
      var dntFiles = exportLinkHelper.getDntFiles(newItem);
      angular.forEach(dntFiles, function(columns, fileName) {
        dntData.init(fileName, columns, function() {}, function() { vm.tryToAddItem(dntFiles, newItem) });
      });
      vm.tryToAddItem(dntFiles, newItem);
    }
    else {
      vm.setOptions();
      // console.log('setup next step');
    }
  }
  
  this.tryToAddItem = function(dntFiles, item) {
    if(!dntData.anyLoading()) {
      
      var allLoaded = true;
      angular.forEach(dntFiles, function(columns, fileName) {
        if(!dntData.isLoaded(fileName)) {
          allLoaded = false;
        }
      });
      
      if(allLoaded) {
        if(vm.datas.length > 0) {
          vm.cancel();
          var newItem = exportLinkHelper.reloadItem(item);
          saveHelper.saveItem(vm.buildName, newItem);
          vm.build.items.push(newItem);
          vm.onChange();
        }
      }
    }
  }
  
  this.reset = function() {
    vm.stepNumber = 0;
    vm.datas = [];
    $timeout(function() {
      vm.setOptions();
    });
  }
  
  this.hasStarted = function() {
    return vm.startedForCat == vm.category.name;
  }
  
  this.start = function() {
    vm.startedForCat = vm.category.name;
    
    jobs.init(function() {}, vm.reset);
    dntData.init('exchange.lzjson', null, function() {}, vm.reset);
    itemCategory.init(vm.category.name, vm.reset);
  }
  
  this.hasOptions = function() {
    return quickAdd.hasOptions(vm.category, vm.build, []);
  }
  
  this.cancel = function() {
    vm.startedForCat = '';
    vm.reset();
  }
  
  this.back = function() {
    if(vm.stepNumber == 0) {
      vm.cancel();
    }
    else {
      do {
        vm.stepNumber--;
        vm.datas.pop();
        
        var testOptions = quickAdd.getOptions(vm.category, vm.build, vm.datas);
      } while(testOptions.length <= 1 && vm.stepNumber > 0);
      
      vm.setOptions();
    }
  }
  
}])
.directive('dngearsimQuickAdd', function() {
  return {
    scope: true,
    bindToController: {
      category: '=category',
      build: '=build',
      buildName: '=buildName',
      onChange: '&onChange',
    },
    controller: 'quickAddCtrl',
    controllerAs: 'quickAdd',
    templateUrl: 'ui/builds/quick-add.html'
  };
});
angular.module('dnsim').controller('ViewGroupCtrl', 
  ['$scope','$window','region','$location','$routeParams','saveHelper','dntData','$timeout','translations','dntReset','exportLinkHelper','groupHelper','jobs','character','statHelper','hCodeValues',
  function($scope,$window,region,$location,$routeParams,saveHelper,dntData,$timeout,translations,dntReset,exportLinkHelper,groupHelper,jobs,character,statHelper,hCodeValues) {
    'use strict';
  
    document.body.className = 'saved-back';
    $window.document.title = 'DN Gear Sim';
    
    region.setLocationByName($routeParams.region);
    
    $scope.buildName = '';
    $scope.build = {};
    

    if('g' in $routeParams && 'i' in $routeParams) {
      $scope.buildName = $routeParams.g;
      
      $scope.enemyLevel = $routeParams.e;
      $scope.playerLevel = $routeParams.p;
      $scope.heroLevel = $routeParams.h;
      $scope.job = { id: $routeParams.j };
      $scope.damageType = hCodeValues.damageTypes[$routeParams.d];
      $scope.element = hCodeValues.elements[$routeParams.t];
      $scope.secondaryElement = hCodeValues.elements[$routeParams.s];
        
      var items = [];
      
      var itemString = $routeParams.i;
      
      angular.forEach(itemString.split(','), function(itemStr, index) {
        var item = exportLinkHelper.decodeItem(itemStr);
        
        if(item.id > 0) {
          items.push(item);
        }
      });

      $scope.build = {};
      $scope.savedItems = {};
      $scope.savedItems[$scope.buildName] = $scope.build;
      $scope.build.items = items;
      $scope.isLoading = true;
      
      angular.forEach(groupHelper.getDntFiles($scope.build), function(columns, fileName) {
        dntData.init(fileName, columns, progress, tryInit);
      });
      
      translations.init(progress, tryInit);
      jobs.init(progress, tryInit);
      character.init(tryInit);
      
      $timeout();
    }
    
    $scope.anyItems = Object.keys($scope.savedItems).length > 0;
    
    function tryInit() {
      
      var allInit = true;
      angular.forEach(groupHelper.getDntFiles($scope.build), function(columns, fileName) {
        if(!dntData.isLoaded(fileName)) {
          allInit = false;
        }
      });
      
      if(!allInit || dntData.anyLoading() || !translations.isLoaded() || !jobs.isLoaded()) {
        return;
      }
      
      $timeout(function() {
        var groupName = $scope.buildName;
        var group = $scope.build;
        
        $scope.job = jobs.getById($scope.job.id);
        
        $scope.enemyStatCaps = character.getStatCaps($scope.enemyLevel);
        $scope.playerStatCaps = character.getStatCaps($scope.playerLevel);
        if($scope.job) {
          $scope.conversions = character.getConversions($scope.job.id);
          $scope.baseStats = character.getBaseStats($scope.playerLevel, $scope.job.id);
        }
        $scope.heroStats = character.getHeroStats($scope.heroLevel);
        
        var newItems = groupHelper.reloadGroup(groupName, group);
      
        $scope.savedItems = {};
        $scope.build = {
          items: newItems,
          lastUpdate: group.lastUpdate,

          enemyLevel: $scope.enemyLevel,
          playerLevel: $scope.playerLevel,
          heroLevel: $scope.heroLevel,
          job: $scope.job,
          damageType: $scope.damageType,
          element: $scope.element,
          secondaryElement: $scope.secondaryElement,
          enemyStatCaps: $scope.enemyStatCaps,
          playerStatCaps: $scope.playerStatCaps,
          conversions: $scope.conversions,
          baseStats: $scope.baseStats,
          heroStats: $scope.heroStats,
        };
        $scope.savedItems[groupName] = $scope.build;
        $scope.stats = statHelper.getBuildStats($scope.build);
        
        var longUrl = exportLinkHelper.createGroupLink($scope.buildName, $scope.build);
        $scope.build.shortUrl = sessionStorage.getItem(longUrl);
      });
    }
    
    function progress() {
    }
    
    $scope.copyGroup = function() {
      var newBuildName = saveHelper.importGroup($scope.buildName, $scope.build.items);
      // console.log('copying in as ' + newBuildName);
      
      saveHelper.renameSavedGroup(
        newBuildName, 
        newBuildName,
        $scope.enemyLevel,
        $scope.playerLevel,
        $scope.heroLevel,
        $scope.job,
        $scope.damageType,
        $scope.element,
        $scope.secondaryElement,
        $scope.enemyStatCaps, $scope.playerStatCaps, $scope.conversions, $scope.baseStats, $scope.heroStats);
      
      $location.url('/build/' + newBuildName);
    }
  }]
);

angular.module('dnsim').controller('ExportCtrl', 
  ['$scope','$window','saveHelper',
   function($scope, $window, saveHelper) {
  'use strict';
     
  document.body.className = 'default-back';
  $window.document.title = 'DN Gear Sim | EXPORT';
  
  var rawSavedData = saveHelper.getSavedItems();
  $scope.exportData = JSON.stringify(rawSavedData, null, 1);
  
  $scope.save = function() {
    localStorage.setItem('savedItems', LZString.compressToUTF16($scope.exportData));
  }
}]);

angular.module('dnsim').controller('HeaderCtrl', 
[
  function() {
    'use strict';
    var vm = this;
  }
]).directive('dngearsimHeader', function() {
  return {
    templateUrl: 'ui/nav/header.html',
  };
});
angular.module('dnsim').controller('NavCtrl', 
  ['$scope','$location','translations','region','itemCategory','saveHelper',
  function($scope,$location,translations,region,itemCategory,saveHelper) {
    'use strict';

    var aboutAction = { path: 'about', name: '', icon: 'question-sign' }
    
    var noMenu = [];
    var noLocationMenu = [aboutAction];
    var normalMenu = [
      {path: 'builds', name:'builds', icon: 'wrench'},
      {path: 'search', name:'gear', icon: 'search'},
      {path: 'items', name:'items', icon: 'search'},
      aboutAction,
      ];
    
    var buildAction = {path: 'build', name:'build', icon: 'wrench'};
    
    var withBuildMenu = [
      {path: 'builds', name:'builds', icon: 'wrench'},
      buildAction,
      {path: 'search', name:'gear', icon: 'search'},
      {path: 'items', name:'items', icon: 'search'},
      aboutAction,
      ];
      
    //var basePath = angular.element(document.querySelector('base')).attr('href');
      
    region.init();
  
    $scope.isSearch = function() {
      return $location.path().indexOf('/search') == 0;
    }

    $scope.isLoading = function() {
      return translations.startedLoading && 
            !translations.isLoaded() &&
            region.tlocation != null &&
            region.tlocation.url != '' &&
            !$scope.noRegion();
    }
    
    $scope.noRegion = function() {
      return region.dntLocation == null;
    }
    
    $scope.isHttpOnly = function() {
      return location.protocol != 'https:';
    }
    
    $scope.getActionUrl = function(action) {
      if(action.name == 'search') {
        var cat = localStorage.getItem('selectedItemCategory', action.name);
        if(cat) {
          return action.path + '?cat=' + cat;
        }
        else {
          return action.path;
        }
      }
      else {
          return action.path;
      }
    }
      
    $scope.getActions = function() {
      // console.log('getting actions');
      var menu = null;
      
      var currentBuild = saveHelper.getCurrentBuild();
      if(currentBuild) {
        var savedItems = saveHelper.getSavedItems();
        if(!(currentBuild in savedItems)) {
          currentBuild = null;
        }
      }

      if(region.dntLocation != null && region.dntLocation.url == '') {
        menu = noLocationMenu; 
      }
      else if(region.tlocation != null && region.tlocation.url == '') {
        menu = noLocationMenu; 
      }
      else if(currentBuild && currentBuild != 'null') {
        menu = withBuildMenu;
        buildAction.path = 'build/' + currentBuild;
        buildAction.name = currentBuild;
      }
      else if($location.path() == '/view-group' || region.dntLocation == null) {
        menu = normalMenu;
      }
      else {
        menu = normalMenu;
      }
      
      angular.forEach(menu, function(value, key) {
        delete value.extraCss;
        if($location.path().length == 1) {
          if(value.path.length == 1) {
            value.extraCss = 'active';
          }
        }
        else if(value.path.length > 1 && $location.path().indexOf('/' + value.path) == 0) {
          if(value.path != 'builds' || $location.path() == '/builds') {
            value.extraCss = 'active';
          }
        }
      });
      
      return menu;
    };
  }
])
.directive('dngearsimNav', function() {
  return {
    templateUrl: 'ui/nav/nav.html'
  };
});
angular.module('dnsim').controller('SetupCtrl', 
  ['$scope','$window','$route','$timeout','translations','dntInit','dntReset','region',
   function($scope, $window, $route, $timeout, translations, dntInit, dntReset, region) {
  'use strict';
     
  document.body.className = 'default-back';
  $window.document.title = 'DN Gear Sim | SETUP';
  
  $scope.advancedSetup = false;
  $scope.isLoading = translations.startedLoading && !translations.isLoaded();
  $scope.translationResults = [];
  $scope.hostedFiles = region.hostedFiles;
  
  var noLocation = '';
  var sessionLocation = region.alternativeFiles.url;
  if(sessionLocation == null) {
    sessionLocation = noLocation;
  }
  
  $scope.location = sessionLocation;
  if($scope.location == noLocation) {
    $scope.testResults = ['No location set'];
  }
  else {
    $scope.testResults = ['Using location ' + $scope.location];
  }
  
  $scope.setLocation = function(url) {
    $scope.location = url;
    $scope.isLoading = true;
    $scope.saveLocation();
    dntReset();

    $scope.translationResults = [];
    var existingFile = localStorage.getItem('UIStrings_file');
    if(existingFile == null || existingFile.indexOf(url) == -1) {
      sessionStorage.removeItem('UIStrings');
    }
    translations.reset();
    translations.location = url;
    translations.init(progressTranslations, translationsStatus);
  }
  
  $scope.resetSessionData = function() {
    $scope.testResults = ['session data reset.. reloading page'];
    region.tlocation = null;
    region.dntLocation = null;
    translations.reset();
    sessionStorage.clear();
    localStorage.clear();
    this.saveLocation();
    $timeout(function() {   
      location.hash = '';
      location.reload(true);
    });
  }
  
  $scope.loadUiString = function() {
    $scope.translationResults = [];
    sessionStorage.removeItem('UIStrings');
    dntReset();
    translations.reset();
    translations.location = region.tlocation.url;
    translations.init(progressTranslations, translationsStatus);
  }
  
  function translationsStatus() {
    progressTranslations('current translations contain words like ' + translations.translate(329) + ', ' + translations.translate(323) + ' and ' + translations.translate(335));
    $scope.isLoading = false;
  }
  
  function progress(msg) {
    $timeout(
      function() {
        if($scope.testResults != null) {
          $scope.testResults.push(msg);
        }
      });
  }
  
  function progressTranslations(msg) {
    $timeout(
      function() {
        if($scope.translationResults != null) {
          $scope.translationResults.push(msg);
        }
      });
  }
  
  $scope.saveLocation = function() {
    dntReset();
    if($scope.location != noLocation) {
      region.setCustomUrl($scope.location);
      
      region.init();
      if(region.alternativeFiles.region == region.tlocation.region) {
        translations.reset();
        translations.init(progressTranslations, translationsStatus);
      }
      $scope.testResults = [
        'Location saved',
        'Using location ' + $scope.location];
    }
  }
  
  $scope.testLocation = function() {
    if($scope.location != noLocation) {
      $scope.testResults = [
        'Using location ' + $scope.location,
        'Loading all data used by the app'];

      translations.init(progress, function () {
        dntInit(progress);
      });
    }
  }
}]);

angular.module('dnsim').controller('groupAssignmentCtrl',

['hCodeValues','statHelper','saveHelper','itemCategory','$scope',
function(hCodeValues,statHelper,saveHelper,itemCategory,$scope) {
  'use strict';
  
  var vm = this;
  
  this.savedItems = saveHelper.getSavedItems();
  this.groupNames = Object.keys(this.savedItems);
  if(!this.groupNames) {
    this.groupNames = [];
  }
  if(this.groupNames.length > 0) {
    this.groupName = saveHelper.getCurrentBuild();
  }
  else {
    this.groupName = null;
  }
  
  if(!this.groupName || !(this.groupName in this.savedItems)) {
    if(this.groupNames.length > 0) {
      this.groupName = this.groupNames[0];
    }
  }
  
  if(!this.groupName) {
    return;
  }
  
  this.summaryStatIds = [];
  for(var id in hCodeValues.stats) {
    if(hCodeValues.stats[id].summaryDisplay) {
      this.summaryStatIds.push(id);
    }
  }
    
  this.clearGroup = function() {
    vm.addAffectAmount = null;
    vm.replaceAffectAmount = {};

    vm.groupItems = null;
    vm.groupCalcStats = null;
  }

  $scope.$watch('editCtrl.item', function() {
    vm.clearGroup();
  });
  
  this.getAddAffectAmount = function(stat) {
    this.initAddAffects();
    // console.log('add affect: ', this.addAffectAmount[stat], this.item);
    return this.addAffectAmount[stat];
  };
  
  this.getReplaceAffectAmount = function(statId, itemIndex, item) {
    this.initReplaceAffects(itemIndex, item);
    return this.replaceAffectAmount[itemIndex][statId];
  };
  
  this.getGroupCalcStats = function() {
    
    if(this.groupCalcStats == null) {
      
      var group = vm.savedItems[vm.groupName];
      if(group) {
        this.groupCalcStats = statHelper.getCalculatedStatsFromItems(group, group.items);
      }
    }
    
    return this.groupCalcStats;
  };
  
  this.getBuild = function() {
    return vm.savedItems[vm.groupName];
  };
  
  this.initAddAffects = function() {
    
    if(vm.addAffectAmount) {
      return;
    }
    
    // console.log('initialising add affects ');
    
    var origStats = vm.getGroupCalcStats();
    var group = vm.savedItems[vm.groupName];
    var newItems = [];
    if(group.items) {
      newItems = group.items.concat([vm.item]);
    }
    var newStats = statHelper.getCalculatedStatsFromItems(group, newItems);
    
    this.addAffectAmount = {};
    for(var id in hCodeValues.stats) {
      if(hCodeValues.stats[id].summaryDisplay) {
        vm.addAffectAmount[id] = calcStatPercent(vm.getStat(id, newStats).max, vm.getStat(id, origStats).max);
      }
    }
  };
  
  this.initReplaceAffects = function(itemIndex, item) {
    if(vm.replaceAffectAmount[itemIndex]) {
      return;
    }
    
    var group = vm.savedItems[vm.groupName];
    var newItems = [vm.item];
    angular.forEach(group.items, function(gItem , index) {
      if(item !== gItem) {
        newItems.push(gItem);
      }
    });
    
    var newStats = statHelper.getCalculatedStatsFromItems(group, newItems);
    var origStats = vm.getGroupCalcStats();
    
    this.replaceAffectAmount[itemIndex] = {};
    for(var id in hCodeValues.stats) {
      if(hCodeValues.stats[id].summaryDisplay) {
        vm.replaceAffectAmount[itemIndex][id] = calcStatPercent(vm.getStat(id, newStats).max, vm.getStat(id, origStats).max);
      }
    }
  };
  
  function calcStatPercent(newVal, origVal) {
    if(newVal && origVal) {
      // console.log('orig: ' + origVal + ',new: ' + newVal);
      return Math.round(10000 * (1 - (origVal / newVal))) / 100;
    }
    else {
      return 0;
    }
  }
  
  this.getStat = function(id, stats) {
    var len = stats.length;
    for(var i=0;i<len;++i) {
      if(stats[i].id == id) {
        return stats[i];
      }
    }
    return {id: id, max:0};
  };
  
  this.getStatName = function(id) {
    var retVal = '';
    if(hCodeValues.stats[id].element == 'primary') {
      var eleId = 0;
      if(vm.savedItems[vm.groupName].element) {
        eleId = vm.savedItems[vm.groupName].element.id;
      }
      retVal += hCodeValues.elements[eleId].name;
    }
    else if(hCodeValues.stats[id].element == 'secondary') {
      var eleId = 0;
      if(vm.savedItems[vm.groupName].secondaryElement) {
        eleId = vm.savedItems[vm.groupName].secondaryElement.id;
      }
      retVal += hCodeValues.elements[eleId].name;
    }
    return retVal + ' ' + hCodeValues.stats[id].name;
  };
  
  this.getGroupItems = function() {

    var itemSplit;
    function numMatches(str) {
      if(str) {
        var numMatches = 0;
        for(var i=0;i<itemSplit.length;++i) {
          if(str.indexOf(itemSplit[i]) > 0) {
            numMatches++;
          }
        }
        return numMatches;
      }
      else {
        return -1;
      }
    }
    
    if(vm.groupItems == null && vm.groupName && vm.groupName in vm.savedItems && vm.item && vm.item.typeName) {
      vm.groupItems = [];
      
      var items = [];
      angular.forEach(vm.savedItems[vm.groupName].items, function(item, index) {
        if(item.exchangeType && item.itemSource != 'gem' && item.itemSource != 'plate') {
          if(item.exchangeType == vm.item.exchangeType) {
            items.push(item);
          }
        }
        else if(item.typeName == vm.item.typeName) {
          items.push(item);
        }
      });
      
      if(vm.item.name) {
        itemSplit = vm.item.name.split(' ');
      }
      items.sort(function(a,b) {
        return numMatches(b.name)-numMatches(a.name);
      });
      
      angular.forEach(items, function(item, index) {
        if(item.name == vm.item.name) {
          vm.groupItems.push(item);
        }
      });
      
      angular.forEach(items, function(item, index) {
        if(item.name != vm.item.name) {
          vm.groupItems.push(item);
        }
      });
    }
    return vm.groupItems;
  };
  
  this.hasMaxExchangable = function() {
    var cat = itemCategory.byName(this.item.typeName);
    var items = this.getGroupItems();
    
    if(cat && cat.maxCat) {
      if(items.length >= cat.maxCat) {
        return true;
      }
    }
    
    if(cat && cat.maxExchange) {
      if(items.length >= cat.maxExchange) {
        for(var i=0;i<items.length;++i) {
          if(!items[i].exchangeType) {
            return false;
          }
        }
        // console.log('maxexchange reached ' + items.length + '>=' + cat.maxExchange + ' for ' + cat.name);
        return true;
      }
    }
    return false;
  };
  
  this.nextGroup = function() {
    
    var uptoItem = false;
    var nextGroup = null;
    angular.forEach(vm.groupNames, function(groupName, index) {
      if(uptoItem) {
        if(nextGroup == null) {
          nextGroup = groupName;
        }
      }
      if(groupName == vm.groupName) {
        uptoItem = true;
      }
    });
    
    if(nextGroup == null) {
      nextGroup = vm.groupNames[0];
    }
    
    vm.groupName = nextGroup;
    saveGroup();
    vm.clearGroup();
  };
  
  this.prevGroup = function() {
    
    var foundGroup = false;
    var prevGroup = null;
    angular.forEach(vm.groupNames, function(groupName, index) {
      if(groupName == vm.groupName) {
        foundGroup = true;
      }
      
      if(!foundGroup) {
        prevGroup = groupName;
      }
    });
    
    if(prevGroup == null) {
      prevGroup = vm.groupNames[vm.groupNames.length-1];
    }
    
    vm.groupName = prevGroup;
    saveGroup();
    vm.clearGroup();
  };
  
  this.addToGroup = function() {
    saveHelper.saveItem(vm.groupName, vm.item);
    this.savedItems = saveHelper.getSavedItems();
    vm.clearGroup();
  };
  
  this.replace = function(item) {
    item.replaceItem = true;
    var newItemList = [];
    angular.forEach(vm.savedItems[vm.groupName].items, function(gItem, index) {
      if(gItem.replaceItem) {
        // console.log('found replace item');
        newItemList.push(vm.item);
      }
      else {
        newItemList.push(gItem);
      }
    });
    
    saveHelper.updatedSavedItems(vm.groupName, newItemList);
    this.savedItems = saveHelper.getSavedItems();
    vm.clearGroup();
  };
  
  function saveGroup() {
    saveHelper.saveBuildSelection(vm.groupName, vm.savedItems);
  }
  
}])
.directive('dngearsimGroupAssignment', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'groupAssignmentCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/group-assignment.html'
  };
});
angular.module('dnsim').controller('itemEditCustomCtrl',

['hCodeValues','$scope',
function(hCodeValues,$scope) {
  'use strict';
  
  if(this.item == null) return;
  if(this.item.itemSource != 'custom' && this.item.typeName != 'custom') {
    return;
  }
  
  var vm = this;

  this.statMap = {};
  
  // console.log(vm.item.stats);
  _.forEach(vm.item.stats, function(stat) {
    // console.log('got stat', stat.id);
    vm.statMap[stat.id] = stat.max;
  });
  
  for(var statId in hCodeValues.stats) {
    $scope.$watch('editCtrl.statMap[' + statId + ']', function(newValue, oldValue) { 

      if(newValue != oldValue) {
        // console.log(statId);
        // console.log('watch got stat value', newValue);

        var anyChange = false;
        var newStats = [];
        for(var statId in vm.statMap) {

          if(!vm.statMap[statId] || !Number(vm.statMap[statId])) {
            _.each(vm.item.stats, function(stat) { 
              if(stat.id == statId) {
                anyChange = true;
              }
            });
          }
          else {
            newStats.push({
              id: Number(statId),
              max: Number(vm.statMap[statId])
            });

            var found = false;
            _.each(vm.item.stats, function(stat) {
              if(stat.id == statId) {
                found = true;
                // console.log('comparing', stat.max, vm.statMap[statId]);
                if(!(statId in vm.statMap) || stat.max != vm.statMap[statId]) {
                  anyChange = true;
                }
              } 
            });

            if(!found) {
              anyChange = true;
            }
          }
        }

        if(anyChange) {
          // console.log('GOT CHANGES!', newStats);
          vm.item.stats = newStats;
          vm.onChange();
        }
      }
    });
  }
  
}])
.directive('dngearsimItemEditCustom', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
    },
    controller: 'itemEditCustomCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-custom.html'
  };
});
angular.module('dnsim').controller('itemEditEnchantmentCtrl',

['dntData','hCodeValues','items','$timeout','translations','itemColumnsToLoad',
function(dntData,hCodeValues,items,$timeout,translations,itemColumnsToLoad) {
  'use strict';
  
  var vm = this;
  
  if(vm.item == null) return;
  if('itemSource' in this.item) {
    vm.itemType = items[vm.item.itemSource];
  }
  
  if(!vm.itemType || !('enchantDnt' in vm.itemType)) {
    return;
  }
  
  if(vm.itemType.enchantDnt) {
    dntData.init(vm.itemType.enchantDnt, itemColumnsToLoad.enchantDnt, null, vm.getEnchantments);
  }
  
  vm.enchantments = null;
  vm.enchantment = null;
  vm.enchantmentAfter = null;
  vm.enchantmentCost = '';
  vm.enhancementOptions = [];
  if(vm.item.enchantmentStats == null) {
    vm.item.enchantmentStats = [];
  }
  
  this.setEnchantment = function() {
    vm.item.enchantmentStats = [];

    if(vm.enchantments && vm.enchantments.length > 0) {

      if(typeof vm.item.enchantmentNum != 'number') {
        vm.item.enchantmentNum = 6;
        vm.onChange();
      }
      
      for(var i=0;i<vm.enchantments.length;++i) {
        if(vm.item.enchantmentNum == vm.enchantments[i].EnchantLevel) {
          vm.enchantment = vm.enchantments[i];
          
          vm.item.enchantmentStats = hCodeValues.getStats(vm.enchantment);
        }
        else if(vm.item.enchantmentNum + 1 == vm.enchantments[i].EnchantLevel) {
          vm.enchantmentAfter = vm.enchantments[i];
          if(vm.enchantmentAfter.NeedCoin < 10000) {
            vm.enchantmentCost = Math.round(vm.enchantmentAfter.NeedCoin / 1000)/10 + 'g';
          }
          else {
            vm.enchantmentCost = Math.round(vm.enchantmentAfter.NeedCoin / 10000) + 'g';
          }
        }
      }
    }
  }
  
  this.isMaxEnchantLevel = function() {

    if(vm.enchantments != null &&
      vm.enchantments.length > 0 &&
      typeof vm.item.enchantmentNum == 'number') {

      for(var i=0;i<vm.enchantments.length;++i) {
        if(vm.item.enchantmentNum + 1 == vm.enchantments[i].EnchantLevel) {
          return false;
        }
      }
      return true;
    }
    else {
      return false;
    }
  }
  
  this.setEnchantmentNum = function(enhancementOption) {
    vm.item.enchantmentNum = enhancementOption;
    vm.enhancementOptions = [];
    vm.setEnchantment();
    vm.onChange();
  }
  
  this.nextEnchantment = function() {
    for(var i=vm.item.enchantmentNum;i==0||vm.enchantments[i-1];++i) {
      if(i == 0) {
        vm.enhancementOptions.push({number: 0});
      }
      else {
        vm.enhancementOptions.push(vm.getOption(vm.enchantments[i-1]));
      }
    }
  }
  
  this.prevEnchantment = function() {
    vm.enhancementOptions = [];
    for(var i=vm.item.enchantmentNum;i>0;--i) {
      vm.enhancementOptions.push(vm.getOption(vm.enchantments[i-1]));
    }
    
    vm.enhancementOptions.push({number: 0});
  }
  
  this.getOption = function(enchantment) {
    return {
      number: enchantment.EnchantLevel,
      stats: hCodeValues.getStats(enchantment)
    };
  }
  
  this.getEnchantments = function() {
    if(!vm.enchantments && vm.item && vm.item.enchantmentId) {
      if(dntData.isLoaded(vm.itemType.enchantDnt)) {
        var eid = vm.item.enchantmentId;
        vm.enchantments = dntData.find(vm.itemType.enchantDnt, 'EnchantID', eid);
        vm.setEnchantment();
      }
    }
    
    return vm.enchantments;
  }
  
  var fileName = 'all-items.lzjson';
  
  this.showMaterials = function() {
    dntData.init(fileName, null, function() {}, function() {
      $timeout(function() {
        
        if(!vm.enchantmentAfter) {
          return;
        }
        
        vm.materials = [];
        for(var i=1;i<=5;++i) {
          var itemId = vm.enchantmentAfter['NeedItemID' + i];
          var itemCount = vm.enchantmentAfter['NeedItemCount' + i];
          if(itemId > 0 && itemCount > 0) {
            
            var items = dntData.find(fileName, 'id', itemId);
            if(items.length == 0) {
              vm.materials.push({num: itemCount, name: 'unknown (' + itemId + ')'});
            }
            else {
              var item = items[0];
              var name = translations.translate(item.NameID, item.NameIDParam);
              
              if(item) {
                var material = {
                  num: itemCount,
                  icon: item.IconImageIndex,
                  rank: item.Rank,
                  levelLimit: item.LevelLimit,
                  name: name
                };
                vm.materials.push(material);
              }
            }
          }
        }
      });
    });
  }
  
  if(dntData.isLoaded(fileName)) {
    this.showMaterials();
  }

  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
}])
.directive('dngearsimItemEditEnchantment', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
    },
    controller: 'itemEditEnchantmentCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-enchantment.html'
  };
});
angular.module('dnsim').controller('itemEditPotentialCtrl',

['dntData','items','hCodeValues','itemColumnsToLoad',
function(dntData,items,hCodeValues,itemColumnsToLoad) {
  'use strict';
  
  var vm = this;
  
  this.potentials = null;
  this.potential = null;
  this.changingPotentials = false;
  this.potentialStats = {};
  
  if(this.item == null) return;
  
  if('itemSource' in this.item) {
    this.itemType = items[this.item.itemSource];
  }
  
  if(!this.itemType || !this.item.pid || !('potentialDnt' in this.itemType)) {
    return;
  }
  
  if(vm.itemType.potentialDnt) {
    dntData.init(vm.itemType.potentialDnt, itemColumnsToLoad.potentialDnt, null, vm.getPotentials);
  }
  
  this.getPotentials = function() {
    if(!vm.potentials) {
      if(vm.item && vm.item.pid && 'potentialDnt' in vm.itemType) {
        var potentials = dntData.find(vm.itemType.potentialDnt, 'id', vm.item.pid);
        
        if(potentials.length == 1) {
          vm.potential = potentials[0];
          vm.potentials = dntData.find(vm.itemType.potentialDnt, 'PotentialID', vm.potential.PotentialID);
          vm.potentialStats = getPotentialStats(vm.potentials);
        }
        else if('potentialDntEx' in vm.itemType) {
          potentials = dntData.find(vm.itemType.potentialDntEx, 'id', vm.item.pid);
        
          if(potentials.length == 1) {
            vm.potential = potentials[0];
            vm.potentials = dntData.find(vm.itemType.potentialDntEx, 'PotentialID', vm.potential.PotentialID);
            vm.potentialStats = getPotentialStats(vm.potentials);
          }
        }
      }
    }
    
    return vm.potentials;
  }
  
  this.nextPotential = function() {
    for(var i=0;i<vm.potentials.length;++i) {
      if(vm.potential.id == vm.potentials[i].id) {
        vm.potential = vm.potentials[i+1];
        vm.item.pid = vm.potential.id;
        vm.onChange();
        this.changingPotentials = true;
        return;
      }
    }
  }
  
  this.prevPotential = function() {
    for(var i=0;i<vm.potentials.length;++i) {
      if(vm.potential.id == vm.potentials[i].id) {
        vm.potential = vm.potentials[i-1];
        vm.item.pid = vm.potential.id;
        vm.onChange();
        this.changingPotentials = true;
        return;
      }
    }
  }
    
  this.changePotential = function(pid) {
    for(var i=0;i<vm.potentials.length;++i) {
      if(pid == vm.potentials[i].id) {
        vm.potential = vm.potentials[i];
        vm.item.pid = vm.potential.id;
        vm.changingPotentials = false;
        vm.onChange();
        return;
      }
    }
  }
  
  this.isFirstPotential = function() {
    this.getPotentials();
    return !vm.potentials || vm.potentials.length <= 1 || !vm.potential || vm.potential.id == vm.potentials[0].id;
  }
  
  this.isLastPotential = function() {
    this.getPotentials();
    return !vm.potentials || vm.potentials.length <= 1 || !vm.potential || vm.potential.id == vm.potentials[vm.potentials.length-1].id;
  }
  
  function getPotentialStats() {
    var pStats = {};
    var emptyStatId = null;
    
    if(vm.potentials != null) {
      angular.forEach(vm.potentials, function(p, index) {
        var stats = [];
        angular.forEach(hCodeValues.getStats(p), function(stat, sIndex) {
          if(!hCodeValues.stats[stat.id].hide) {
            stats.push(stat);
          }
        });
        
        if(stats.length > 0) {
          pStats[p.id] = stats;
        }
        else if(!emptyStatId) {
          pStats[p.id] = [];
          emptyStatId = p.id;
        }
      });
    }
    
    return pStats;
  }
  
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }

}])
.directive('dngearsimItemEditPotential', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
    },
    controller: 'itemEditPotentialCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-potential.html'
  };
});
angular.module('dnsim').controller('itemEditSkillCtrl',

['$timeout','dntData','statHelper',
function($timeout,dntData,statHelper) {
  'use strict';
  
  if(this.item == null) return;
  if(this.item.itemSource != 'skills') {
    return;
  }
  
  if(!this.item.enchantmentNum) {
    this.item.enchantmentNum = 1;
  }
  
  var vm = this;
  
  function getDntFile() {
    return 'skillleveltable_character' + vm.item.baseJobName + vm.item.pve + '.lzjson';
  }
  
  this.initSkills = function() {
    var dntFile = getDntFile();
    dntData.init(dntFile, null, reportProgress, function() { $timeout(function() {
      vm.skillData = dntData.find(dntFile, 'SkillIndex', vm.item.id);
    })});
  }
  
  this.nextEnchantment = function() {
    if(this.skillData && this.item.enchantmentNum < this.skillData.length) {
      this.item.enchantmentNum++;
      vm.onChange();
    }
  }
  
  this.isMaxSkillLevel = function() {
    return this.skillData && this.item && this.item.enchantmentNum >= this.skillData.length;
  }
  
  this.prevEnchantment = function() {
    if(this.item.enchantmentNum > 0) {
      this.item.enchantmentNum--;
    }
    else {
      this.item.enchantmentNum = 0;
    }

    vm.onChange();
  }
  
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
  
  dntData.init(getDntFile(), null, null, vm.initSkills);

}])
.directive('dngearsimItemEditSkill', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
    },
    controller: 'itemEditSkillCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-skill.html'
  };
});
angular.module('dnsim').controller('itemEditSparkCtrl',

['dntData','hCodeValues','items','itemColumnsToLoad',
function(dntData,hCodeValues,items,itemColumnsToLoad) {
  'use strict';
  
  var vm = this;
  
  if(this.item == null) return;
  if('itemSource' in this.item) {
    this.itemType = items[this.item.itemSource];
  }
  
  if(!vm.itemType || !vm.itemType.sparkDnt) {
    return
  }
  
  if(vm.itemType.sparkDnt) {
    dntData.init(vm.itemType.sparkDnt, itemColumnsToLoad.sparkDnt, null, vm.getSparks);
  }
  
  this.sparks = null;

  this.nextSpark = function() {
    var index = getPotentialIndex();
    index++;
    if(index >= vm.sparks.length) {
      index = 0;
    }
    var spark = vm.sparks[index]; 
    vm.item.sparkId = spark.id;
    vm.item.sparkStats = hCodeValues.getStats(spark);
    vm.onChange();
  }
  
  this.isMoreSparks = function() {
    return vm.sparks != null && getPotentialIndex() >= vm.sparks.length-1;
  }
  
  this.isFirstSpark = function() {
    return getPotentialIndex() == 0;
  }
  
  this.prevSpark = function() {
    var index = getPotentialIndex();
    index--;
    if(index < 0) {
      index = vm.sparks.length-1;
    }
    var spark = vm.sparks[index]; 
    vm.item.sparkId = spark.id;
    vm.item.sparkStats = hCodeValues.getStats(spark);
    vm.onChange();
  }
  
  this.removeSpark = function() {
    vm.item.sparkId = null;
    vm.item.sparkStats = null;
    vm.onChange();
  }
  
  this.getSparks = function() {
    if(vm.item == null || vm.itemType == null) return null;
    if(vm.sparks == null) {
      var sid = vm.item.sparkTypeId;
      if(sid) {
        if(dntData.isLoaded(vm.itemType.sparkDnt)) {
          vm.sparks = dntData.find(vm.itemType.sparkDnt, 'PotentialID', sid);
        }
      }
    }
    
    return vm.sparks;
  }

  function getPotentialIndex() {
    var potentialIndex = -1;
    if(vm.item.sparkId > 0) {
      angular.forEach(vm.sparks, function(spark, index) {
        if(spark.id == vm.item.sparkId) {
          potentialIndex = index;
          return;
        }
      });
    }
      
    return potentialIndex;
  }

  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
}])
.directive('dngearsimItemEditSpark', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
    },
    controller: 'itemEditSparkCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-spark.html'
  };
});
angular.module('dnsim').controller('itemEditTalismanCtrl',

[function() {
  'use strict';
  
  if(this.item == null) return;
  if(this.item.itemSource != 'tman') {
    return;
  }
  
  this.setTalisman = function(amount) {
    if(amount == 0) {
      this.item.enchantmentNum = null;
      this.item.enchantmentStats = [];
    }
    else {
      this.item.enchantmentNum = amount;
      
      var extraStats = [];
      angular.forEach(this.item.stats, function(stat, index) {
        extraStats.push({id: stat.id, max: stat.max * (amount/100)});
      });
      
      this.item.enchantmentStats = extraStats;
    }
    this.onChange();
  }

}])
.directive('dngearsimItemEditTalisman', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
    },
    controller: 'itemEditTalismanCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-talisman.html'
  };
});
angular.module('dnsim').controller('itemEditCtrl',

['hCodeValues',
function(hCodeValues) {
  'use strict';
  
  var vm = this;
  
  if(vm.item == null) return;
  
  vm.onUpdateItem = function() {
    vm.updateItem();
  }
  
}])
.directive('dngearsimItemEdit', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
      updateItem: '&updateItem'
    },
    controller: 'itemEditCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-edit.html'
  };
});
angular.module('dnsim').controller('itemViewBoxCtrl',

['$timeout','dntData','itemFactory',
  function($timeout, dntData, itemFactory) {
  'use strict';
  
  if(this.item == null) return;
  if(this.item.typeId != 46 && this.item.typeId != 8 && this.item.typeId != 112 && this.item.typeId != 122) {
    console.log('not box item type ' + this.item.typeId);
    return;
  }
  
  var vm = this;
  
  var pouchFileNames = [
    'itemdroptable.lzjson',
    'itemdroptable_abyss.lzjson',
    'itemdroptable_apprentice.lzjson',
    'itemdroptable_cook.lzjson',
    'itemdroptable_darklair.lzjson',
    'itemdroptable_dimension.lzjson',
    'itemdroptable_disjoint.lzjson',
    'itemdroptable_dnexpedition.lzjson',
    'itemdroptable_event.lzjson',
    'itemdroptable_farm.lzjson',
    'itemdroptable_fishing.lzjson',
    'itemdroptable_guildwar.lzjson',
    'itemdroptable_item.lzjson',
    'itemdroptable_monsteritem.lzjson',
    'itemdroptable_propdrop.lzjson',
    'itemdroptable_pvp.lzjson',
    'itemdroptable_randomcompound.lzjson',
    'itemdroptable_stageclear.lzjson',
    'itemdroptable_themepark.lzjson',
    'itemdroptable_union.lzjson']
  
  var allItemFileName = 'all-items.lzjson';
  var charmItemtable = 'charmitemtable.lzjson';
  var commonCharmItemtable = 'charmitemtable_common.lzjson';
  
  var files;
  if(this.item.typeId == 46 || this.item.typeId == 112 || this.item.typeId == 122) {
    files = [allItemFileName, charmItemtable, commonCharmItemtable];
  }
  else if (this.item.typeId == 8) {
    files = [allItemFileName].concat(pouchFileNames);
  }

  for(var i=0;i<files.length;++i) {
    dntData.init(files[i], null, function() {}, function() {
      $timeout(function() {
        vm.initBoxContents();
      });
    });
  }
  
  this.initBoxContents = function() {
    console.log('init contents', this.item.fileName);

    for(var i=0;i<files.length;++i) {
      if(!dntData.isLoaded(files[i])) {
        return;
      }
    }

    var datas = dntData.find(this.item.fileName + '.lzjson', 'id', this.item.id);
    if(datas.length > 0) {
      var d = datas[0];
      vm.items = [];
      
      
      if(vm.item.typeId == 46 || vm.item.typeId == 112 || vm.item.typeId == 122) {
        vm.getCharmItems(d.TypeParam1);
      }
      else if (vm.item.typeId == 8) {
        vm.getPouchItems(d.TypeParam1);
      }
      
    }
  }
  
  this.getPouchItems = function(boxType) {
    for(var f=0;f<pouchFileNames.length;++f) {
      vm.getPouchItemsFromFile(boxType, pouchFileNames[f]);
    }
  }
  
  this.getPouchItemsFromFile = function(boxType, pouchFileName) {
    
    var pouchData = dntData.find(pouchFileName, 'id', boxType);
    if(pouchData.length == 0) {
    }
    else {
      var gold = pouchData[0].GoldMin;

      var itemIndex = 0;
      do {
        itemIndex++;
        var isGroup = pouchData[0]['IsGroup' + itemIndex];
        var pouchItem = pouchData[0]['Item' + itemIndex + 'Index'];
        var pouchItemCount = pouchData[0]['Item' + itemIndex + 'Info'];
        //console.log('pouch contains ' + pouchItem);
        if(pouchItem) {
          if(isGroup) {
            vm.getPouchItems(pouchItem, pouchFileName);
          }
          else {
            // console.log('adding item ' + pouchItem);
            var itemds = dntData.find(allItemFileName, 'id', pouchItem);
            if(itemds.length > 0) {
              var basicItem = itemFactory.createBasicItem(itemds[0]);
              // console.log('found item ' + basicItem.name);
  
              vm.items.push({
                count: pouchItemCount,
                gold: gold,
                item: basicItem
              });
            }
          }
        }
      } while(pouchItem);
    }
  }
  
  this.getCharmItems = function(boxType) {
    var charmFiles = [charmItemtable, commonCharmItemtable];
    for(var i=0;i<charmFiles.length;++i) {

      var charmData = dntData.getData(charmFiles[i]);
      console.log('box: ' + boxType, charmData);
      
      for(var c=0;c<charmData.length;++c) {
        var cd = charmData[c];
        if(cd.CharmNum == boxType && cd.Look) {
          
          var itemds = dntData.find(allItemFileName, 'id', cd.ItemID);
          if(itemds.length > 0) {
            vm.items.push({
              count: cd.Count,
              gold: cd.Gold,
              item: itemFactory.createBasicItem(itemds[0])
            });
          }
        }
      }
    }
  }

}])
.directive('dngearsimItemViewBox', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewBoxCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-box.html'
  };
});
angular.module('dnsim').controller('itemViewCraftCtrl',

['$timeout','dntData','itemFactory','hCodeValues','translations',
  function($timeout, dntData, itemFactory, hCodeValues, translations) {
  'use strict';
  
  if(this.item == null) return;
  
  var vm = this;
  vm.crafts = [];

  var cFiles = [
    'itemcompoundtable.lzjson',
    'itemcompoundtable_custom.lzjson',
    'itemcompoundtable_glyph.lzjson',
    'itemcompoundtable_jewel.lzjson',
    'itemcompoundtable_renewal.lzjson',
    'itemcompoundtable_set.lzjson'];
  
  var allItemFileName = 'all-items.lzjson';
  
  var files = cFiles.concat([allItemFileName]);
  for(var i=0;i<files.length;++i) {
    dntData.init(files[i], null, function() {}, function() {
      $timeout(function() {
        vm.initCrafts();
      });
    });
  }
  
  this.initCrafts = function() {
    for(var i=0;i<files.length;++i) {
      if(!dntData.isLoaded(files[i])) {
        return;
      }
    }
    
    vm.crafts = [];
    for(var i=0;i<cFiles.length;++i) {
      vm.initCraft(cFiles[i]);
    }
    
    var newCrafts = [];
    for(var i=0;i<vm.crafts.length;++i) {
      var found = false;
      for(var j=0;j<newCrafts.length;++j) {
        if(vm.crafts[i].gold == newCrafts[j].gold &&
          vm.crafts[i].items.length == newCrafts[j].items.length) {
            
            found = true;
            for(var k=0;k<vm.crafts[i].items.length;++k) {
              if(vm.crafts[i].items[k].item.id != newCrafts[j].items[k].item.id ||
                vm.crafts[i].items[k].num != newCrafts[j].items[k].num) {
                  found = false;
              }
            }
        }
      }
      
      if(!found) {
        newCrafts.push(vm.crafts[i]);
      }
    }
    
    vm.crafts = newCrafts;
  }

  this.initCraft = function(fileName) {
    var fCrafts = dntData.find(fileName, 'SuccessItemID1', vm.item.id);
    
    for(var i=0;i<fCrafts.length;++i) {
      var c = fCrafts[i];
      
      var craft = {
        id: c.id,
        fileName: fileName.replace('.lzjson', ''),
        gold: c.Cost/100/100,
        items: [],
      };
      
      var j=0;
      for(;;) {
        j++;
        var itemColName = 'Slot' + j +'Id';
        var qtyColName = 'Slot' + j +'Num';
        if(!(itemColName in c)) {
          break;
        }

        var items = dntData.find(allItemFileName, 'id', c[itemColName]);
        if(items.length > 0) {
          craft.items.push({
            item: itemFactory.createBasicItem(items[0]),
            num: c[qtyColName],
          });
        }
      }
      
      vm.crafts.push(craft);
    }
  }

}])
.directive('dngearsimItemViewCraft', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewCraftCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-craft.html'
  };
});
angular.module('dnsim').controller('itemViewExtractionCtrl',

['$timeout','dntData','itemFactory','items',
  function($timeout, dntData, itemFactory, items) {
  'use strict';
  
  if(this.item == null) return;
  
  var vm = this;
  
  var extractFileName = 'itemdroptable_disjoint.lzjson';
  var allItemFileName = 'all-items.lzjson';
  
  var files = [extractFileName,allItemFileName];
  for(var i=0;i<files.length;++i) {
    dntData.init(files[i], null, function() {}, function() {
      $timeout(function() {
        vm.initExtract();
      });
    });
  }
  
  this.initExtract = function() {
    for(var i=0;i<files.length;++i) {
      if(!dntData.isLoaded(files[i])) {
        return;
      }
    }
    
    var disjoint;
    var d = itemFactory.getItemData(vm.item);
    if(d && d.DisjointDrop1 > 0) {
      disjoint = d.DisjointDrop1;
    }
    
    var itemType = items[vm.item.itemSource];
    
    if(itemType && d.EnchantID) {
      var enchantments = dntData.find(itemType.enchantDnt, 'EnchantID', d.EnchantID);
      for(var i=0;i<enchantments.length;++i) {
        if(enchantments[i].EnchantLevel == vm.item.enchantmentNum) {
          disjoint = enchantments[i].DisjointDrop;
          break;
        }
      }
    }
    
    vm.items = [];
    if(disjoint) {
      vm.getItems(disjoint);
    }
  }
  
  this.getGold = function() {
    var d = itemFactory.getItemData(this.item);
    return Number(d.Disjointamount)/100/100;
  }
  
  this.getItems = function(disjoint) {
    // console.log('checking ' + pouchFileName + ' for ' + boxType);
    
    var pouchData = dntData.find(extractFileName, 'id', disjoint);
    if(pouchData.length == 0) {
    }
    else {
      var gold = pouchData[0].GoldMin;

      var itemIndex = 0;
      do {
        itemIndex++;
        var isGroup = pouchData[0]['IsGroup' + itemIndex];
        var pouchItem = pouchData[0]['Item' + itemIndex + 'Index'];
        var pouchItemCount = pouchData[0]['Item' + itemIndex + 'Info'];
        //console.log('pouch contains ' + pouchItem);
        if(pouchItem) {
          if(isGroup) {
            vm.getItems(pouchItem);
          }
          else {
            var itemds = dntData.find(allItemFileName, 'id', pouchItem);
            if(itemds.length > 0) {
              //console.log('found item ');
  
              vm.items.push({
                count: pouchItemCount,
                gold: gold,
                item: itemFactory.createBasicItem(itemds[0]),
              });
            }
          }
        }
      } while(pouchItem);
    }
  }

}])
.directive('dngearsimItemViewExtraction', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewExtractionCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-extraction.html'
  };
});
angular.module('dnsim').controller('itemViewPlateCtrl',

['$timeout','dntData','itemFactory','hCodeValues','translations',
  function($timeout, dntData, itemFactory) {
  'use strict';
  
  if(this.item == null) return;
  
  var vm = this;
  vm.items = [];
  
  var plateFile = 'platetable.lzjson';
  var allItemFileName = 'all-items.lzjson';
  
  var allFiles = [plateFile,allItemFileName];
  for(var i=0;i<allFiles.length;++i) {
    dntData.init(allFiles[i], null, function() {}, function() {
      $timeout(function() {
        vm.initSets();
      });
    });
  }
  
  this.initSets = function() {
    for(var i=0;i<allFiles.length;++i) {
      if(!dntData.isLoaded(allFiles[i])) {
        return;
      }
    }
    
    vm.items = [];
    getPlates();
  }
  
  function getPlates() {
    var rows = dntData.find(plateFile, 'ItemID', vm.item.id);
    for(var r=0;r<rows.length;++r) {
      var row = rows[r];
      var col=0;
      for(;;) {
        col++;
        var colName = 'CompoundTableIndex' + col;
        if(!(colName in row)) {
          break;
        }

        var itemData = dntData.find(allItemFileName, 'id', row[colName]);
        if(itemData.length > 0) {
          vm.items.push(itemFactory.createBasicItem(itemData[0]));
        }
      }
    }
  }

}])
.directive('dngearsimItemViewPlate', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewPlateCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-plate.html'
  };
});
angular.module('dnsim').controller('itemViewSetCtrl',

['$timeout','dntData','itemFactory','hCodeValues','translations',
  function($timeout, dntData, itemFactory) {
  'use strict';
  
  if(this.item == null) return;
  
  var vm = this;
  vm.items = [];
  
  var files = [
  'partstable.optimised.lzjson',
  'partstable_cash.optimised.lzjson',
  'partstable_common2014.optimised.lzjson',
  'partstable_common2015.optimised.lzjson',
  'partstable_common2016.lzjson',
  'partstable_commoncash.lzjson',
  'partstable_equipment.optimised.lzjson',
  'partstable_event.lzjson',
  'partstable_guild.lzjson',
  'partstable_pvp.optimised.lzjson',
  'partstable_reboot.optimised.lzjson',
  'partstable_skilllevelup.lzjson',
  'weapontable.optimised.lzjson',
  'weapontable_cash.optimised.lzjson',
  'weapontable_common2014.optimised.lzjson',
  'weapontable_common2015.optimised.lzjson',
  'weapontable_common2016.lzjson',
  'weapontable_commoncash.lzjson',
  'weapontable_equipment.optimised.lzjson',
  'weapontable_event.lzjson',
  'weapontable_guild.lzjson',
  'weapontable_pvp.optimised.lzjson',
  'weapontable_reboot.optimised.lzjson',
  //'weapontable_skilllevelup.lzjson'
  ];
  
  var allItemFileName = 'all-items.lzjson';
  
  var allFiles = files.concat([allItemFileName]);
  for(var i=0;i<allFiles.length;++i) {
    dntData.init(allFiles[i], null, function() {}, function() {
      $timeout(function() {
        vm.initSets();
      });
    });
  }
  
  this.initSets = function() {
    for(var i=0;i<allFiles.length;++i) {
      if(!dntData.isLoaded(allFiles[i])) {
        return;
      }
    }
    
    vm.items = [];
    for(var i=0;i<files.length;++i) {
      getSetItems(files[i]);
    }
  }
  
  function getSetItems(fileName) {
    var rows = dntData.find(fileName, 'SetItemID', vm.item.setId);
    for(var r=0;r<rows.length;++r) {
      var itemData = dntData.find(allItemFileName, 'id', rows[r].id);
      if(itemData.length > 0) {
        vm.items.push(itemFactory.createBasicItem(itemData[0]));
      }
    }
  }

}])
.directive('dngearsimItemViewSet', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewSetCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-set.html'
  };
});
angular.module('dnsim').controller('itemViewShopCtrl',

['$timeout','dntData','itemFactory','hCodeValues','translations',
  function($timeout, dntData, itemFactory, hCodeValues, translations) {
  'use strict';
  
  if(this.item == null) return;
  
  var vm = this;
  vm.shopCosts = [];
  
  var cShopFileName = 'combinedshoptable.lzjson';
  var cSysShopFileName = 'combinedshoptable_system.lzjson';
  var cCashShopFileName = 'combinedshoptable_cash.lzjson';
  // var shopFileName = 'shoptable.lzjson';
  var allItemFileName = 'all-items.lzjson';
  
  var files = [cCashShopFileName,cSysShopFileName,cShopFileName,allItemFileName];
  for(var i=0;i<files.length;++i) {
    dntData.init(files[i], null, function() {}, function() {
      $timeout(function() {
        vm.initShops();
      });
    });
  }
  
  this.initShops = function() {
    for(var i=0;i<files.length;++i) {
      if(!dntData.isLoaded(files[i])) {
        return;
      }
    }
    
    vm.shopCosts = [];
    getCombinedCosts(cShopFileName);
    getCombinedCosts(cSysShopFileName);
    getCombinedCosts(cCashShopFileName);
    // getShopCosts();
    
    var newShopCosts = [];
    for(var i=0;i<vm.shopCosts.length;++i) {
      var found = false;
      for(var j=0;j<newShopCosts.length;++j) {
        if(vm.shopCosts[i].tabName == newShopCosts[j].tabName &&
          vm.shopCosts[i].gold == newShopCosts[j].gold &&
          vm.shopCosts[i].item1.id == newShopCosts[j].item1.id &&
          vm.shopCosts[i].numItem1.id == newShopCosts[j].numItem1.id &&
          vm.shopCosts[i].item2.id == newShopCosts[j].item2.id &&
          vm.shopCosts[i].numItem2.id == newShopCosts[j].numItem2.id) {
            found = true;
            break;
        }
      }
      
      if(!found) {
        newShopCosts.push(vm.shopCosts[i]);
      }
    }
    
    vm.shopCosts = newShopCosts;
  }
  
  /*
  function getShopCosts() {
    var shops = dntData.getData(shopFileName);
    
    for(var i=0;i<shops.length;++i) {
      var s = shops[i];
      
      var c = 0;
      for(;;) {
        ++c;
        
        var colName = 'itemIndex' + c;
        if(!(colName in s)) {
          break;
        }
        
        var itemId = s[colName];
        if(!itemId) {
          break;
        }
        
        if(itemId == vm.item.id) {
          s = {
            shopName: s.ShopID,
            tabName: translations.translate(s.TabNameID),
            gold: s['Quantity' + c],
          };
          
      
          if(s.shopName in hCodeValues.shopNames) {
            s.shopName = hCodeValues.shopNames[s.shopName];
          }
      
          if(!s.shopName) {
            s.shopName = s.ShopId;
          }
          vm.shopCosts.push(s);
        }
      }
    }
  }*/

  function getCombinedCosts(fileName) {
    var shops = dntData.find(fileName, 'itemindex', vm.item.id);
    
    for(var i=0;i<shops.length;++i) {
      var s = shops[i];
        
      var item1s = dntData.find(allItemFileName, 'id', s.PurchaseItem1);
      var item2s = dntData.find(allItemFileName, 'id', s.PurchaseItem2);
      
      var shopCost = {
        shopName: s.ShopID,
        tabName: translations.translate(s.TabNameID),
        gold: 0,
        nightmarePoints: 0,
        ladderPoints: 0,
        item1: itemFactory.createBasicItem(item1s[0]),
        item2: itemFactory.createBasicItem(item2s[0]),
        numItem1: 0,
        numItem2: 0,
      };
      
      if(shopCost.shopName in hCodeValues.shopNames) {
        shopCost.shopName = hCodeValues.shopNames[shopCost.shopName];
      }
      
      if(s.PurchaseType1 == 1) {
        shopCost.gold += s.PurchaseItemValue1;
      }
      else if(s.PurchaseType1 == 3) {
        shopCost.ladderPoints += s.PurchaseItemValue1;
      }
      else if(s.PurchaseType1 == 8) {
        shopCost.nightmarePoints += s.PurchaseItemValue1;
      }
      else {
        shopCost.numItem1 = s.PurchaseItemValue1;
      }
      
      if(s.PurchaseType2 == 1) {
        shopCost.gold += s.PurchaseItemValue2;
      }
      else if(s.PurchaseType2 == 3) {
        shopCost.ladderPoints += s.PurchaseItemValue2;
      }
      else if(s.PurchaseType2 == 8) {
        shopCost.nightmarePoints += s.PurchaseItemValue2;
      }
      else {
        shopCost.numItem2 = s.PurchaseItemValue2;
      }
      
      shopCost.gold = shopCost.gold/100/100;
      
      vm.shopCosts.push(shopCost);
    }
  }

}])
.directive('dngearsimItemViewShop', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewShopCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-shop.html'
  };
});
angular.module('dnsim').controller('itemViewTransferCtrl',

['$timeout','dntData','itemFactory','hCodeValues',
  function($timeout, dntData, itemFactory, hCodeValues) {
  'use strict';
  
  if(this.item == null) return;
  
  var vm = this;
  vm.matchingTransfers = [];
  
  var transferFileName = 'enchanttransfertable.lzjson';
  var allItemFileName = 'all-items.lzjson';
  var transferItemsFileName = 'enchanttransferitemtable.lzjson';
  
  var files = [transferFileName,allItemFileName,transferItemsFileName];
  for(var i=0;i<files.length;++i) {
    dntData.init(files[i], null, function() {}, function() {
      $timeout(function() {
        vm.initTransfers();
      });
    });
  }
  
  this.initTransfers = function() {
    for(var i=0;i<files.length;++i) {
      if(!dntData.isLoaded(files[i])) {
        return;
      }
    }
    vm.matchingTransfers = [];
    
    var transferItem = dntData.find(transferItemsFileName, 'ItemID', vm.item.id);
    if(transferItem && transferItem.length > 0) {
      var transfers = dntData.find(transferFileName, 'EnchantLevel', vm.item.enchantmentNum);
      
      for(var i=0;i<transfers.length;++i) {
        var t = transfers[i];
        if(t.Rank == vm.item.rank.id && t.LevelLimit == vm.item.levelLimit) {
          
          var item1s = dntData.find(allItemFileName, 'id', t.NeedItemID1);
          var item2s = dntData.find(allItemFileName, 'id', t.NeedItemID2);
          
          vm.matchingTransfers.push({
            level: t.ResultLevel,
            enchantmentNum: t.ResultEnchantLevel,
            gold: t.NeedCoin/100/100,
            rank: hCodeValues.rankNames[t.ResultRank],
            numItem1: t.NeedItemCount1,
            item1: itemFactory.createBasicItem(item1s[0]),
            numItem2: t.NeedItemCount2,
            item2: itemFactory.createBasicItem(item2s[0]),
          });
        }
      }
    }
  }

}])
.directive('dngearsimItemViewTransfer', function() {
  return {
    scope: true,
    bindToController: {
      item: '=item',
    },
    controller: 'itemViewTransferCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-transfer.html'
  };
});
angular.module('dnsim').controller('ItemCtrl',
['$scope','$window','dntData','hCodeValues','items','jobs','exportLinkHelper','$routeParams','translations','$location','region','itemFactory','$timeout',
function($scope,$window,dntData,hCodeValues,items,jobs,exportLinkHelper,$routeParams,translations,$location,region,itemFactory,$timeout) {
  'use strict';
  
  region.setLocationByName($routeParams.region);
  
  $window.scrollTo(0, 0);
  
  $scope.jobName = null;
  // console.log('search string: ', $routeParams.i);
  $scope.item = exportLinkHelper.decodeItem($routeParams.i);
  if('itemSource' in $scope.item) {
    $scope.itemType = items[$scope.item.itemSource];
  }
  
  $scope.item.setStats = null;
  $scope.item.setId = null;
  $scope.detail = null;
  
  $scope.getDescription = function() {
    if($scope.item.description) {
      return $scope.item.description;
    }
    else if($scope.itemType &&
      $scope.itemType.name == 'title' &&
      translations.isLoaded() &&
      dntData.isLoaded($scope.itemType.mainDnt)) {

      var itemData = dntData.find($scope.itemType.mainDnt, 'id', $scope.item.id);
      if(itemData && itemData.length > 0 && itemData[0].DescriptionID > 0) {
        return translations.translate(itemData[0].DescriptionID, itemData[0].DescriptionIDParam);
      }
    }
    else if($scope.item.fileName &&
      dntData.isLoaded($scope.item.fileName + '.lzjson')) {
        
      var itemData = dntData.find($scope.item.fileName + '.lzjson', 'id', $scope.item.id);
      if(itemData && itemData.length > 0 && itemData[0].DescriptionID > 0) {
        return translations.translate(itemData[0].DescriptionID, itemData[0].DescriptionIDParam);
      } 
    }
    return '';
  }
  
  $scope.getExchangeType = function() {
    // console.log('getting exchange');
    var exchangeDnt = 'exchange.lzjson';
    if(translations.isLoaded() &&
      dntData.isLoaded(exchangeDnt) &&
      $scope.item.exchangeType > 0) {
        
      // console.log('finding exchange ' + $scope.item.exchangeType);

      var exchange = dntData.find(exchangeDnt, 'ExchangeType', $scope.item.exchangeType);
      // console.log('got ' + exchange.length);
      if(exchange && exchange.length > 0 && exchange[0].NameID > 0) {
        // console.log('exchange name: ' + exchange[0].NameID);
        return translations.translate(exchange[0].NameID).toLowerCase();
      }
    }
    return '';
  }
  
  $scope.setDetail = function(detail) {
    $scope.detail = detail;
  }
  
  $scope.getServerStorage = function() {
    var itemData = itemFactory.getItemData($scope.item);
    if(itemData && 'AbleWStorage' in itemData && 'IsCash' in itemData && itemData.IsCash == 0) {
      if(itemData.AbleWStorage == 1) {
        return 'can put in server storage';
      }
      else if(itemData.AbleWStorage == 0) {
        return 'not transferable';
      }
    }
    return '';
  }
  
  $scope.handleChange = function() {
    // console.log('changes');
    if($scope.item.itemSource != 'custom') {
      $location.search('i', exportLinkHelper.encodeItem($scope.item));
    }
    else {
      setFullStats();
      $scope.item = angular.copy($scope.item);
    }
  }
  
  function getJobName() {
    var retVal = '';
    var allJobs = jobs.getAllJobs();
    angular.forEach(allJobs, function(job, index) {
      if(job.id == $scope.item.needJobClass) {
        $scope.jobName = job.name;
        return;
      }
    });
  }
  
  function init() {
    $scope.preInitItem = $scope.item;
    $scope.item = null;
  
    var anyToLoad = false;
    
    angular.forEach(exportLinkHelper.getDntFiles($scope.preInitItem), function(columns, fileName) {
      if(!dntData.isLoaded(fileName)) {
        dntData.init(fileName, columns, reportProgress, function() { tryInit() });
        anyToLoad = true;
      }
    });
    
    if(!translations.isLoaded()) {
      translations.init(reportProgress,function() { tryInit() });
      anyToLoad = true;
    }
    
    if(!jobs.isLoaded()) {
      jobs.init(reportProgress, function() { tryInit(); });
      anyToLoad = true;
    }
    
    if(!anyToLoad) {
      tryInit();
    }
  }
  init();
  
  function tryInit() {
    if(!dntData.anyLoading() && translations.isLoaded() && jobs.isLoaded()) {
      $scope.item = exportLinkHelper.reloadItem($scope.preInitItem);
      if($scope.item == null) {
        return;
      }
      
      setFullStats();
      $window.document.title = 'DN Gear Sim | ' + $scope.item.name;
      if($scope.item.itemSource != 'custom') {
      
        if($scope.item.typeName == 'skills') {
          if(!$scope.item.pve || $scope.item.pve != 'pvp') {
            $scope.item.pve = 'pve';
          }
          else {
            $scope.item.pve = 'pvp';
          }
        }
    
        if($scope.item.needJobClass > 0) {
          getJobName();
        }
        
        if(!$scope.item.fileName) {
          if($scope.item.itemSource in items && items[$scope.item.itemSource].mainDnt) {
            $scope.item.fileName = items[$scope.item.itemSource].mainDnt.replace('.lzjson', '').replace('.optimised', '');
          }
        }
      }
      
      var itemData = itemFactory.getItemData($scope.item);
      if(itemData.DisjointDrop1 > 0) {
        $scope.canExtract = true;
      }
      
      if((itemData.Type == 0 || itemData.Type == 1) && $scope.item.enchantmentNum > 0) {
        $scope.canTransfer = true;
      }
      
      if($scope.item.setId) {
        $scope.isInSet = true;
      }
      
      if($scope.item.typeId == 5) {
        $scope.isPlate = true;
      }
      
      if($scope.item.typeId == 46 || $scope.item.typeId == 8 || $scope.item.typeId == 112 || $scope.item.typeId == 122) {
        $scope.hasContents = true;
        $scope.detail = 'contents';
      }
      else if($scope.item.typeName != null) {
        $scope.canUse = true;
        $scope.detail = 'use';
      }
      else if($scope.canExtract) {
        $scope.detail = 'extract';
      }
      else if($scope.canTransfer) {
        $scope.detail = 'transfer';
      }
      else if($scope.isPlate) {
        $scope.detail = 'plate';
      }
      else {
        $scope.detail = 'shops';
      }
    }
  }

  
  function setFullStats() {
    // full stats are cleared when publishing builds
    $scope.item.fullStats = $scope.item.stats;
    
    if($scope.item.enchantmentStats != null && $scope.item.enchantmentStats.length > 0) {
      $scope.item.fullStats = hCodeValues.mergeStats($scope.item.enchantmentStats, $scope.item.fullStats);
    }
    
    if($scope.item.sparkStats != null && $scope.item.sparkStats.length > 0) {
      $scope.item.fullStats = hCodeValues.mergeStats($scope.item.sparkStats, $scope.item.fullStats);
    }
  }
  
  function reportProgress(msg) {
    // $scope.progress += '|' + msg;
    // console.log('progress: ' + msg);
  }
}]);
(function () {
'use strict';
angular.module('dnsim').controller('BuildSearchCtrl', ['$routeParams','$location','$timeout','onlineService','jobs', buildSearch]);

function buildSearch($routeParams,$location,$timeout,onlineService,jobs) {
  'use strict';
  
  var vm = this;
  
  vm.maxDisplay = 15;
  vm.totalNumResults = 0;
  
  jobs.init(null, function() {
    if($routeParams.jobId) {
      vm.job = jobs.getById($routeParams.jobId);
      getClassBuilds();
    } 
  })
  
  this.setJob = function() {
    $timeout(function() {
      $location.search('jobId', vm.job.id);
    });
  }
  
  this.showMoreResults = function(extra) {
    vm.maxDisplay = vm.totalNumResults + extra;
    vm.totalNumResults = 0;
  }
  
  vm.allResults = null;
  vm.getFilteredBuilds = function() {
    
    // init
    if(vm.allResults == null) {
      vm.allResults = [];
      for(var uid in vm.jobBuilds) {
        for(var buildName in vm.jobBuilds[uid]) {
          vm.allResults.push({
            uid: uid,
            name: buildName,
            data: vm.jobBuilds[uid][buildName]
          });
        }
      }
    }
    
    var results = [];
    for(var i=0;i<vm.allResults.length;++i) {
      
      var result = vm.allResults[i];
      if(vm.filter && vm.filter.length > 0) {
        var f = vm.filter.toUpperCase();
        if(result.name.toUpperCase().indexOf(f) == -1) {
          if(!result.data.guild ||
             result.data.guild.toUpperCase().indexOf(f) == -1) {

            continue;
          }
        }
      }
      
      results.push(result);

      if(results.length >= vm.maxDisplay) {
        break;
      }
    }
    
    vm.totalNumResults = results.length;
    return results;
  }
  
  function getClassBuilds() {
    if(vm.job) {
      onlineService.getClassBuilds(vm.job).then(function(builds) {
        if(builds) {
          // console.log('got builds', builds);
          vm.jobBuilds = builds;
        }
        else {
          // console.log('no builds');
          vm.jobBuilds = {};
        }
      });
    }
  }
}

})();
(function () {
'use strict';
angular.module('dnsim').controller('ProfileCtrl', ['$location', '$routeParams', 'onlineService', profile]);

function profile($location, $routeParams, onlineService, saveHelper) {
  'use strict';
  
  var vm = this;
  vm.uid = $routeParams.uid;
  
  getSavedBuilds();
  getProfile();
  
  function getSavedBuilds() {
    onlineService.getUserBuilds(vm.uid).then(function(builds) {
      if(builds) {
        vm.storedBuilds = builds;
      }
      else {
        vm.storedBuilds = {};
      }
    });
  }
  
  function getProfile() {
    onlineService.getProfile(vm.uid).then(function(profile) {
      if(profile) {
        vm.profile = profile;
      }
      else {
        vm.profile = {};
      }
    });
  }
  
  this.load = function(buildName, build) {

    var newGroupName = saveHelper.importGroup(buildName, build.items);
    
    saveHelper.renameSavedGroup(
      newGroupName, 
      newGroupName,
      build.enemyLevel,
      build.playerLevel,
      build.heroLevel,
      build.job,
      build.damageType,
      build.element,
      build.secondaryElement,
      build.enemyStatCaps, 
      build.playerStatCaps, 
      build.conversions, 
      build.baseStats, 
      build.heroStats);
      
    vm.builds = saveHelper.getSavedItems();
    
    $location.path('/build/' + newGroupName);
  }
}

})();
(function () {
'use strict';
angular.module('dnsim').controller('PublishCtrl', ['$location', 'saveHelper', 'onlineService', '$routeParams', 'region', publish]);

function publish($location, saveHelper, onlineService, $routeParams, region) {
  'use strict';
  
  var vm = this;
  
  vm.show = $routeParams.show;
  
  onlineService.login().then(function(user) {
    getSavedBuilds();
    getProfile();
  
    vm.builds = saveHelper.getSavedItems();
  });
  
  function getSavedBuilds() {
    var user = vm.getUser();
    if(user) {
      onlineService.getUserBuilds(user.uid).then(function(builds) {
        if(builds) {
          vm.storedBuilds = builds;
        }
        else {
          vm.storedBuilds = {};
        }
      });
    }
  }
  
  function getProfile() {
    var user = vm.getUser();
    if(user) {
      onlineService.getProfile(user.uid).then(function(profile) {
        if(profile) {
          vm.profile = profile;
        }
        else {
          vm.profile = {};
        }
      });
    }
  }
  
  this.saveProfile = function() {
    onlineService.saveProfile(vm.profile).then(getProfile).catch(handleError);
  }
  
  this.getUser = function() {
    return onlineService.getUser();
  }
  
  this.save = function(buildName, build) {
    build.lastUpdate = (new Date()).getTime();
    onlineService.saveBuild(buildName, build).then(getSavedBuilds).catch(handleError);
    vm.publishBuild = null;
  }
  
  this.startPublish = function(buildName) {
    if(buildName in vm.storedBuilds) {
      if(!vm.builds[buildName].region) {
        vm.builds[buildName].region = vm.storedBuilds[buildName].region;
      }
      
      if(!vm.builds[buildName].about) {
        vm.builds[buildName].about = vm.storedBuilds[buildName].about;
      }
      
      if(!vm.builds[buildName].guild) {
        vm.builds[buildName].guild = vm.storedBuilds[buildName].guild;
      }
    }
    
    if(!vm.builds[buildName].region) {
      vm.builds[buildName].region = region.dntLocation.region;
    }
    
    vm.publishBuild = buildName;
  }
  
  function handleError(err) {
    console.log(err);
  }
  
  this.deleteAccount = function() {
    onlineService.deleteAccount(vm.storedBuilds);
  }
  
  this.getBuildLimit = function() {
    if(vm.profile && vm.profile.maxBuilds) {
      return vm.profile.maxBuilds;
    }
    else {
      return 15;
    }
  }
  
  this.getNumStoredBuilds = function() {
    return _.size(vm.storedBuilds);
  }
  
  this.getNumBuilds = function() {
    return _.size(vm.builds);
  }
  
  this.load = function(buildName, build) {

    var newGroupName = saveHelper.importGroup(buildName, build.items);
    
    saveHelper.renameSavedGroup(
      newGroupName, 
      newGroupName,
      build.enemyLevel,
      build.playerLevel,
      build.heroLevel,
      build.job,
      build.damageType,
      build.element,
      build.secondaryElement,
      build.enemyStatCaps, 
      build.playerStatCaps, 
      build.conversions, 
      build.baseStats, 
      build.heroStats);
      
    vm.builds = saveHelper.getSavedItems();
  }
  
  this.signOut = function() {
    onlineService.signOut();
  }
  
  vm.deleteLocal = function(buildName) {
    vm.localToDelete = buildName;
  }
  
  vm.getAllBuildNames = function() {
    var allKeys = _.keys(vm.builds).concat(_.keys(vm.storedBuilds));
    return _.uniq(allKeys.sort(), true);
  }
  
  vm.reallyDeleteLocal = function(buildName) {
    saveHelper.updatedSavedItems(buildName, []);
    vm.localToDelete = null;
    vm.builds = saveHelper.getSavedItems();
  }
  
  vm.deleteServer = function(buildName) {
    vm.serverToDelete = buildName;
  }
  
  vm.reallyDeleteServer = function(buildName) {
    onlineService.deleteBuild(buildName, vm.storedBuilds[buildName]).then(getSavedBuilds);
    vm.serverToDelete = null;
  }
  
}

})();
(function () {
'use strict';
angular.module('dnsim').controller('PublishedCtrl', ['onlineService', '$location', '$routeParams', 'saveHelper', 'statHelper', published]);

function published(onlineService, $location, $routeParams, saveHelper, statHelper) {
  'use strict';
  
  var vm = this;
  vm.uid = $routeParams.uid;
  vm.buildName = $routeParams.buildName;
  
  getBuild();
  getProfile();
  
  vm.copyLocally = function() {
    var newGroupName = saveHelper.importGroup(vm.buildName, vm.build.items);
    
    saveHelper.renameSavedGroup(
      newGroupName, 
      newGroupName,
      vm.build.enemyLevel,
      vm.build.playerLevel,
      vm.build.heroLevel,
      vm.build.job,
      vm.build.damageType,
      vm.build.element,
      vm.build.secondaryElement,
      vm.build.enemyStatCaps, 
      vm.build.playerStatCaps, 
      vm.build.conversions, 
      vm.build.baseStats, 
      vm.build.heroStats);
      
    $location.path('/build/' + newGroupName);
  }
  
  function getProfile() {
    onlineService.getProfile(vm.uid).then(function(profile) {
      if(profile) {
        vm.profile = profile;
      }
      else {
        vm.profile = {};
      }
    });
  }
  
  function getBuild() {
    onlineService.getBuild(vm.uid, vm.buildName).then(function(build) {
      if(build) {
        vm.build = build;
        vm.stats = statHelper.getBuildStats(build);
      }
      else {
        vm.build = {};
      }
    });
  }
}

})();
angular.module('dnsim').controller('RegionCtrl', 
  ['$timeout','$route','$routeParams','$location','translations','region','$http',
  function($timeout,$route,$routeParams,$location,translations,region,$http) {
    'use strict';
    
    var vm = this;

    vm.override = region.getOverride();
    region.init();
    translations.init(
      function(msg) { 
        // console.log(msg);
      }, 
      function() {
        $timeout();
      });
      
    vm.region = region;
    vm.tHoverLocation = region.tlocation;
    vm.hoverLocation = region.dntLocation;
    vm.edit = (region.dntLocation == null);
    vm.dntVersion = '';
    setDntVersion();
    
    function setDntVersion() {
      // console.log('setting version for ', vm.region.dntLocation);
      if(vm.region.dntLocation && vm.region.dntLocation.url) {
        $http.get(vm.region.dntLocation.url + '/Version.cfg').then(function(res) {
          if(res && res.data) {
            var newLineDetails = res.data.split('\r\n');
            if(newLineDetails.length) {
              var spaceDetails = newLineDetails[0].split(' ');
              if(spaceDetails.length > 1) {
                vm.dntVersion = 'v' + spaceDetails[1];
              }
            }
          }
        });
      }
    }
    
    vm.getDntLocation = function() {
      return region.dntLocation;
    };
    vm.getTlocation = function() {
      return region.tlocation;
    };
     
    vm.getHostedFiles = function() {
      // console.log('getting hosted files');
      return region.hostedFiles;
    };
    
    vm.getWorldName = function() {
      if(translations.isLoaded()) {
        return translations.translate(10169);
      }
      else {
        return '';
      }
    };
    
    vm.setTLocation = function(location) {
      region.setTLocation(location);
      vm.edit = false;
    };
    
    vm.setLocation = function(location) {
      if(!vm.override) {
        vm.setTLocation(null);
      }
      
      if($routeParams.region) {
        $routeParams.region = location.region;
        $route.updateParams($routeParams);
        $route.reload();
      }
      else {
        region.setLocation(location);
      }
      vm.edit = false;
      setDntVersion();
    };
    
    vm.setOverride = function(value) {
      region.setOverride(value);
      vm.override = value;
      vm.edit = value;
    };
  }
])
.directive('dngearsimRegion', function() {
  return {
    templateUrl: 'ui/region/region.html',
    controllerAs: 'ctrl',
  };
});
(function () {
'use strict';

angular.module('dnsim').directive('dngearsimCustomItems', function() {
  return {
    scope: {},
    bindToController: {
    },
    controller: ['$window','saveHelper','$location','hCodeValues','itemCategory','$timeout', customItemCtrl],
    controllerAs: 'customItems',
    templateUrl: 'ui/search/custom-items.html'
  };
});

function customItemCtrl($window,saveHelper,$location,hCodeValues,itemCategory,$timeout) {
  'use strict';

  var vm = this;
  
  this.customItems = hCodeValues.customItems;
  
  this.maxDisplay = 10;
  this.currentResults = 0;
  
  if(this.nameSearch == null) {
    this.nameSearch = '';
  }
  
  this.getResults = function() {
    return this.customItems;
  }
  
  this.getNewStatName = function() {
    if(this.nameSearch == '' || this.nameSearch == null) {
      return 'unnamed custom item';
    }
    else {
      return this.nameSearch;
    }
  }
  
  this.createCustomItem = function() {
    if(this.nameSearch == '' || this.nameSearch == null) {
      this.nameSearch = this.getNewStatName();
    }
    $location.path('/item/_custom:.' + this.nameSearch);
  }
}

})();
angular.module('dnsim').controller('ItemSearchCtrl',
['$scope','$window','$routeParams','$timeout','$location',
'translations',
'itemCategory',
'jobs',
'hCodeValues',
'itemFactory',
'region',
'saveHelper',
function(
  $scope,$window,$routeParams,$timeout,$location,
  translations,
  itemCategory,
  jobs,
  hCodeValues,
  itemFactory,
  region,
  saveHelper) {
  'use strict';
  
  var vm = this;
  
  vm.itemCategory = itemCategory.byPath($routeParams.cat);
  if(!vm.itemCategory) {
     var catName = localStorage.getItem('selectedItemCategory');
     if(!catName) {
       catName = 'titles';
     }
     
     vm.itemCategory = itemCategory.byName(catName);
     if(vm.itemCategory) {
       // console.log('moving');
       $location.search('cat', vm.itemCategory.path);
     }
     return;
  }
  
  $window.document.title = 'DN Gear Sim | ' + vm.itemCategory.name.toUpperCase();
  
  vm.job = {id: -1, name: ''};
  vm.jobs = [vm.job];
  vm.allJobs = [];
  vm.minLevel = 1;
  vm.maxLevel = 99;
  vm.maxDisplay = 10;
  vm.totalNumResults = 0;
  vm.grades = hCodeValues.rankNames;
  vm.stat = {id:-1, name:''};
  vm.stats = [vm.stat];
  vm.results = null;
  
  angular.forEach(hCodeValues.stats, function(stat, statId) {
    if(stat.searchable) {
      vm.stats.push(stat);
    }
  });
  
  var minLevel = Number(localStorage.getItem('minLevel'));
  if(minLevel > 0 && minLevel < 100) {
    vm.minLevel = minLevel;
  }
  var maxLevel = Number(localStorage.getItem('maxLevel'));
  if(maxLevel > 0 && maxLevel < 100) {
    vm.maxLevel = maxLevel;
  }
  
  vm.nameSearch = localStorage.getItem('nameSearch');
  if(!vm.nameSearch) {
    vm.nameSearch = '';
  }
  
  var savedSearchStatId = localStorage.getItem('searchStat');
  if(savedSearchStatId > -1 && savedSearchStatId in hCodeValues.stats) {
    vm.stat = hCodeValues.stats[savedSearchStatId];
  }

  vm.navigate = function() {
    var catName = localStorage.getItem('selectedItemCategory');
    if(catName) {
      vm.itemCategory = itemCategory.byName(catName);
      if(vm.itemCategory) {
        // console.log('navigating to ', vm.itemCategory.path);
        $location.search('cat', vm.itemCategory.path);
      }
    }
  }

  vm.save = function() {
    if(!vm.itemCategory.hideLevel) {
      localStorage.setItem('minLevel', vm.minLevel);
      localStorage.setItem('maxLevel', vm.maxLevel);
    }
    
    if(!vm.itemCategory.hideJob) {
      if(vm.job != null) {
        localStorage.setItem('jobNumber', vm.job.id);
      }
    }
  
    if(vm.stat) {
      localStorage.setItem('searchStat', vm.stat.id);
    }

    localStorage.setItem('nameSearch', vm.nameSearch);
  };
  
  function init() {
    // console.log('translations loaded');
    if(jobs.isLoaded()) {
      jobInit();
    }
    else {
      jobs.init(reportProgress, function() { $timeout(jobInit); } );
    }

    itemCategory.init(vm.itemCategory.name, loadResults);
  }
  
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
  
  function jobInit() {
    // console.log('called the job init func');
    if(translations.isLoaded() && jobs.isLoaded()) {
      // console.log('trying to init jobs');
      // console.log('job dropdown should be set');
      var newJobs = jobs.getFinalJobs();

      newJobs.splice(0, 0, vm.jobs[0]);
      vm.jobs = newJobs;
      vm.allJobs = jobs.getAllJobs();
      
      var lastJobNumber = Number(localStorage.getItem('jobNumber'));
      if(lastJobNumber != null) {
        angular.forEach(newJobs, function(value, key) {
          if(value.id == lastJobNumber) {
            vm.job = value;
            return;
          }
        });
      }
    }
  }
  
  vm.rankChecked = hCodeValues.checkedRank;
    
  vm.changeSearch = function() {
    vm.save();
    loadResults();
  }
  
  function loadResults() {
    $timeout(function() {
      vm.maxDisplay = 24;
      vm.results = getResults();
    });
  }
  
  function getResults() {
    // console.log('getting items');
    var allItems = itemCategory.getItems(vm.itemCategory.name);
    if(allItems == null) {
      // console.log('no items');
      return null;
    }
    
    allItems = allItems.sort(function(item1, item2) {
        return (item2.levelLimit - item1.levelLimit);
      });
          
    var pcStatId = -1;
    if('pc' in vm.stat) {
      pcStatId = vm.stat.pc;
    }
          
    var altStatId = -1;
    if('altStat' in vm.stat) {
      altStatId = vm.stat.altStat;
    }
  
    var statVals = [];
    var newResults = [];
    var numEquip = allItems.length;
    var curDisplay = 0;
    for(var i=0;i<numEquip && (curDisplay<vm.maxDisplay || vm.stat.id >= 0);++i) {
      var e = allItems[i];
      if(e) {
        
        if(!vm.itemCategory.hideLevel) {
          if(e.levelLimit < vm.minLevel || e.levelLimit > vm.maxLevel) {
            continue;
          }
        }
          
        if(!vm.itemCategory.hideRank) {
          if(e.rank && !vm.rankChecked[e.rank.id]) {
            continue;
          }
        }
          
        if(!vm.itemCategory.hideJob) {
          if(vm.job && vm.job.id > -1) {
            if(!vm.job.isClassJob(e.needJobClass)) {
              continue;
            }
          }
        }
        
        itemFactory.initItem(e);
        if(e.typeName != vm.itemCategory.name) {
          continue;
        }
        // console.log('name filter', vm.nameSearch); 
        
        if(vm.nameSearch != '') {
          // console.log('filtering on name');
          var nameSearches = vm.nameSearch.split(' ');
          if(!nameSearches.length) {
            nameSearches = [vm.nameSearch];
          }
          var allMatch = true;
          for(var ns=0;ns<nameSearches.length;++ns) {
            if(e.name.toUpperCase().indexOf(nameSearches[ns].toUpperCase()) == -1) {
              allMatch = false;
              break;
            }
          }
          
          if(!allMatch) {
            continue;
          }
        }
        
        if(vm.stat.id >= 0) {
          var statFound = false;
          
          var statVal = {};
          for(var s=0;s<e.stats.length;++s) {
            var stat = e.stats[s];
            if(stat.id == vm.stat.id) {
              statFound = true;
              statVal.i = curDisplay;
              statVal.s = Number(stat.max);
              break;
            }
            else if(stat.id == pcStatId) {
              statFound = true;
              statVal.i = curDisplay;
              statVal.s = Number(stat.max);
            }
            else if(stat.id == altStatId) {
              statFound = true;
              statVal.i = curDisplay;
              statVal.s = Number(stat.max);
            }
          }
          
          if(!statFound) {
            continue;
          }
          else {
            statVals.push(statVal);
          }
        }
        
        newResults.push(e);
        curDisplay++;
      }
    }
    
    if(vm.stat.id >= 0) {
      
      var currentResults = Math.min(curDisplay, vm.maxDisplay);
      
      statVals = statVals.sort(function(value1, value2) {
        return value2.s - value1.s;
      });
      
      var statResults = [];
      for(var i=0;i<currentResults;++i) {
        statResults.push(newResults[statVals[i].i]);
      }
      newResults = statResults;
    }
    
    vm.totalNumResults = newResults.length;
    
    return newResults;
  }

  vm.showMoreResults = function() {
    $timeout(function() {
      vm.maxDisplay += 18;
      vm.results = getResults();
    });
  }
  
  region.init();
  if(translations.isLoaded()) {
    init();
  }
  else {
    translations.init(reportProgress, function() { $timeout(init); } );
  }
  
}]);

(function () {
'use strict';

angular.module('dnsim').directive('dngearsimSkillSearch', function() {
  return {
    scope: {},
    bindToController: {
      job: '=job',
      jobs: '=jobs',
    },
    controller: ['$window','$timeout','saveHelper','region','jobs','translations','dntData','hCodeValues','itemCategory','$location', skillSearchCtrl],
    controllerAs: 'skillSearch',
    templateUrl: 'ui/search/skill-search.html'
  };
});

function skillSearchCtrl($window,$timeout,saveHelper, region, jobs, translations,dntData,hCodeValues,itemCategory,$location) {

  var vm = this;
  
  vm.allJobs = [];
  vm.dntName = '';
  vm.skills = [];
  vm.loadedJobId = -1;

  vm.itemCategory = itemCategory.byName('skills');

  vm.nameSearch = localStorage.getItem('nameSearch');
  if(!vm.nameSearch) {
    vm.nameSearch = '';
  }
  
  region.init();
  if(translations.isLoaded()) {
    init();
  }
  else {
    translations.init(reportProgress, function() { $timeout(init); } );
  }

  vm.navigate = function() {
    $timeout(function() {
      if(vm.itemCategory) {
        $location.path(vm.itemCategory.path);
      }
    });
  }
  
  vm.isLoading = function() {
    
    if(!translations.isLoaded()) {
      // console.log('transations not loaded');
      if(!translations.startedLoading) {
        translations.init(reportProgress, function() { } );
      }

      return true;
    }
    
    var baseName = jobs.getBaseJobName(vm.job);
    var dntName = getDntName(baseName);
    if(dntName) {
      if(!dntData.isLoaded(dntName)) {
        return true;
      }
    }

    return false;
  };
  
  function getDntName(baseClassName) {
    // console.log('got base class :' + baseClassName);
    if(baseClassName != null) {
      return 'skilltable_character' + baseClassName.toLowerCase() + '.lzjson';
    }
    else {
      return null;
    }
  }

  function getSkills() {
    // console.log('getting skills for ' + vm.job.name);
    if(vm.loadedJobId == vm.job.id) {
      return vm.skills;
    }
    else {
      
      var baseJobNames = [];
      if(vm.job.id >= 0) {
        var baseName = jobs.getBaseJobName(vm.job);
        baseJobNames.push(baseName);
      }

      angular.forEach(baseJobNames, function(baseName, index) {
        var dntName = getDntName(baseName);
        if(dntName) {
          if(!dntData.isLoaded(dntName)) {
            // console.log('loading skills for ' + baseName);
            dntData.init(dntName, null, reportProgress, function() { $timeout(function() { setupSkills(baseJobNames, vm.job);} ); });
          }
          else {
            setupSkills(baseJobNames, vm.job);
          }
        }
      });
    }
  }
  
  function setupSkills(baseJobNames, job) {
    
    vm.skills = [];
    var allReady = true;
    angular.forEach(baseJobNames, function(baseName, index) {
      var dntName = getDntName(baseName);
      if(!dntData.isLoaded(dntName)) {
        allReady = false;
      }
    });
    
    if(allReady) {
      angular.forEach(baseJobNames, function(baseName, index) {
        var dntName = getDntName(baseName);
      
        var skills = dntData.getData(dntName);
        var numSkills = skills.length;
        for(var s=0;s<numSkills;++s) {
          if(skills[s].NameID == 0) {
            continue;
          }
          
          if(skills[s].EffectClass1 > 0 || 
             skills[s].EffectClass2 > 0 || 
             skills[s].EffectClass3 > 0 || 
             skills[s].EffectClass4 > 0 ||
             skills[s].EffectClass5 > 0 ||  
             skills[s].EffectClass6 > 0) {
               
            var newItem = {d: skills[s]};
            
            newItem.id = skills[s].id;
            newItem.typeName = 'skills';
            newItem.itemSource = 'skills';
            newItem.name = translations.translate(skills[s].NameID, skills[s].NameIDParam);
            newItem.needJobClass = skills[s].NeedJob;
            newItem.rank = hCodeValues.rankNames[0];
            newItem.baseJobName = baseName.toLowerCase();
            newItem.icon = skills[s].IconImageIndex;
            
            vm.skills.push(newItem);
          }
        }
      });
  
      vm.loadedJobId = job.id;
    }
  }
  
  vm.itemLinkClosed = function() {
    saveHelper.saveCustomItems(vm.customItems);
    vm.customItems = saveHelper.getCustomItems();
  }
  
  vm.getResults = function() {
    
    var skills = getSkills();
    if(skills == null) {
      return [];
    }
    
    if(vm.job && vm.job.id >= 0) {
      localStorage.setItem('jobNumber', vm.job.id);
    }
    localStorage.setItem('nameSearch', vm.nameSearch);

    var newResults = [];
    var numSkills = skills.length;
    var curDisplay = 0;
    for(var i=0;i<numSkills;++i) {
      var e = skills[i];
      
      if(vm.nameSearch != '') {
        var nameSearches = vm.nameSearch.split(' ');
        if(!nameSearches.length) {
          nameSearches = [vm.nameSearch];
        }
        var allMatch = true;
        for(var ns=0;ns<nameSearches.length;++ns) {
          if(e.name && e.name.toString().toUpperCase().indexOf(nameSearches[ns].toUpperCase()) == -1) {
            allMatch = false;
            break;
          }
        }
        
        if(!allMatch) {
          continue;
        }
      }
      
      if(vm.job.id >= 0 && !vm.job.isClassJob(e.needJobClass)) {
        continue;
      }
      
      newResults.push(e);
    }
    return newResults;
  }
  
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
  
  function jobInit() {
    if(translations.isLoaded() && jobs.isLoaded()) {
      var newJobs = jobs.getFinalJobs();

      if(vm.jobs && vm.jobs.length) {
        newJobs.splice(0, 0, vm.jobs[0]);
      }
      vm.jobs = newJobs;
      vm.allJobs = jobs.getAllJobs();
      
      var lastJobNumber = Number(localStorage.getItem('jobNumber'));
      // console.log('using job', lastJobNumber);
      if(lastJobNumber != null) {
        angular.forEach(newJobs, function(value, key) {
          if(value.id == lastJobNumber) {
            vm.job = value;
            // console.log('using job', value);
            return;
          }
        });
      }
      
      vm.getResults();
    }
  }
  
  function init() {
    // console.log('skill init');
    if(jobs.isLoaded()) {
      $timeout(jobInit);
    }
    else {
      jobs.init(reportProgress, function() { $timeout(jobInit); } );
    }
  }
}

})();
angular.module('dnsim')
.controller('ItemsCtrl', 
  ['$window','$timeout','hCodeValues','region','translations','dntData',
  function($window, $timeout, hCodeValues, region, translations, dntData) {
    
    'use strict';
    
    var vm = this;
    
    vm.boxes = null;
    vm.maxDisplay = 32;
    vm.currentResults = 0;
    vm.results = null;

    vm.nameSearch = localStorage.getItem('itemNameSearch');
    if(vm.nameSearch == null) {
      vm.nameSearch = '';
    }
    
    $window.document.title = 'DN Gear Sim | ITEM SEARCH';
    
    var fileName = 'all-items.lzjson';
    
    dntData.init(fileName, null, function() {}, function() {
      $timeout(function() {
        vm.initBoxes();
      });
    });
    
    vm.initBoxes = function() {
      if(dntData.isLoaded(fileName) && translations.isLoaded()) {
        vm.boxes = [];
        
        var datas = dntData.getData(fileName);
        // console.log(datas.length + ' boxes');
        for(var i=0;i<datas.length;++i) {
          var data = datas[i];
          if(data.NameID > 0) {
            var box = {
              id: data.id,
              name: translations.translate(data.NameID, data.NameIDParam),
              rank: hCodeValues.rankNames[data.Rank],
              icon: data.IconImageIndex,
              levelLimit: data.LevelLimit,
              fileName: data.fileName,
            }
            vm.boxes.push(box);
          }
        }
        
        vm.boxes = _.sortBy(vm.boxes, 'name');
        
        $timeout(function() {
          vm.showMoreResults();
        });
      }
    }
    
    vm.getResults = function() {
      if(vm.boxes == null) {
        vm.initBoxes();
      }
      
      if(vm.boxes == null) {
        return [];
      }
  
      var newResults = [];
      var numBoxes = vm.boxes.length;
      var curDisplay = 0;
      for(var i=0;i<numBoxes && (curDisplay<vm.maxDisplay);++i) {
        var e = vm.boxes[i];

        if(vm.nameSearch != '') {
          var nameSearches = vm.nameSearch.split(' ');
          if(nameSearches.length == 0) {
            nameSearches = [vm.nameSearch];
          }
          var allMatch = true;
          for(var ns=0;ns<nameSearches.length;++ns) {
            if(e.name && e.name.toString().toUpperCase().indexOf(nameSearches[ns].toUpperCase()) == -1) {
              allMatch = false;
              break;
            }
          }
          
          if(!allMatch) {
            continue;
          }
        }
        
        newResults.push(e);
        curDisplay++;
      }
      
      vm.totalNumResults = newResults.length;
      return newResults;
    }
    
    vm.changeSearch = function() {
      localStorage.setItem('itemNameSearch', vm.nameSearch);
      
      vm.maxDisplay = 64;
      vm.results = vm.getResults();
    }
  
    vm.showMoreResults = function() {
      $timeout(function() {
        // console.log('show more', vm.maxDisplay);
        vm.maxDisplay += 18;
        vm.results = vm.getResults();
      });
    }
  }]
);

(function () {
'use strict';

angular.module('dnsim').directive('dnsimChooseClass', chooseClass);

function chooseClass() {
  return {
    restrict: 'E',
    scope: {},
    bindToController: {
      job: '=job',
      onSetJob: '&onSetJob'
    },
    templateUrl: 'ui/widgets/choose-class.html',
    controllerAs: 'ctrl',
    controller: [
      '$window','$location','$routeParams','$timeout','saveHelper','dntData','jobs','hCodeValues','itemColumnsToLoad','character', 
      chooseClassController],
  };
}

function chooseClassController($window,$location,$routeParams,$timeout,saveHelper,dntData,jobs,hCodeValues,itemColumnsToLoad,character) {
  this.getFinalJobs = function() {
    var allJobs = jobs.getFinalJobs();
    var finalJobs = [];
    for(var j=0;j<allJobs.length;++j) {
      if(jobs.getBaseJobName(allJobs[j]) == this.bJob) {
        finalJobs.push(allJobs[j]);
      }
    }
    return finalJobs;
  }
  
  this.getBaseJobs = function() {
    return jobs.getBaseJobs();
  }
  
  this.getJobName = function(englishName) {
    var allJobs = jobs.getAllJobs();
    for(var j=0;j<allJobs.length;++j) {
      if(allJobs[j].d.EnglishName == englishName) {
        return allJobs[j].name;
      }
    }
  }
  
  this.setJob = function(job) {
    this.job = job;
    if(job) {
      this.onSetJob();
    }
  }
  
  
  jobs.init(reportProgress, $timeout);
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }

}

})();

(function () {
'use strict';
  
angular.module('dnsim').directive('dnsimCategoryLinks', ['itemCategory','$location', dnsimCategoryLinks]);

function dnsimCategoryLinks(itemCategory,$location) {
  return {
    restrict: 'E',
    scope: {},
    bindToController: {
      collapse: '=collapse',
      cat: '=cat',
      onChange: '&onChange'
    },
    templateUrl: 'ui/widgets/dnsim-category-links.html',
    controller: ['itemCategory', dnsimCategoryLinksController],
    controllerAs: 'ctrl',
  };
};

function dnsimCategoryLinksController(itemCategory) {

  var vm = this;

  vm.categories = itemCategory.categories;
  vm.collapsed = true;

  vm.setCategory = function(action) {
    // console.log('setting cat', action);
    vm.cat = action;
    localStorage.setItem('selectedItemCategory', action.name);
    
    if(vm.collapse) {
      vm.collapsed = !vm.collapsed;
    }

    if(vm.onChange) {
      vm.onChange();
    }
  }
}

})();

(function () {
'use strict';
  
angular.module('dnsim').directive('dnsimItemIcon', ['exportLinkHelper','$location','region', dnsimItemIcon]);

function dnsimItemIcon(exportLinkHelper,$location,region) {
  return {
    restrict: 'E',
    scope: {
      item: '=item',
    },
    templateUrl: 'ui/widgets/dnsim-item-icon.html',
    link: function($scope, element, attrs) {
      
      $scope.$watch('item', function(newValue, oldValue) {
        if (newValue) {
          $scope.iconImage = $scope.getIcon();
        }
      });
      
      $scope.getIcon = function() {
        if($scope.item && $scope.item.icon > 0) {
          var fileIndex = Math.floor($scope.item.icon/200 + 1);
          
          var prefix;
          if($scope.item.typeName == 'skills') {
            prefix = 'skillicon';
          }
          else {
            prefix = 'itemicon';
          }
          
          if(fileIndex > 9) {
            return prefix + fileIndex + '.png';
          }
          else {
            return prefix + '0' + fileIndex + '.png';
          }
        }
        return null;
      }
      
      $scope.iconImage = $scope.getIcon();
      
      $scope.getIconXPostion = function() {
        if($scope.item && $scope.item.icon > 0) {
          return (($scope.item.icon % 10) * 40) + 5;
        }
        return 0;
      }
      
      $scope.getIconYPostion = function() {
        if($scope.item && $scope.item.icon > 0) {
          return (Math.floor(($scope.item.icon % 200) / 10) * 40) + 4;
        }
        return 0;
      }
    },
  };
}

})();

(function () {
'use strict';
  
angular.module('dnsim').directive('dnsimItemLink', ['exportLinkHelper','$location','region', dnsimItemLink]);

function dnsimItemLink(exportLinkHelper,$location,region) {
  return {
    restrict: 'E',
    scope: {
      item: '=item',
      noClick: '=noClick',
    },
    templateUrl: 'ui/widgets/dnsim-item-link.html',
    link: function($scope, element, attrs) {
      $scope.itemLink = 'item/?region=' + region.dntLocation.region + '&i=' + exportLinkHelper.encodeItem($scope.item);
      // var basePath = angular.element(document.querySelector('base')).attr('href');
      
      $scope.$watch('item', function(newValue, oldValue) {
        if (newValue) {
          $scope.itemLink = 'item/?region=' + region.dntLocation.region + '&i=' + exportLinkHelper.encodeItem($scope.item);
        }
      });
    },
  };
}

})();

(function () {
'use strict';

angular.module('dnsim').directive('dnsimJobIcon', [dnsimJobIcon]);

function dnsimJobIcon() {
  return {
    restrict: 'E',
    scope: {},
    bindToController: {
      item: '=item',
    },
    templateUrl: 'ui/widgets/dnsim-job-icon.html',
    controller: dnsimJobIconController,
    controllerAs: 'ctrl'
  }
}

function dnsimJobIconController() {

  this.getIconXPostion = function() {
    if(this.item && this.item.d && this.item.d.JobIcon > 0) {
      return ((this.item.d.JobIcon % 9) * 44) + 5;
    }
    return 0;
  }
  
  this.getIconYPostion = function() {
    if(this.item && this.item.d && this.item.d.JobIcon > 0) {
      return (Math.floor(this.item.d.JobIcon / 9) * 44) + 5;
    }
    return 0;
  }
}

})();

(function () {
'use strict';

angular.module('dnsim').directive('dnsimLoading', ['dntData','translations','$timeout', 'region', dnsimLoading]);

function dnsimLoading(dntData, translations, $timeout, region) {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    scope: {
      alsoShowFor: '=alsoShowFor',
    },
    templateUrl: 'ui/widgets/dnsim-loading.html',
    link: function($scope, element, attrs) {
      $scope.$on('TRANSLATION_LOAD_EVENT', function() {
        $scope.setLoadCount();
      });
      
      $scope.$on('DNTDATA_LOAD_EVENT', function() {
        $scope.setLoadCount();
      });
      
      $scope.$on('DNTDATA_LOAD_ERROR', function() {
        $timeout(function() {
          $scope.loadError = true;
        });
      });
      
      $scope.$on('TRANSLATION_LOAD_ERROR', function() {
        $timeout(function() {
          $scope.loadError = true;
        });
      });

      $scope.numLoading = 0;
      $scope.setLoadCount = function() {
        $scope.noRegion = !region.dntLocation;
        
        var n = dntData.anyLoading();
        if(!translations.isLoaded())
        {
          n++;
        }
        
        // $timeout(function() {
          if($scope.numLoading < n || !$scope.totalToLoad) {
            $scope.totalToLoad = n;
          }
          $scope.numLoading = n;
        // });
        $timeout();
      };
      
      $scope.loadError = false;
      $scope.setLoadCount();
    },
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').directive('dnsimSelectAllOnClick', [dnsimSelectAllOnClick]);

function dnsimSelectAllOnClick() {
  'use strict';
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      var hasSelectedAll = false;
      element.on('click', function($event) {
        if (!hasSelectedAll) {
          try {
            //IOs, Safari, thows exception on Chrome etc
            this.selectionStart = 0;
            this.selectionEnd = this.value.length + 1;
            hasSelectedAll = true;
          } catch (err) {
            //Non IOs option if not supported, e.g. Chrome
            this.select();
            hasSelectedAll = true;
          }
        }
      });
      //On blur reset hasSelectedAll to allow full select
      element.on('blur', function($event) {
        hasSelectedAll = false;
      });
    }
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').directive('dnsimStats', ['hCodeValues',dnsimStats]);

function dnsimStats(hCodeValues) {
  return {
    restrict: 'A',
    scope: {
      stats: '=stats',
      build: '=build',
      altStats: '=altStats',
      separator: '=separator',
      filter: '=filter',
    },
    link: function($scope, element, attrs) {
      
      var sep;
      if(!$scope.separator) {
        sep = '';
      }
      else {
        sep = '&nbsp;' + $scope.separator + ' ';
      }
      
      var addedElements = [];
      var originalDisplay = element.css('display');
      
      function showStats() {
        element.css('display', 'none' );
        var stats = $scope.stats;
        if(!stats) {
          stats = $scope.altStats;
        }
        
        angular.forEach(addedElements, function(value, key) {
          value.remove();
        });
        
        var first = true;
        var lastElement = element;
        
        function append(text) {
          var newElement = element.clone();
          newElement.css('display', originalDisplay);
          newElement.html(text);
          
          lastElement.after(newElement);
          lastElement = newElement;
          addedElements.push(newElement);
        }
        
        angular.forEach(stats, function(stat, key) {
          var output = '';
          
          if(stat.id in hCodeValues.stats) {
            
            var def = hCodeValues.stats[stat.id];
            if(!$scope.filter && 'hide' in def && def.hide) {
              return;
            }
            
            if($scope.filter && !def[$scope.filter]) {
              return;
            }
            
            if(!first) {
              output += sep;
            }
            first = false;
          
            if('needSetNum' in stat) {
              output += stat.needSetNum + '&nbsp;';
            }
            
            if($scope.build) {
              if(def.element == 'primary') {
                var eleId = 0;
                if($scope.build.element) {
                  eleId = $scope.build.element.id;
                }
                output += hCodeValues.elements[eleId].name + '&nbsp;';
              }
              else if(def.element == 'secondary') {
                var eleId = 0;
                if($scope.build.secondaryElement) {
                  eleId = $scope.build.secondaryElement.id;
                }
                output += hCodeValues.elements[eleId].name + '&nbsp;';
              }
            }
            
            output += def.name+':&nbsp;'+def.display(stat);
            if(def.combineWith > 0) {
              angular.forEach(stats, function(stat2, key2) {
                if(stat2.id == def.combineWith) {
                  if(stat2.max != stat.max) {
                    output += '-' + def.display(stat2);
                  }
                  return;
                }
              });
            }
          }
          else {
            if(!first) {
              output += sep;
            }
            first = false;
          
            if('needSetNum' in stat) {
              output += stat.needSetNum + '-Increases&nbsp;';
            }
            
            output += stat.id+':&nbsp;'+stat.max;
          }
          
          append(output);
        });
      }
        
      $scope.$watch('stats', function(newValue, oldValue) {
        if (newValue) {
          showStats();
        }
      });
      
      $scope.$watch('altStats', function(newValue, oldValue) {
        if (newValue) {
          showStats();
        }
      });
    }
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').directive('dnsimStringToNumber', dnsimStringToNumber);

function dnsimStringToNumber() {
  return {
    require: 'ngModel',
    link: function(scope, element, attrs, ngModel) {
      ngModel.$parsers.push(function(value) {
        return '' + value;
      });
      ngModel.$formatters.push(function(value) {
        return parseFloat(value, 10);
      });
    }
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').directive('dnsimStringToPercent', dnsimStringToNumber);

function dnsimStringToNumber() {
  return {
    require: 'ngModel',
    link: function(scope, element, attrs, ngModel) {
      ngModel.$parsers.push(function(value) {
        return '' + (value/100.0);
      });
      ngModel.$formatters.push(function(value) {
        return parseFloat(value, 10)*100;
      });
    }
  };
}

})();
(function () {
'use strict';
angular.module('dnsim').directive('fileChange', ['$parse', fileChangeFunction]);

function fileChangeFunction($parse) {

    return {
      restrict: 'A',
      link: function ($scope, element, attrs) {

        // Get the function provided in the file-change attribute.
        // Note the attribute has become an angular expression,
        // which is what we are parsing. The provided handler is 
        // wrapped up in an outer function (attrHandler) - we'll 
        // call the provided event handler inside the handler()
        // function below.
        var attrHandler = $parse(attrs['fileChange']);

        // This is a wrapper handler which will be attached to the
        // HTML change event.
        var handler = function (e) {

          $scope.$apply(function () {

            // Execute the provided handler in the directive's scope.
            // The files variable will be available for consumption
            // by the event handler.
            attrHandler($scope, { $event: e, files: e.target.files });
          });
        };

        // Attach the handler to the HTML change event 
        element[0].addEventListener('change', handler, false);
      }
    };
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('character',['dntData','itemColumnsToLoad','jobs','hCodeValues',character]);
function character(dntData,itemColumnsToLoad,jobs,hCodeValues) {

  var jobConversions = 'rebootplayerweighttable.lzjson';
  var statCaps = 'playercommonleveltable.lzjson';
  var jobBaseStats = 'playerleveltable.lzjson';

  var heroLevels = 'heroleveltable.lzjson';
  var heroLevelPotentials = 'potentialtable_herolevel.lzjson';
  
  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }

  return {
    init: function(complete) {
      jobs.init(reportProgress, complete);
      dntData.init(jobConversions, itemColumnsToLoad.jobConversionColsToLoad, reportProgress, complete);
      dntData.init(statCaps, itemColumnsToLoad.statCapColsToLoad, reportProgress, complete);
      dntData.init(jobBaseStats, itemColumnsToLoad.jobBaseStatColsToLoad, reportProgress, complete);
      dntData.init(heroLevels, null, reportProgress, complete);
      dntData.init(heroLevelPotentials, null, reportProgress, complete);
    },
    
    getHeroStats: function(heroLevel) {
      var heroStats = [];
      if(heroLevel > 0) {
        var index = dntData.findFast(heroLevels, 'id', heroLevel);
        if(index.length == 1) {
          var h = dntData.getRow(heroLevels, index[0]);
          if(h) {
            var pIndex = dntData.findFast(heroLevelPotentials, 'PotentialID', h.HeroLevelAbilityID);
            if(pIndex.length == 1) {
              var p = dntData.getRow(heroLevelPotentials, pIndex[0]);
              if(p) {
                heroStats = hCodeValues.getStats(p);
              }
            }
          }
        }
      }
      return heroStats;
    },
    
    getStatCaps: function(level) {
      if(level > 0) {
        var index = dntData.findFast(statCaps, 'id', level);
        if(index.length == 1) {
          return dntData.getRow(statCaps, index[0]);
        }
      }
      
      return {};
    },
    
    getConversions: function(jobId) {
      if(jobId > 0) {
        var index = dntData.findFast(jobConversions, 'id', jobId);
        if(index.length == 1) {
          return dntData.getRow(jobConversions, index[0]);
        }
      }
      
      return {};
    },
    
    getBaseStats: function(level, jobId) {
      if(level > 0 && jobId > 0) {
        var index = dntData.findFast(jobBaseStats, 'id', (Number(jobId) * 100) + Number(level) - 100);
        if(index.length == 1) {
          return dntData.getRow(jobBaseStats, index[0]);
        }
      }
      
      return {};
    }
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('itemColumnsToLoad',[itemColumnsToLoad]);
function itemColumnsToLoad() {
  return {
    mainDnt: {
      NameID: true, DescriptionID: true, NameIDParam: true, DescriptionIDParam: true,
      Type: true,TypeParam1: true,TypeParam2: true, TypeParam3: true, LevelLimit: true, NeedJobClass: true, Rank: true,
      State1: true, StateValue1: true, State1_Max: true, State1_GenProb: true,
      State2: true, StateValue2: true, State2_Max: true,
      State3: true, StateValue3: true, State3_Max: true,
      State4: true, StateValue4: true, State4_Max: true,
      State5: true, StateValue5: true, State5_Max: true,
      State6: true, StateValue6: true, State6_Max: true,
      State7: true, StateValue7: true, State7_Max: true,
      State8: true, StateValue8: true, State8_Max: true,
      State9: true, StateValue9: true, State9_Max: true,
      State10: true,StateValue10: true,State10_Max: true,
      EnchantID: true,
      SkillID: true,
      dragonjeweltype: true, AbleWStorage: true, ExchangeType:true, IconImageIndex: true, IsCash: true, DisjointDrop1: true, Disjointamount: true
    },
    partsDnt: {
      SetItemID: true
    },
    enchantDnt: {
      EnchantID: true,EnchantLevel: true,EnchantRatio: true,BreakRatio: true,MinDown: true,MaxDown: true,NeedCoin: true,
      DisjointDrop: true,
      NeedItemID1: true,NeedItemCount1: true,NeedItemID2: true,NeedItemCount2: true,NeedItemID3: true,NeedItemCount3: true,NeedItemID4: true,NeedItemCount4: true,NeedItemID5: true,NeedItemCount5: true,ProtectItemCount: true,
      State1: true,State1Value: true,State2: true,State2Value: true,State3: true,State3Value: true,State4: true,State4Value: true,State5: true,State5Value: true,State6: true,State6Value: true,State7: true,State7Value: true,State8: true,State8Value: true,State9: true,State9Value: true,State10: true,State10Value: true
    },
    potentialDnt : {
      PotentialID: true, PotentialNo: true,PotentialRatio: true,
      State1: true,State1Value: true,
      State2: true,State2Value: true,
      State3: true,State3Value: true,
      State4: true,State4Value: true,
      State5: true,State5Value: true,
      State6: true,State6Value: true,
      State7: true,State7Value: true,
      State8: true,State8Value: true,
      State9: true,State9Value: true,
      State10: true,State10Value: true,
      State11: true,State11Value: true,
      State12: true,State12Value: true,
      State13: true,State13Value: true,
      State14: true,State14Value: true,
      State15: true,State15Value: true,
      State16: true,State16Value: true
    },
    gemDnt: {
      Type: true
    },
    setDnt : null,
    sparkDnt: null,
    jobsDnt: {
      JobName: true,JobNumber: true,BaseClass: true,ParentJob: true, EnglishName: true, JobIcon: true
    },
    jobBaseStatColsToLoad: {
      Strength:true,Agility:true,Intelligence:true,Stamina:true,AggroperPvE:true,BaseMP:true
    },
    statCapColsToLoad: {
      Cbase: true,
      Cdefense: true,
      Ccritical: true,
      Cfinaldamage: true,
      CcriticalDamage: true,
    },
    jobConversionColsToLoad: {
      HP: true,StrengthAttack: true,AgilityAttack: true,IntelligenceAttack: true,PhysicalDefense: true,MagicDefense: true,Critical: true,CriticalResistance: true,Stiff: true,StiffResistance: true,Stun: true,StunResistance: true,MoveSpeed: true,MoveSpeedRevision: true,DownDelay: true,ElementAttack: true,ElementDefense: true,ElementDefenseMin: true,ElementDefenseMax: true,StrengthIntelligenceToCriticalDamage: true
    }
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('dntData', ['$rootScope','$timeout',dntData]);

function dntData($rootScope,$timeout) {
  
  function createLoader(dntLocation, file, colsToLoad) {

    var loader = {
      reader: new DntReader(),
      
      loaded: false,
      startedLoading: false,
      
      file: file,
      
      dntLocation: dntLocation,
      progressCallback: null,
      completeCallbacks : [],
      
      init: function(progress, complete) {
        
        if(this.loaded) {
          if(complete) {
            complete();
          }
        }
        else {
          this.progressCallback = progress;
          if(complete) {
            this.completeCallbacks.push(complete);
          }
          
          if(!this.startedLoading) {
            this.startedLoading = true;
            var t = this;
            
            this.reader.colsToLoad = colsToLoad;
            
            if(this.dntLocation && 
              this.dntLocation.url &&
              this.dntLocation.url.length) {

              $rootScope.$broadcast('DNTDATA_LOAD_EVENT');

              $timeout(function() {
                t.reader.loadDntFromServerFile(
                  t.dntLocation.url + '/' + file,
                  function(msg) { if(t.progressCallback) t.progressCallback(msg) }, 
                  function(result, fileName) {
                    // console.info('dnt loading complete : ' + file);
                    t.loaded = true;
                    
                    angular.forEach(t.completeCallbacks, function(value, key) {
                      if(value) {
                        value();
                      }
                    });
                    t.completeCallbacks = [];
                    $rootScope.$broadcast('DNTDATA_LOAD_EVENT');
                  },
                  function(msg) {
                    $rootScope.$broadcast('DNTDATA_LOAD_ERROR');
                    t.startedLoading = false;
                    t.loaded = false;
                  }  );
              });
            }
            else {
              // console.log("dnt location not set!");
            }
          }
        }
      },
      
      reset: function() {
        this.reader = new DntReader();
        this.loaded = false;
        this.startedLoading = false;
      }
    }
  
    return loader;
  };
  
  return {
    loaders : {},
    findIndexes : {},
    dntLocation : null,
    
    setLocation: function(location) {
      this.dntLocation = location;
      var t = this;
      angular.forEach(this.loaders, function(value, key) {
        if(value.dntLocation != location) {
          value.dntLocation = location;
          t.reset(key);
        }
      });
    },
    
    init : function (fileName, colsToLoad, progress, complete) {
      if(!progress) {
        progress = function() {};
      }
      if(!(fileName in this.loaders)) {
        if(fileName.length > 0) {
          this.loaders[fileName] = createLoader(this.dntLocation, fileName, colsToLoad);
        }
      }
      this.loaders[fileName].init(progress, complete);
    },
    getData : function (fileName) {
      if(this.isLoaded(fileName)) {
        var reader = this.loaders[fileName].reader;
        var retVal = new Array(reader.numRows);
        for(var i=0;i<reader.numRows;++i) {
          retVal[i] = reader.getRow(i);
        }
        
        return retVal;
      }
      else {
        return [];
      }
    },
    find : function(fileName, column, value) {
      var results = this.findFast(fileName, column, value);
      var retVal = [];
      var numResults = results.length;
      for(var i=0;i<numResults;++i) {
        retVal.push(this.getRow(fileName, results[i]));
      }
      
      return retVal;
    },
    findFast : function(fileName, column, value) {
      
      if(this.isLoaded(fileName)) {
        if(!(fileName in this.findIndexes)){
          this.findIndexes[fileName] = {};
        }
        
        var reader = this.loaders[fileName].reader;
        var colIndex = reader.columnIndexes[column];
        
        var findIndex = this.findIndexes[fileName];
        
        if(!(column in findIndex)) {
          var index = {}
          findIndex[column] = index;
          
          var results = [];
          
          var data = reader.data;
          var len = data.length;
          for(var r=0;r<len;++r) {
            var d = data[r];
            var val = d[colIndex];

            if(!(val in index)) {
              index[val] = [r];
            }
            else {
              index[val].push(r);
            }
          }
        }
        
        if(value in findIndex[column]) {
          return findIndex[column][value];
        }
        else {
          return [];
        }
      }
      
      return [];
    },
    isLoaded : function(fileName) {
      return fileName in this.loaders && this.loaders[fileName].loaded;
    },
    hasStartedLoading : function(fileName) {
      return this.isLoaded(fileName) || (fileName in this.loaders && this.loaders[fileName].startedLoading);
    },
    reset : function(fileName) {
      if(fileName in this.loaders) {
        this.loaders[fileName].reset();
        delete this.loaders[fileName];
        delete this.findIndexes[fileName];
      }
    },
    resetAll : function() {
      var t = this;
      angular.forEach(this.loaders, function(value, key) {
        t.reset(key);
      });
    },
    anyLoading : function() {
      var t = this;
      var found = 0;
      angular.forEach(this.loaders, function(value, key) {
        if(!value.loaded && value.startedLoading) {
          found++;
        }
      });
      
      return found;
    },
    getNumRows : function(fileName) {
      if(this.isLoaded(fileName)) {
        return this.loaders[fileName].reader.numRows;
      }
      else {
        return 0;
      }
    },
    getRow : function(fileName, index) {
      if(this.isLoaded(fileName)) {
        return this.loaders[fileName].reader.getRow(index);
      }
      else {
        return {};
      }
    },
    lookupValue: function(fileName, data, columnName) {
      if(this.isLoaded(fileName)) {
        return data[this.loaders[fileName].reader.columnNames[columnName]];
      }
      else {
        return null;
      }
    },
    convertData: function(fileName, data) {
      if(this.isLoaded(fileName)) {
        return this.loaders[fileName].reader.convertData(data);
      }
      else {
        return null;
      }
    },
    getValue : function(fileName, index, columnName) {
      if(this.isLoaded(fileName)) {
        return this.loaders[fileName].reader.getValue(index, columnName);
      }
      else {
        return null;
      }
    }
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('dntInit', ['items','jobs','dntData','itemFactory',dntInit]);
function dntInit(items,jobs,dntData,itemFactory) {
  return function(progress) {
    
    progress('starting init');
    
    var allFactories = [jobs];
    
    var dntFiles = {};
    angular.forEach(items, function(item, key) {
      if(key != 'all') {
        angular.forEach(item, function(value, prop) {
          if(prop.indexOf('Dnt') == prop.length-3) {
            var newFactory = { 
              init: function(progress, complete) {
                dntData.init(value, null, progress, complete);
              },
              isLoaded: function() {
                return dntData.isLoaded(value);
              },
              fileName: value,
            };
            
            allFactories.push(newFactory);
          }
        });
      }
    });
    
    function initFactory(index) {
    
      if(index < allFactories.length) {
        allFactories[index].init(progress, function() { 
          if(allFactories[index].isLoaded()) {
            if('fileName' in allFactories[index]) {
              progress('dnt loaded: ' + allFactories[index].fileName);
            }
            initFactory(index+1);
          }
        });
      }
      else {
        progress('Full initialise complete');
      }
    }
    
    initFactory(0);
  }
}
})();
(function () {
'use strict';

angular.module('dnsim').factory('dntReset',['items','jobs','dntData',dntReset]);
function dntReset(items, jobs, dntData) {
  return function() {
    
    angular.forEach(items, function(source, name) {
      source.reset();
    });
    
    jobs.reset();
    dntData.resetAll();
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('exportLinkHelper', 
['$http','items','dntData','itemFactory','hCodeValues','itemColumnsToLoad','statHelper','translations','itemCategory','region',exportLinkHelper]);
function exportLinkHelper($http,items,dntData,itemFactory,hCodeValues,itemColumnsToLoad,statHelper,translations,itemCategory,region) {

  return {
    
    encodeItem: function(item, small) {
      if(item) {
        var itemString;

        if(item.typeName == 'custom')  {
          itemString = '_custom';
          angular.forEach(item.stats, function(stat, index) {
            if(index > 0) {
              itemString += '|';
            }
            else {
              itemString += ':C';
            }
            itemString += stat.id.toString(36) + '=' + stat.max;
          });
        }
        else if(item.id) {
          itemString = 'I' + item.id.toString(36) + ':_';
          if('itemSource' in item) {
            itemString += item.itemSource;
          }
          else if('itemTypeName' in item) {
            // this is to support groups saved with the old property name
            itemString += item.itemTypeName;
          }
          else if(item.fileName) {
            itemString += ':F' + item.fileName;
          }
        
          if(item.enchantmentNum || item.enchantmentNum == 0) {
            itemString += ':E' + item.enchantmentNum.toString(36);
          }
          if(item.pid > 0) {
            itemString += ':P' + item.pid.toString(36);
          }
          // if(item.setId > 0) {
            // itemString += ':S' + item.setId.toString(36);
          // }
          if(item.sparkId > 0) {
            itemString += ':H' + item.sparkId.toString(36);
          }
          if(item.typeName == 'skills') {
            itemString += ':J' + item.baseJobName;
          }
          if(item.pve) {
            itemString += ':V' + item.pve;
          }
        }
        
        if(item.name && !small) {
          itemString += ':.' + item.name.replace(/ /g, '-').replace(/\//g, ' ');
        }

        return itemString;
      }
      
      return '';
    },
    
    decodeItem: function(itemStr) {
      var item = {};
      
      if(itemStr) {
        angular.forEach(itemStr.split(':'), function(itemBit, bitIndex) {
          if(itemBit.charAt(0) == 'I') {
            item.id = parseInt(itemBit.substr(1), 36);
          }
          else if(itemBit.charAt(0) == 'E') {
            item.enchantmentNum = parseInt(itemBit.substr(1), 36);
          }
          else if(itemBit.charAt(0) == 'P') {
            item.pid = parseInt(itemBit.substr(1), 36);
          }
          else if(itemBit.charAt(0) == 'S') {
            item.setId = parseInt(itemBit.substr(1), 36);
          }
          else if(itemBit.charAt(0) == 'H') {
            item.sparkId = parseInt(itemBit.substr(1), 36);
          }
          else if(itemBit.charAt(0) == 'J') {
            item.baseJobName = itemBit.substr(1);
          }
          else if(itemBit.charAt(0) == 'V') {
            item.pve = itemBit.substr(1);
          }
          else if(itemBit.charAt(0) == '_') {
            item.itemSource = itemBit.substr(1);
          }
          else if(itemBit.charAt(0) == '.') {
            item.name = itemBit.substr(1).replace('-', ' ');
          }
          else if(itemBit.charAt(0) == 'C') {
            item.stats = [];
            var statString = itemBit.substr(1);
            angular.forEach(statString.split('|'), function(statBit, statBitIndex) {
              var splitStat = statBit.split('=');
              item.stats.push({
                id: parseInt(splitStat[0], 36),
                max: Number(splitStat[1])
              });
            });
          }
          else if(itemBit.charAt(0) == 'F') {
            
            item.fileName = itemBit.substr(1);
            angular.forEach(items, function(itemSource, key) {
              if(itemSource.mainDnt && itemSource.mainDnt.indexOf(item.fileName + '.') == 0) {
                item.itemSource = key;
              }
            });
          }
        });
      }
      
      return item;
    },
    
    createGroupLink: function(groupName, group) {
      var itemStrings = [];
      var self = this;
      
      if(group == null) {
        return '';
      }
      
      angular.forEach(group.items, function(item, key) {
        var itemString = self.encodeItem(item, true);  
        if(itemString && itemString.length) {
          itemStrings.push(itemString);
        }
      });
  
      var retVal = 'view-group?region=' + region.dntLocation.region;
      
      
      if(group.enemyLevel) {
        retVal += '&e=' + group.enemyLevel;
      }
      if(group.playerLevel) {
        retVal += '&p=' + group.playerLevel;
      }
      if(group.heroLevel) {
        retVal += '&h=' + group.heroLevel;
      }
      if(group.job && group.job.id) {
        retVal += '&j=' + group.job.id;
      }
      if(group.damageType && group.damageType.id) {
        retVal += '&d=' + group.damageType.id;
      }
      if(group.element && group.element.id) {
        retVal += '&t=' + group.element.id;
      }
      if(group.secondaryElement && group.secondaryElement.id) {
        retVal += '&s=' + group.secondaryElement.id;
      }
      retVal += '&g=' + encodeURI(groupName) + '&i=' + itemStrings.join(',');
      return retVal;
    },

    createShortUrl: function(groupName, group) {
      
      var path = this.createGroupLink(groupName, group);
      var basePath = angular.element(document.querySelector('base')).attr('href');
      var longUrl = window.location.href.split(basePath)[0] + basePath + path;
      var data = { longUrl: longUrl };
      console.log('getting short url for ', longUrl);
      
    	$http.post(
    	  'https://www.googleapis.com/urlshortener/v1/url?key=AIzaSyD5t5o7ZcSAvM-xMwc14ft2BA-MKQA7LMo', data).success(
    	    function(data,status,headers,config){
        		group.shortUrl = data.id;
    	      sessionStorage.setItem(path, data.id);
        	}).
        	error(function(data,status,headers,config){
        		// console.log(data);
        		// console.log(status);
        		// console.log(headers);
        		// console.log(config);
        	});
    },
    
    reloadItem: function(item) {

      if(item == null) {
        // console.log('cannot reload null item');
        return;
      }
      
      // support for old property name
      if('itemTypeName' in item && !item.itemSource) {
        item.itemSource = item.itemTypeName;
      }
      
      // console.log('checking ' + item.itemSource)
      if(item.itemSource == 'rbTech') {
        item.itemSource = 'tech';
        // console.log('changed to ' + item.itemSource)
      }
      
      if(item.itemSource == 'custom' || item.typeName == 'custom') {
        item.typeName = 'custom';
        return item;
      }
      else if(item.itemSource == 'skills' || item.typeName == 'skills') {
        
        if(!item.enchantmentNum) {
          item.enchantmentNum = 1;
        }
        
        var skillDnt = 'skilltable_character' + item.baseJobName + '.lzjson';
        var pv = 'pve';
        if(item.pve == 'pvp') {
          pv = 'pvp';
        }
        var skillLevelDnt = 'skillleveltable_character' + item.baseJobName + pv + '.lzjson';
        
        var skillData = dntData.find(skillDnt, 'id', item.id)[0];
        if(!skillData) {
          console.log('cannot get skill data from ', skillDnt);
        }
        var skillLevelDatas = dntData.getData(skillLevelDnt);

        var skillLevelVals = {};
        angular.forEach(skillLevelDatas, function(value, index) {
          if(value.SkillIndex == item.id && value.SkillLevel == item.enchantmentNum) {
            skillLevelVals = value;
            return;
          }
        });
        
        var newItem = {
          id: item.id,
          itemSource: item.itemSource,
          typeName: item.itemSource,
          needJobClass: skillData.NeedJob,
          baseJobName: item.baseJobName,
          rank: hCodeValues.rankNames[0],
          enchantmentNum: item.enchantmentNum,
          name: translations.translate(skillData.NameID, skillData.NameIDParam),
          description: translations.translate(skillLevelVals.SkillExplanationID, skillLevelVals.SkillExplanationIDParam),
          icon: skillData.IconImageIndex,
          pve: item.pve,
        };
        
        newItem.stats = statHelper.getSkillStats(newItem, skillData, skillLevelDatas);
        return newItem;
      }
      else if(item.itemSource in items) {
        
        var itemType = items[item.itemSource];
        var ds = dntData.find(itemType.mainDnt, 'id', item.id);
        if(!ds.length) {
          console.log('item ' + item.id + ' not found in ' + itemType.mainDnt);
        }
        else {
          var d = ds[0];
        
          var totalRatio = 0;
          var p = null;
          
          var ps = dntData.find(itemType.potentialDnt, 'id', item.pid);
          if(!ps.length) {
            ps = dntData.find(itemType.potentialDnt, 'PotentialID', d.TypeParam1);
          }
          
          if(!ps.length) {
            ps = dntData.find(itemType.potentialDntEx, 'id', item.pid);
            if(!ps.length) {
              ps = dntData.find(itemType.potentialDntEx, 'PotentialID', d.TypeParam1);
            }
          }
          
          if(ps.length > 0) {
            p = ps[0];
            
            if(p.PotentialID != d.TypeParam1) {
              // this happened one time
              // not sure how but it corrupted the stats
              p = null;
              console.log('bad potential');
            }
            else {
              var potentials = dntData.find(itemType.potentialDnt, 'PotentialID', p.PotentialID);
              angular.forEach(potentials, function(value, key) {
                totalRatio += value.PotentialRatio;
              });
            }
          }
          
          var newItem = itemFactory.createItem(itemType.name, d, p, totalRatio);
          itemFactory.initItem(newItem);
          itemCategory.setItemCategory(newItem, d);

          var usePartDnt = null;
          if(newItem.typeName != 'weapons' && newItem.typeId != 0) {
            usePartDnt = 'partsDnt';
          }
          else {
            usePartDnt = 'weaponDnt';
          }
      
          if(usePartDnt) {
            if(dntData.isLoaded(itemType[usePartDnt]) && dntData.isLoaded(itemType.setDnt)) {
              newItem.setStats = [];
              var parts = dntData.find(itemType[usePartDnt], 'id', item.id);
              if(parts.length > 0) {
                newItem.setId = parts[0].SetItemID;
                var sets = dntData.find(itemType.setDnt, 'id', parts[0].SetItemID);
                if(sets.length > 0) {
                  newItem.setStats = hCodeValues.getStats(sets[0]);
                }
              }
            }
          }

          newItem.fullStats = newItem.stats;
          if(item.enchantmentNum >= 0) {
            newItem.enchantmentNum = item.enchantmentNum;
            
            if(newItem.typeName == 'skills') {
              
            }
            else if(newItem.typeName == 'talisman') {
              var extraStats = [];
              angular.forEach(newItem.stats, function(stat, index) {
                extraStats.push({id: stat.id, max: stat.max * (newItem.enchantmentNum/100)});
              });
              
              newItem.enchantmentStats = extraStats;
              newItem.fullStats = hCodeValues.mergeStats(newItem.enchantmentStats, newItem.stats);
            }
            else {
              var enchantments = dntData.find(itemType.enchantDnt, 'EnchantID', newItem.enchantmentId);
              angular.forEach(enchantments, function(enchantment, index) {
                if(enchantment.EnchantLevel == newItem.enchantmentNum) {
                  newItem.enchantmentStats = hCodeValues.getStats(enchantment);
                  newItem.fullStats = hCodeValues.mergeStats(newItem.enchantmentStats, newItem.stats);
                  return;
                }
              });
            }
          }
          
          if(item.sparkId > 0) {
            newItem.sparkId = item.sparkId;
            var sparks = dntData.find(itemType.sparkDnt, 'id', item.sparkId);
            if(sparks.length > 0) {
              newItem.sparkStats = hCodeValues.getStats(sparks[0]);
              newItem.fullStats = hCodeValues.mergeStats(newItem.fullStats, newItem.sparkStats);
            }
          }
          else if(d.dragonjeweltype) {
            newItem.offensiveGemSlots = 0;
            newItem.increasingGemSlots = 0;
            var itemData = dntData.find('dragonjewelslottable.lzjson', 'DragonJewelID', d.dragonjeweltype);
            if(itemData && itemData.length > 0) {
              if(itemData[0].DragonJewelSlot1 == 1) newItem.offensiveGemSlots++;
              if(itemData[0].DragonJewelSlot2 == 1) newItem.offensiveGemSlots++;
              if(itemData[0].DragonJewelSlot3 == 1) newItem.offensiveGemSlots++;
              if(itemData[0].DragonJewelSlot4 == 1) newItem.offensiveGemSlots++;
              
              if(itemData[0].DragonJewelSlot1 == 2) newItem.increasingGemSlots++;
              if(itemData[0].DragonJewelSlot2 == 2) newItem.increasingGemSlots++;
              if(itemData[0].DragonJewelSlot3 == 2) newItem.increasingGemSlots++;
              if(itemData[0].DragonJewelSlot4 == 2) newItem.increasingGemSlots++;
            }
          }
          
          return newItem;
        }
      }
      
      if(item.fileName) {
        var datas = dntData.find(item.fileName + '.lzjson', 'id', item.id);
        if(datas.length > 0) {
          var d = datas[0];
          var newItem = {
            id: item.id,
            data: d,
            levelLimit : d.LevelLimit,
            needJobClass : d.NeedJobClass,
            typeId : d.Type,
            exchangeType: d.ExchangeType,
            rank : hCodeValues.rankNames[d.Rank],
            fileName: item.fileName,
            description: translations.translate(d.DescriptionID, d.DescriptionIDParam),
          };
          
          itemFactory.initItem(newItem);
          return newItem;
        }
        else {
          return {name: 'unknown item'};
        }
      }
      else {
        return {name: 'unknown item source: ' + item.itemSource};
      }
    },
    
    getDntFiles: function(item) {

      var dntFiles = {};

      if(item == null) {
      }
      else {
        if(!item.itemSource && item.itemTypeName in items) {
          item.itemSource = item.itemTypeName;
        }
        
        if(item.itemSource == 'rbTech') {
          item.itemSource = 'tech';
        }
        
        if(item.itemSource in items) {
          var itemType = items[item.itemSource];
          
          dntFiles['exchange.lzjson'] = null;
          dntFiles['dragonjewelslottable.lzjson'] = null;
  
          dntFiles[itemType.mainDnt] = itemColumnsToLoad.mainDnt;
          if('potentialDnt' in itemType) {
            dntFiles[itemType.potentialDnt] = itemColumnsToLoad.potentialDnt;
          }
          if('potentialDntEx' in itemType) {
            dntFiles[itemType.potentialDntEx] = itemColumnsToLoad.potentialDnt;
          }
          
          if('enchantDnt' in itemType) {
            dntFiles[itemType.enchantDnt] = itemColumnsToLoad.enchantDnt;
          }
          
          if('weaponDnt' in itemType) {
            dntFiles[itemType.weaponDnt] = itemColumnsToLoad.weaponDnt;
          }
          
          if('partsDnt' in itemType) {
            dntFiles[itemType.partsDnt] = itemColumnsToLoad.partsDnt;
          }
          
          if('setDnt' in itemType) {
            dntFiles[itemType.setDnt] = itemColumnsToLoad.setDnt;
          }
          
          if('gemDnt' in itemType) {
            dntFiles[itemType.gemDnt] = itemColumnsToLoad.gemDnt;
          }
          
          if('sparkDnt' in itemType) {
            dntFiles[itemType.sparkDnt] = itemColumnsToLoad.sparkDnt;
          }
        }
        
        if(item.itemSource == 'skills' || item.typeName == 'skills') {
            var skillDnt = 'skilltable_character' + item.baseJobName + '.lzjson';
            dntFiles[skillDnt] = null;
            var skillLevelDnt = 'skillleveltable_character' + item.baseJobName + 'pve' + '.lzjson';
            dntFiles[skillLevelDnt] = null;
            skillLevelDnt = 'skillleveltable_character' + item.baseJobName + 'pvp' + '.lzjson';
            dntFiles[skillLevelDnt] = null;
        }
        
        
        if(item.fileName) {
          dntFiles[item.fileName + '.lzjson'] = null;
        }
      }
      
      return dntFiles;
    }
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('groupHelper', ['exportLinkHelper',groupHelper]);
function groupHelper(exportLinkHelper) {
  'use strict';
  
  return {
    reloadGroup: function(groupName, group) {
      var newItems = [];
      angular.forEach(group.items, function(item, key) {
        var newItem = exportLinkHelper.reloadItem(item);
        if(newItem) {
          newItems.push(newItem);
        }
      });
      
      return newItems;
    },
    
    getDntFiles: function(group) {

      var allDntFiles = {};
      angular.forEach(group.items, function(item, key1) {
        
        var dntFiles = exportLinkHelper.getDntFiles(item);

        angular.forEach(dntFiles, function(value, key) {
          allDntFiles[key] = value;
        });
      });
      
      return allDntFiles;
    }
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('itemCategory',
['itemFactory','items','dntData',itemCategory]);
function itemCategory(itemFactory,items,dntData) {

  return {
    categories: [
      {path: 'titles', name:'titles', sourceType: 'titles', hideRank: true, hideJob: true, hideLevel: true, numItemText: '1', maxCat: 1},
      {path: 'weapons', name:'weapons', sourceType: 'equipment', numItemText: '2', maxExchange: 1, maxCat: 2, limitExchange: [1,2]},
      {path: 'armour', name:'armour', sourceType: 'equipment', numItemText: '5', maxExchange: 1, maxCat: 5, limitExchange: [3,4,5,6,7]},
      {path: 'accessories', name:'accessories', sourceType: 'equipment', hideJob: true, maxCat: 4, maxExchange: 2, limitExchange: [8,9,10]},
      {path: 'techs', name:'techs', sourceType: 'techs', maxCat: 4, maxExchange: 2, limitExchange: [8,9,10]},
      {path: 'offensive-gems', name:'offensive gems', sourceType: 'gems', hideJob: true, maxCat: 4, maxExchange: 4, limitExchange: [54]},
      {path: 'increasing-gems', name:'increasing gems', sourceType: 'gems', hideJob: true, maxCat: 14, maxExchange: 14, limitExchange: [54]},
      {path: 'enhancement-plates', name:'enhancement plates', sourceType: 'plates', hideJob: true, numItemText: '8+3', maxCat: 11, maxExchange: 15, limitExchange: [33]},
      {path: 'expedition-plates', name:'expedition plates', sourceType: 'plates', hideRank: true, hideJob: true, numItemText: '4', maxCat: 4, maxExchange: 15, limitExchange: [33]},
      {path: 'talisman', name:'talisman', sourceType: 'talisman', hideJob: true, numItemText: '8+4', maxCat: 12, maxExchange: 12, limitExchange: [52,53]},
      {path: 'costume', name:'costume', sourceType: 'cash', numItemText: '7', maxCat: 7, maxExchange: 1, hideLevel: true, limitExchange: [16,17,18,19,20,21,22]},
      {path: 'imprint', name:'imprint', sourceType: 'imprint', hideLevel: true, hideJob: true},
      {path: 'cash', name:'cash', sourceType: 'cash', numItemText: '8', maxCat: 8, maxExchange: 2, hideJob: true, hideLevel: true, limitExchange: [23,24,25,26,27,28,29]},
      {path: 'extras', name:'extras', sourceType: 'xtras', limitExchange: [47], hideJob: true, hideLevel: true,},
      {path: 'skills', name:'skills', searchType: 'skills'},
      {path: 'custom', name:'custom', searchType: 'custom'},
      ],
      
    byName: function(name) {
      var retVal = null;
      angular.forEach(this.categories, function(category, index) {
        if(category.name == name) {
          retVal = category;
        }
      });
      
      return retVal;
    },
      
    byPath: function(name) {
      var retVal = null;
      angular.forEach(this.categories, function(category, index) {
        if(category.path == name) {
          retVal = category;
        }
      });
      
      return retVal;
    },
    
    getItems: function(name) {
      var cat = this.byName(name);
      if(cat && 'sourceType' in cat) {
        var retVal = [];
        angular.forEach(items, function(source, sourceName) {
          if(source.type == cat.sourceType && retVal) {
            if(!source.items && !source.loading) {
              itemFactory.loadItems(source);
            }
            
            if(source.items) {
              retVal = retVal.concat(source.items);
            }
            else {
              retVal = null; // if any are null just return null
            }
          }
        });
        
        var catItems = [];
        if(retVal) {
          var vm = this;
          angular.forEach(retVal, function(item, index) {
            if(item.typeName == cat.name ||
              vm.isItemForCat(cat, item, item.data)) {

              item.typeName = name;
              catItems.push(item);
            }
          });
        }
        
        return catItems;
      }
      else {
        return null;
      }
    },
    
    isItemForCat: function(cat, item, rawData) {
      
      if(item.itemSource in items && items[item.itemSource].type != cat.sourceType) {
        return false;
      }
      
      if(item.itemType == cat.name) {
        return true;
      }
      
      if(cat.limitExchange) {
        
        for(var i=0;i<cat.limitExchange.length;++i) {
          if(cat.limitExchange[i] == item.exchangeType || (rawData && cat.limitExchange[i] == rawData.ExchangeType)) {
            
            if(item.itemSource == 'plate') {
              if((item.rawData && rawData.Rank == 4) || (item.rank && item.rank.id == 4)) {
                return cat.name == 'expedition plates';
              }
              else {
                return cat.name == 'enhancement plates';
              }
            }
            else if(item.itemSource == 'gem') {
              var gemTypes = dntData.find(items.gem.gemDnt, 'id', item.id);
              if(gemTypes.length > 0) {
                
                if(gemTypes[0].Type == 1) {
                  return cat.name == 'offensive gems';
                }
                else if(gemTypes[0].Type == 2) {
                  return cat.name == 'increasing gems';
                }
                else {
                  return false;
                }
              }
            }
            
            return true;
          }
        }
      }
      else if(item.itemSource in items) {
        return items[item.itemSource].type == cat.sourceType;
      }

      return false;
    },
    
    init: function(name, complete) {
      var cat = this.byName(name);
      if(cat && 'sourceType' in cat) {
        angular.forEach(items, function(source, sourceName) {
          if(source.type == cat.sourceType) {
            source.init(function() {}, complete);
          }
        });
      }
    },
    
    setItemCategory: function (item, rawData) {
      var vm = this;
      
      angular.forEach(this.categories, function(cat, index) {
        if(vm.isItemForCat(cat, item, rawData)) {
          item.typeName = cat.name;
        }
      });
    },
    
    getItemsByCategory: function(items) {
      var itemMap = {};
      if(items) {
        var types = {};
        angular.forEach(items, function(item, index) {
          if(item) {
            if(!(item.typeName in types)) {
              types[item.typeName] = [];
            }
            types[item.typeName].push(item);
          }
        });
        
        angular.forEach(this.categories, function(category, index) {

          if(category.name in types) {
            
            var sorted = types[category.name].sort(function(item1, item2) {
              if(category.name == 'talisman') {
                
                var enh1 = item1.enchantmentNum;
                if(!enh1) enh1 = 0;
                var enh2 = item2.enchantmentNum;
                if(!enh2) enh1 = 0;
                
                if(enh1 != enh2) {
                  return enh2 - enh1;
                }
              }
              else if(item1.itemSource == 'gem' || item1.itemSource == 'plate') {
                if(item1.gemSlot || item2.gemSlot) {
                  if(!item1.gemSlot) {
                    return 1;
                  }
                  else if(!item2.gemSlot) {
                    return -1;
                  }
                  return item1.gemSlot - item2.gemSlot;
                }
                else {
                  return item2.levelLimit - item1.levelLimit;
                }
              }
              else if('exchangeType' in item1 && 'exchangeType' in item2) {
                return item1.exchangeType - item2.exchangeType;
              }
              
              return item1.name.localeCompare(item2.name);
            });
            itemMap[category.name] = sorted;
          }
          else {
            itemMap[category.name] = [];
          }
        });
        
        angular.forEach(items, function(item, index) {
          if(item && !(item.typeName in itemMap)) {
            // console.log('we dont know ' + item.typeName + ' anymore')
            itemMap.typeError = true;
          }
        });
      }
      return itemMap;
    },
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('itemFactory',
['translations','dntData','hCodeValues','items',itemFactory]);

function itemFactory(translations,dntData,hCodeValues,items) {
  
  return {
    loadItems: loadItems,
    initItem: initItem,
    createItem: createItem,
    getItemData: getItemData,
    createBasicItem: createBasicItem,
  };
  
  function createItem(itemSourceName, d, p, totalRatio) {
    
    // data and potential are used to initialise name and stats
    // this is only done when needed
    // they are then removed from the object
    return {
      data : d,
      potential : p,
      id: d.id,
      totalRatio: totalRatio,
      itemSource : itemSourceName,
      levelLimit : d.LevelLimit,
      needJobClass : d.NeedJobClass,
      typeId : d.Type,
      exchangeType: d.ExchangeType,
      rank : hCodeValues.rankNames[d.Rank],
      pid: null,
      name : null,
      stats : null,
      potentialRatio : null,
      typeName : null,
      sparkId: null,
    };
  };
  
  function loadItems(itemType) {
    
    if(!dntData.isLoaded(itemType.mainDnt)) {
      return null;
    }
    
    if(!translations.isLoaded()) {
      return null;
    }
    
    if('potentialDnt' in itemType && !dntData.isLoaded(itemType.potentialDnt)) {
      return null;
    }
    
    if('potentialDntEx' in itemType && !dntData.isLoaded(itemType.potentialDntEx)) {
      return null;
    }
    
    var start = new Date().getTime();
    
    itemType.items = [];
    var numRows = dntData.getNumRows(itemType.mainDnt);
    for(var r=0;r<numRows;++r) {
      var dType = dntData.getValue(itemType.mainDnt, r, 'Type');
      var dLevelLimit = dntData.getValue(itemType.mainDnt, r, 'LevelLimit');
      var dRank = dntData.getValue(itemType.mainDnt, r, 'Rank');
      
      // skip certain types like pouches, res scrolls, etc
      if(dType != 8 &&
        dType != 9 &&
        dType != 11 &&
        dType != 12 &&
        dType != 13 &&
        dType != 18 &&
        dType != 19 &&
        dType != 20 &&
        dType != 21 &&
        dType != 24 &&
        dType != 29 &&
        dType != 46 &&
        dType != 51 &&
        dType != 74 &&
        dType != 75 &&
        dType != 76 &&
        dType != 78 &&
        dType != 79 &&
        dType != 84 &&
        dType != 100 &&
        dType != 112 &&
        dType != 114 &&
        dType != 115 &&
        dType != 116 &&
        dType != 122 &&
        dType != 142 &&
        dType != 174 &&
        dType != 130 &&
        dType != 182 &&
        (!itemType.minLevel || dLevelLimit >= itemType.minLevel) &&
        (!itemType.maxLevel || dLevelLimit <= itemType.maxLevel) &&
        (!itemType.minRank || dRank >= itemType.minRank)) {

        var dState1_GenProb = dntData.getValue(itemType.mainDnt, r, 'State1_GenProb');
        var dStateValue1 = dntData.getValue(itemType.mainDnt, r, 'StateValue1');
        var dTypeParam1 = dntData.getValue(itemType.mainDnt, r, 'TypeParam1');
          
        // skip items with no data
        if(dState1_GenProb > 0 || dStateValue1 > 0 || dTypeParam1 > 0) {
          var d = dntData.getRow(itemType.mainDnt, r);
          
          if(itemType.type == 'techs') {
            var exists = false;
            for(var i=0;i<itemType.items.length;++i) {
              if(itemType.items[i].needJobClass == d.NeedJobClass &&
                itemType.items[i].levelLimit == d.LevelLimit &&
                itemType.items[i].potential && itemType.items[i].potential.PotentialID == dTypeParam1) {
                  exists = true;
                  break;
                }
            }
            
            if(exists) {
              continue;
            }
          }
          
          var potentials = [];
          if(dTypeParam1 > 0 && 'potentialDnt' in itemType) {
            potentials = dntData.find(itemType.potentialDnt, 'PotentialID', dTypeParam1);
            
            if(!potentials.length && 'potentialDntEx' in itemType) {
              potentials = dntData.find(itemType.potentialDntEx, 'PotentialID', dTypeParam1);
            }
          }
          
          var numPotentials = potentials.length;
          if(!numPotentials) {
            itemType.items.push(createItem(itemType.name, d, null, 0));
          }
          else {
            var totalRatio = 0;
            for(var p=0;p<numPotentials;++p) {
              totalRatio += potentials[p].PotentialRatio;
            }
            
            for(var p=0;p<numPotentials;++p) {
              
              var found = false;
              for(var q=0;q<p;++q) {
                if(potentialsMatch(potentials[p], potentials[q])) {
                  found = true;
                  break;
                }
              }
              
              if(!found) {
                for(var q=p+1;q<numPotentials;++q) {
                  if(potentialsMatch(potentials[p], potentials[q])) {
                    potentials[p].PotentialRatio += potentials[q].PotentialRatio;
                  }
                }
                
                itemType.items.push(createItem(itemType.name, d, potentials[p], totalRatio));
              }
            }
          }
        }
      }
    }
            
    var end = new Date().getTime();
    var time = end - start;
    console.log('item init time: ' + time/1000 + 's for ' + itemType.name);
  }
  
  function potentialsMatch(p1, p2) {
    
    var i = 1;
    var j = 1;
    for(;;) {
      var state1Col = 'State' + i;
      var state2Col = 'State' + j;
      
      if(p1[state1Col] == 107) {
        i++;
        state1Col = 'State' + i;
      }
      if(p2[state2Col] == 107) {
        j++;
        state2Col = 'State' + j;
      }
      
      if(!(state1Col in p1 || state2Col in p2)) {
        return true;
      }
      
      if(!(state1Col in p1)) {
        return false;
      }
      if(!(state2Col in p2)) {
        return false;
      }
      
      if(p1[state1Col] == -1 && p2[state2Col] == -1) {
        return true;
      }
      
      if(!(p1[state1Col] >= 0 || p2[state2Col] >= 0)) {
        return true;
      }
      
      if(p1[state1Col] != p2[state2Col]) {
        return false;
      }
      
      var val1Col = 'State' + i + 'Value';
      var val2Col = 'State' + j + 'Value';
      if(p1[val1Col] != p2[val2Col]) {
        return false;
      }
      
      ++i;
    }
  }
  
  function initItem(item) {
    
    if(item.data) {
      var d = item.data;
      var p = item.potential;
  
      if(item.name == null) {
        item.name = translations.translate(d.NameID, d.NameIDParam);
      }
      
      if(!item.sparkTypeId && d.TypeParam2 > 0) {
        item.sparkTypeId = d.TypeParam2;
      }
      
      if(item.stats == null) {
        var stats = hCodeValues.getStats(d);
        if(p) {
          var potentialStats = hCodeValues.getStats(p);
          stats = hCodeValues.mergeStats(stats, potentialStats);
        }
        
        item.stats = stats;
      }
      
      if(d.SkillID && !item.skillId) {
        item.skillId = d.SkillID;
      }
      
      if(item.iconIndex == null) {
        item.icon = d.IconImageIndex;
        if(!item.icon && item.itemSource == 'title') {
          item.icon = 12417;
        }
      }
      
      if(d.EnchantID && !item.enchantmentId) {
        item.enchantmentId = d.EnchantID;
      }
      
      if(p) {
        item.pid = p.id;
      
        if(item.potentialRatio === null) {
          item.potentialRatio = getPotentialRatio(p, item.totalRatio);
        }
      }
      
      delete item.data;
      delete item.potential;
    }
  }
  
  function getPotentialRatio(p, totalRatio) {
    
    if(p && p.PotentialRatio > 0 && totalRatio != 0) {
      var ratio = Math.round(p.PotentialRatio/totalRatio*100*100)/100;
      if(ratio != 100) {
        return ratio + '%';
      }
    }

    return null;
  }
  
  function getItemData(item) {
    
    var fileName = null;
    var itemType = items[item.itemSource];
    
    if(item.fileName && dntData.isLoaded(item.fileName + '.optimised.lzjson')) {
      fileName = item.fileName + '.optimised.lzjson';
    }
    else if(item.fileName && dntData.isLoaded(item.fileName + '.lzjson')) {
      fileName = item.fileName + '.lzjson';
    }
    else if(itemType && dntData.isLoaded(itemType.mainDnt)) {
      fileName = itemType.mainDnt
    }

    if(fileName) {
      var itemData = dntData.find(fileName, 'id', item.id);
      if(itemData && itemData.length > 0) {
        return itemData[0];
      }
    }
    
    return [];
  }
  
  function createBasicItem(d) {
    if(!d) {
      return [];
    }
    return {
      id: d.id,
      name: translations.translate(d.NameID, d.NameIDParam),
      rank: hCodeValues.rankNames[d.Rank],
      icon: d.IconImageIndex,
      levelLimit : d.LevelLimit,
      fileName: d.fileName,
    };
  }
}
})();
(function () {
'use strict';

angular.module('dnsim').factory('items',
['translations','dntData','itemColumnsToLoad',items]);
function items(translations,dntData,itemColumnsToLoad) {
  
  var itemSources = {
    
      title : {
        mainDnt: 'appellationtable.optimised.lzjson', 
        type: 'titles', 
        minLevel: 0, 
        minRank: 0 },
      // wspr: { mainDnt: 'itemtable_source.dnt', type: 'wellspring', minLevel: 24 },
      
      tech: { 
        mainDnt: 'itemtable_skilllevelup.optimised.lzjson', 
        potentialDnt: 'potentialtable.optimised.lzjson',
        potentialDntEx: 'potentialtable_reboot.optimised.lzjson',
        sparkDnt: 'potentialtable_potentialjewel.optimised.lzjson',
        type: 'techs', 
        minLevel: 24,
        minRank: 0},
      
      tman: { 
        mainDnt: 'itemtable_talisman.optimised.lzjson', 
        type: 'talisman', 
        potentialDnt: 'potentialtable_talismanitem.optimised.lzjson',
        minLevel: 24,
        minRank: 0 },
      
      gem: { 
        mainDnt: 'itemtable_dragonjewel.optimised.lzjson', 
        potentialDnt: 'potentialtable_dragonjewel.optimised.lzjson',
        potentialDntEx: 'potentialtable_reboot.optimised.lzjson',
        enchantDnt: 'enchanttable_dragonjewel.optimised.lzjson', 
        gemDnt: 'dragonjeweltable.optimised.lzjson',
        type: 'gems',
        minLevel: 24,
        minRank: 3},
      
      plate: { 
        mainDnt : 'itemtable_glyph.optimised.lzjson', 
        potentialDnt: 'potentialtable_glyph.optimised.lzjson',
        type: 'plates',
        minLevel: 16,
        minRank: 2 },

      items: {
        mainDnt: 'itemtable.optimised.lzjson', 
        partsDnt: 'partstable.optimised.lzjson', 
        weaponDnt: 'weapontable.optimised.lzjson', 
        enchantDnt: 'enchanttable.optimised.lzjson', 
        potentialDnt: 'potentialtable.optimised.lzjson',
        setDnt: 'setitemtable.optimised.lzjson',
        type: 'equipment',
        minLevel: 80,
        minRank: 3 },
      eq: {
        mainDnt: 'itemtable_equipment.optimised.lzjson', 
        partsDnt: 'partstable_equipment.optimised.lzjson', 
        weaponDnt: 'weapontable_equipment.optimised.lzjson', 
        enchantDnt: 'enchanttable.optimised.lzjson', 
        potentialDnt: 'potentialtable.optimised.lzjson',
        sparkDnt: 'potentialtable_potentialjewel.optimised.lzjson',
        setDnt: 'setitemtable.optimised.lzjson',
        type: 'equipment',
        minLevel: 24,
        minRank: 3 },
      rbeq: { 
        mainDnt: 'itemtable_reboot.optimised.lzjson', 
        partsDnt: 'partstable_reboot.optimised.lzjson', 
        weaponDnt: 'weapontable_reboot.optimised.lzjson', 
        enchantDnt: 'enchanttable_reboot.optimised.lzjson', 
        potentialDnt: 'potentialtable_reboot.optimised.lzjson',
        setDnt: 'setitemtable.optimised.lzjson',
        type: 'equipment',
        minLevel: 24,
        minRank: 3 },
      pvpeq: { 
        mainDnt: 'itemtable_pvp.optimised.lzjson',
        partsDnt: 'partstable_pvp.optimised.lzjson', 
        weaponDnt: 'weapontable_pvp.optimised.lzjson', 
        enchantDnt: 'enchanttable.optimised.lzjson', 
        setDnt: 'setitemtable.optimised.lzjson',
        type: 'equipment',
        minLevel: 24,
        minRank: 3 },

      c2016: { 
        mainDnt: 'itemtable_common2016.optimised.lzjson', 
        partsDnt: 'partstable_common2016.optimised.lzjson', 
        weaponDnt: 'weapontable_common2016.optimised.lzjson', 
        setDnt: 'setitemtable_cash.optimised.lzjson',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      c2015: { 
        mainDnt: 'itemtable_common2015.optimised.lzjson', 
        partsDnt: 'partstable_common2015.optimised.lzjson', 
        weaponDnt: 'weapontable_common2015.optimised.lzjson', 
        setDnt: 'setitemtable_cash.optimised.lzjson',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      c2014: { 
        mainDnt: 'itemtable_common2014.optimised.lzjson', 
        partsDnt: 'partstable_common2014.optimised.lzjson', 
        weaponDnt: 'weapontable_common2014.optimised.lzjson', 
        setDnt: 'setitemtable_cash.optimised.lzjson',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      cash: { 
        mainDnt: 'itemtable_cash.optimised.lzjson', 
        partsDnt: 'partstable_cash.optimised.lzjson', 
        weaponDnt: 'weapontable_cash.optimised.lzjson', 
        setDnt: 'setitemtable_cash.optimised.lzjson',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      event: {
        mainDnt: 'itemtable_event.optimised.lzjson',
        partsDnt: 'partstable_event.optimised.lzjson',
        weaponDnt: 'weapontable_event.optimised.lzjson',
        setDnt: 'setitemtable_cash.optimised.lzjson',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      xtras: {
        mainDnt: 'itemtable_vehicle.optimised.lzjson',
        partsDnt: 'vehiclepartstable.optimised.lzjson',
        setDnt: 'setitemtable_cash.optimised.lzjson',
        type: 'xtras',
        minLevel: 0,
        minRank: 0 },
      imprint: {
        mainDnt: 'itemtable_imprinting.lzjson',
        type: 'imprint',
        minLevel: 0,
        minRank: 0 },
    };
    
    // now that the sources are set up add some methods on them for initialisation
    // each source will store the items from that source for reuse by searches
    angular.forEach(itemSources, function(itemSource, key) {
      itemSource.name = key;
      itemSource.loading = false;
      itemSource.items = null;
      itemSource.init = init; // decalared below
      itemSource.reset = function() {
        itemSource.items = null;
        itemSource.loading = false;
      };
    });

    return itemSources;
  
  
    function init(progress, complete) {
      var itemSource = this;
      itemSource.loading = true;
  
      if(itemSource.items) {
        complete();
      }
      else {
        
        translations.init(progress, function() { doComplete(itemSource, complete) });
        dntData.init(itemSource.mainDnt, itemColumnsToLoad.mainDnt, progress, function() { doComplete(itemSource, complete) });
        if('potentialDnt' in itemSource) {
          dntData.init(itemSource.potentialDnt, itemColumnsToLoad.potentialDnt, progress, function() { doComplete(itemSource, complete) });
        }
        if('potentialDntEx' in itemSource) {
          dntData.init(itemSource.potentialDntEx, itemColumnsToLoad.potentialDnt, progress, function() { doComplete(itemSource, complete) });
        }
        if('gemDnt' in itemSource) {
          dntData.init(itemSource.gemDnt, itemColumnsToLoad.gemDnt, progress, function() { doComplete(itemSource, complete) });
        }
  
        doComplete(itemSource, complete);
      }
    }
    
    function doComplete(itemSource, complete) {
      if(translations.isLoaded() && 
      dntData.isLoaded(itemSource.mainDnt) && 
      (!('potentialDnt' in itemSource) || dntData.isLoaded(itemSource.potentialDnt)) &&
      (!('potentialDntEx' in itemSource) || dntData.isLoaded(itemSource.potentialDntEx)) &&
      (!('gemDnt' in itemSource) || dntData.isLoaded(itemSource.gemDnt))
      ) {
        complete();
        itemSource.loading = false;
      }
    }
  };
})();
(function () {
'use strict';

angular.module('dnsim').factory('jobs', ['dntData', 'translations', 'itemColumnsToLoad', jobs]);
function jobs(dntData, translations, itemColumnsToLoad) {
  
  var fileName ='jobtable.lzjson';
  var colsToLoad = itemColumnsToLoad.jobsDnt;
  
  return {
    fileName : fileName,
    allJobs : null,
    
    isLoaded : function() {
      return dntData.isLoaded(fileName);
    },
    
    hasStartedLoading: function() {
      return dntData.hasStartedLoading(fileName);
    },
    
    init : function(progress, complete) {
      dntData.init(fileName, colsToLoad, progress, function() {
        complete();
        });
    },

    reset : function() {
      this.allJobs = null;
      dntData.reset(fileName);
    },
    
    getFinalJobs : function () {
      var jobs = [];
      var alljobs = this.getAllJobs();
      if(alljobs) {
        var numRows = alljobs.length;
        for(var r=0;r<numRows;++r) {
          if(alljobs[r].d.JobNumber == 2 && alljobs[r].d.JobIcon > 0) {
            jobs.push(alljobs[r]);
          }
        }
      }
      
      return jobs;
    },
    
    getBaseJobs : function () {
      var retVal=[];
      var baseJobs = {};

      var self = this;
      angular.forEach(this.getFinalJobs(), function(job, key) {
        baseJobs[self.getBaseJobName(job)] = job;
      });

      angular.forEach(baseJobs, function(job, jobName) {
        retVal.push(jobName);
      });

      return retVal;
    },
    
    getAllJobs : function () {
      if(this.allJobs == null && this.isLoaded() && translations.isLoaded()) {
        var jobs = [];
        var data = dntData.getData(fileName);
        var numRows = data.length;
        for(var r=0;r<numRows;++r) {
          jobs[jobs.length] = this.createJob(data[r]);
        }
        
        this.allJobs = jobs;
      }
      return this.allJobs;
    },
    
    getById: function(id) {
      var data = this.getAllJobs();
      if(data) {
        var numRows = data.length;
        for(var r=0;r<numRows;++r) {
          if(data[r].id == id) {
            return data[r];
          }
        }
      }
    },
    
    createJob : function(d) {
      var t = this;
      return {
          d : d,
          id : d.id,
          name : translations.translate(d.JobName),
          isClassJob : function(c) {
            return t.isClassJob(d, c);
          }
        };
    },
    
    isClassJob : function (d, c) {
      if(c == 0) return true;
      if(d.id == c) {
        return true;
      }
      
      var parentJob = d.ParentJob;
      
      if(!parentJob) return false;
      if(parentJob == c) return true;

      var parentJobData = this.getById(parentJob);
      if(parentJobData) {
        return this.isClassJob(parentJobData.d, c);
      }
      
      return false;
    },
    
    getBaseJobName : function(job) {
      if(this.isLoaded()) {
        var alljobs = this.getAllJobs();
        if(alljobs) {
          var numRows = alljobs.length;
          for(var r=0;r<numRows;++r) {
            if(alljobs[r].id == (job.d.BaseClass+1) && alljobs[r].d.EnglishName) {
              return alljobs[r].d.EnglishName;
            }
          }
        }
      }
      
      return null;
    },
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('onlineService', ['$window','$q','hCodeValues',onlineService]);

function onlineService($window, $q, hCodeValues) {
  console.log('setup online service');
  
  var service = {
    login: login,
    getUser: function() {
      return firebase.auth().currentUser;
    },
    signOut: signOut,
    deleteAccount: deleteAccount,
    
    getUserBuilds: getUserBuilds,
    deleteBuild: deleteBuild,
    saveBuild: saveBuild,
    getBuild: getBuild,
    getClassBuilds: getClassBuilds,
    
    getProfile: getProfile,
    saveProfile: saveProfile,
    
    stripBuildName: stripBuildName
  };
  
  init();
  
  return service;
  
  function init() {
    console.log('init');
    firebase.initializeApp({
      apiKey: "AIzaSyC-Mckgho1xAI2SQzsKnpsr2ObDKOhdSrE",
      authDomain: "dngearsim.firebaseapp.com",
      databaseURL: "https://dngearsim.firebaseio.com",
      storageBucket: "dngearsim.appspot.com",
    });
  }
  
  function login() {
    return $q(function(resolve, reject) {
      var auth = firebase.auth();
        
      auth.onAuthStateChanged(function(user) {
        if(user == null) {
          console.log('redirecting');
          $window.location.href = 'login.html';
        }
        else {
          console.log('logged in');
          resolve(user);
        }
      });
    });
  }
  
  function getProfile(uid) {
    console.log('get profile');
    return $q(function(resolve, reject) {
      firebase.database().ref('profile/' + uid).once('value', function(storedProfile) {
        if(storedProfile) {
          resolve(storedProfile.val());
        }
        else {
          resolve({});
        }
      });
    });
  }
  
  function getBuild(uid, buildName) {
    console.log('get build');
    return $q(function(resolve, reject) {
      firebase.database().ref('builds/' + uid + '/' + stripBuildName(buildName)).once('value', function(storedProfile) {
        if(storedProfile) {
          resolve(decompressBuild(storedProfile.val()));
        }
        else {
          resolve({});
        }
      });
    });
  }
  
  function saveProfile(profile) {
    return $q(function(resolve, reject) {
      var user = service.getUser();
      if(user) {
        profile = angular.copy(profile);
        deleteNullProperties(profile, true);
        firebase.database().ref('profile/' + user.uid).set(profile).then(resolve);
      }
    });
  }
  
  function getUserBuilds(uid) {
    console.log('get builds');
    return $q(function(resolve, reject) {
      console.log('getting builds');
      firebase.database().ref('builds/' + uid).once('value', function(storedBuilds) {
        if(storedBuilds) {
          var retVal = {};
          var val = storedBuilds.val();
          for(var buildName in val) {
            retVal[buildName] = decompressBuild(val[buildName]);
          }
          resolve(retVal);
        }
        else {
          resolve({});
        }
      });
    });
  }
  
  function getClassBuilds(job) {
    console.log('get class builds');
    return $q(function(resolve, reject) {
      console.log('getting builds', job.id);
      firebase.database().ref('job-builds/' + job.id).once('value', function(jobBuilds) {
        console.log('ok');
        if(jobBuilds) {
          resolve(jobBuilds.val());
        }
        else {
          resolve({});
        }
      });
    });
  }
  
  function compressBuild(build) {
    
    if(build.items) {
      _.each(build.items, function(item) {
        delete item.fullStats;
      });
    }
    
    var stringifiedData = JSON.stringify(build);
    return LZString.compressToUTF16(stringifiedData);
  }
  
  function decompressBuild(compressedBuild) {
    var stringifiedData = LZString.decompressFromUTF16(compressedBuild);
    var build = JSON.parse(stringifiedData);
    
    if(build.items) {
      _.each(build.items, function(item) {
        item.fullStats = item.stats;
        
        if(item.enchantmentStats && item.enchantmentStats.length) {
          item.fullStats = hCodeValues.mergeStats(item.enchantmentStats, item.fullStats);
        }
        
        if(item.sparkStats && item.sparkStats.length) {
          item.fullStats = hCodeValues.mergeStats(item.sparkStats, item.fullStats);
        }
      });
    }
    
    return build;
  }
  
  function saveBuild(buildName, build) {
    var user = service.getUser();
    var actions = [];
    if(user) {
      build = angular.copy(build);
      deleteNullProperties(build, true);
      // console.log('saving', build);
      actions.push(
        firebase.database().ref('builds/' + user.uid + '/' + stripBuildName(buildName)).set(compressBuild(build))
      );
      
      if(build.job && build.job.id) {
        console.log('saving build');
          
        var data = {};
        if(build.playerLevel) {
          data.lev = build.playerLevel;
        }
        if(build.region) {
          data.region = build.region;
        }
        if(build.guild) {
          data.guild = build.guild;
        }
        if(build.about) {
          data.about = build.about;
        }
        
        deleteNullProperties(data, true);
          
        actions.push(
          firebase.database().ref('job-builds/' + build.job.id + '/' + user.uid + '/' + stripBuildName(buildName)).set(data)
        );
      }
    }
    return $q.all(actions);
  }
  
  function deleteNullProperties(test, recurse) {
    for (var i in test) {
        if (test[i] === undefined) {
            delete test[i];
        } else if (recurse && typeof test[i] === 'object') {
            deleteNullProperties(test[i], recurse);
        }
    }
  }
  
  function signOut() {
    var auth = firebase.auth();
    return $q(function(resolve, reject) {
      auth.signOut().then(function() {
        resolve();
      }, function(error) {
        reject();
      });
    });
  }
  
  function deleteAccount(builds) {
    var auth = firebase.auth();
    var user = service.getUser();
    
    return $q(function(resolve, reject) {
      
      var pList = [
        firebase.database().ref('builds/' + user.uid).remove(),
        firebase.database().ref('profile/' + user.uid).remove(),
        firebase.database().ref('private/' + user.uid).remove()];
        
      var jobIds = [];
      for(var buildName in builds) {
        if(builds[buildName].job) {
          jobIds.push(builds[buildName].job.id);
        }
      }
      
      jobIds = _.uniq(jobIds);
      _.each(jobIds, function(id) {
        pList.push(
          firebase.database().ref('job-builds/' + id + '/' + user.uid).remove()
        )
      });
        
      $q.all(pList).then(function() {
        console.log('deleted data');
        user.delete().then(function() {
          console.log('deleted user');
          auth.signOut().then(function() {
            console.log('signed out');
            resolve();
          }, function(error) {
            reject();
          });
        });
      });
    });
  }
  
  function deleteBuild(buildName, build) {
    
    var pList = [];
    var user = service.getUser();
    if(user) {
      pList.push(
        firebase.database().ref('builds/' + user.uid + '/' + stripBuildName(buildName)).remove());
      
      if(build.job) {
        pList.push(
          firebase.database().ref('job-builds/' + build.job.id + '/' + user.uid + '/' + stripBuildName(buildName)).remove());
      }
    }
    
    return $q.all(pList);
  }
  
  function stripBuildName(buildName) {
    return buildName.replace(/[.$\[\]#\/]/g, '');
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('quickAdd', ['dntData', 'translations', 'itemColumnsToLoad', 'itemCategory','itemFactory','jobs','hCodeValues', quickAdd]);
function quickAdd(dntData, translations, itemColumnsToLoad, itemCategory,itemFactory,jobs,hCodeValues) {

  return {
    stepDefs: {
      exchangeStep: {
        name: 'type',
        getOptions: function(category, build, datas) {
          
          var exchanges = [];
          
          for(var e=0;e<category.limitExchange.length;++e) {
            var exId = category.limitExchange[e];
            
            var numExchange = 0;
            if(build.items) {
              for(var i=0;i<build.items.length;++i) {
                if(build.items[i].exchangeType == exId) {
                  numExchange++;
                }
              }
            }
            
            if(numExchange >= category.maxExchange) {
              continue;
            }
            
            var exchange = dntData.find('exchange.lzjson','ExchangeType',exId);
            var exName = '';
            if(exchange && exchange.length > 0 && exchange[0].NameID > 0) {
              exName = translations.translate(exchange[0].NameID).toLowerCase();
            }
            exchanges.push({id: exId, name: exName.toLowerCase()});
          }
          
          return exchanges;
        },
        matchesItem: function(id, item) {
          return item.exchangeType == id;
        }
      },
      accExchangeStep: {
        name: 'type',
        getOptions: function(category, build, datas) {
          
          var exchanges = [];
          
          for(var e=0;e<category.limitExchange.length;++e) {
            var exId = category.limitExchange[e];
            
            var numExchange = 0;
            for(var i=0;i<build.items.length;++i) {
              if(build.items[i] && build.items[i].exchangeType == exId) {
                numExchange++;
              }
            }
            
            if(exId == 10 || exId == 25) {
              if(numExchange >= 2) {
                continue;
              }
            }
            else {
              if(numExchange >= 1) {
                continue;
              }
            }
            
            var exchange = dntData.find('exchange.lzjson','ExchangeType',exId);
            if(exchange && exchange.length > 0 && exchange[0].NameID > 0) {
              var exName = translations.translate(exchange[0].NameID).toLowerCase();
              
              exchanges.push({id: exId, name: exName.toLowerCase()});
            }
          }
          
          return exchanges;
        },
        matchesItem: function(id, item) {
          return item.exchangeType == id;
        }
      },
      sixtyLevelStep: {
        name: 'level',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 93, name: 'level 93' },
          { id: 90, name: 'level 90' },
          { id: 80, name: 'level 80' },
          { id: 70, name: 'level 70' }, 
          { id: 60, name: 'level 60' }, 
          ];
        },
        matchesItem: function(id, item) {
          return item.levelLimit == id;
        }
      },
      allLevelStep: {
        name: 'level',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 93, name: 'level 93' },
          { id: 90, name: 'level 90' },
          { id: 80, name: 'level 80' },
          { id: 70, name: 'level 70' }, 
          { id: 60, name: 'level 60' }, 
          { id: 50, name: 'level 50' }, 
          { id: 40, name: 'level 40' }, 
          { id: 32, name: 'level 32' }, 
          { id: 24, name: 'level 24' }, 
          ];
        },
        matchesItem: function(id, item) {
          return item.levelLimit == id;
        }
      },
      cashRankStep: {
        name: 'rank',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 4, name: 'unique' },
          { id: 3, name: 'epic' },
          { id: 2, name: 'rare' },
          { id: 1, name: 'magic' },
          { id: 0, name: 'normal' },
          ];
        },
        matchesItem: function(id, item) {
          return item.rank.id == id;
        }
      },
      techRankStep: {
        name: 'rank',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 4, name: 'unique' },
          { id: 3, name: 'epic' },
          ];
        },
        matchesItem: function(id, item) {
          return item.rank.id == id;
        }
      },
      talismanRankStep: {
        name: 'rank',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 2, name: 'rare' },
          { id: 999, name: 'quality high grade' },
          { id: 1, name: 'magic' },
          { id: 0, name: 'normal' },
          ];
        },
        matchesItem: function(id, item) {
          itemFactory.initItem(item);
          if(item.name) {
            // todo: change this to use the name id
            var index = Math.max(
              item.name.indexOf('Quality'),
              item.name.indexOf('High Grade'));
              
            if(id == 999) {
              return index === 0;
            }
            else {
              return item.rank.id == id && index != 0;
            }
          }
          return false;
        }
      },
      gemRankStep: {
        name: 'rank',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 5, name: 'legendary' },
          { id: 999, name: 'quality high grade epic' },
          { id: 3, name: 'epic' },
          ];
        },
        matchesItem: function(id, item) {
          itemFactory.initItem(item);
          if(item.name) {
            var index = Math.max(
              item.name.indexOf('Quality'),
              item.name.indexOf('High Grade'));
            if(id == 999) {
              return item.rank.id == 3 && index >= 0;
            }
            else {
              return item.rank.id == id && index < 0;
            }
          }
          return false;
        }
      },
      otherRankStep: {
        name: 'rank',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 3, name: 'epic' },
          { id: 2, name: 'rare' },
          { id: 1, name: 'normal' },
          ];
        },
        matchesItem: function(id, item) {
          return item.rank.id == id;
        }
      },
      equipRankStep: {
        name: 'rank',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 5, name: 'legendary' },
          { id: 4, name: 'unique' },
          { id: 3, name: 'epic' },
          ];
        },
        matchesItem: function(id, item) {
          return item.rank.id == id;
        }
      },
      enhanceTalismanStep: {
        name: 'slot',
        getOptions: function(category, build, datas) {
          
          return [
          { id: 100, name: '+100% slot' },
          { id: 75, name: '+75% slot' },
          { id: 25, name: '+25% slot' },
          { id: 0, name: '+0% slot' },
          ];
        },
        alterItem: function(id, item) {
          item.enchantmentNum = id;
        }
      },
      titleStep: {
        name: 'select',
        getOptions: function(category, build, datas) {
          var allTitles = findData(category, build, datas, 9999);
          var usefulTitles = [];
          for(var i=0;i<allTitles.length;++i) {
            switch(allTitles[i].id) {
              case 1975: // Manticore Expert
              case 1973: // Returned
              case 1008: // Dark Knight
              // case 339: // Cow Wrangler
              case 230: // Miraculous
              case 279: // Provoking
              // case 1280: // Dragon Tamer
              case 1313: // Jakard's Demise
              case 2032: // Sharing Goddess's Grief
              case 2033: // Grief-stricken
                usefulTitles.push(allTitles[i]);
            }
          }
          
          return usefulTitles;
        },
        hasOptions: function(category, build, datas) {
          return true;
        },
        isItemStep: true,
      },
      enhanceStep: {
        name: 'enhance',
        getOptions: function(category, build, datas) {
          
          var item = getItem(datas);
          if(item && item.enchantmentId) {
            return [
            { id: 15, name: 'enhance to +15' },
            { id: 14, name: 'enhance to +14' },
            { id: 13, name: 'enhance to +13' },
            { id: 12, name: 'enhance to +12' },
            { id: 11, name: 'enhance to +11' },
            { id: 10, name: 'enhance to +10' },
            { id: 9, name: 'enhance to +9' },
            { id: 8, name: 'enhance to +8' },
            { id: 7, name: 'enhance to +7' },
            { id: 6, name: 'enhance to +6' },
            { id: 5, name: 'enhance to +5' },
            { id: 4, name: 'enhance to +4' },
            { id: 3, name: 'enhance to +3' },
            { id: 2, name: 'enhance to +2' },
            { id: 1, name: 'enhance to +1' },
            { id: 0, name: 'not enhanced' },
            ];
          }
          else {
            return [{ id: 0, name: 'not enhanced' }];
          }
        },
        alterItem: function(id, item) {
          item.enchantmentNum = id;
        }
      },
      itemStep: {
        name: 'select',
        getOptions: function(category, build, datas) {
          return findData(category, build, datas);
        },
        isItemStep: true,
      },
      techSkillStep: {
        name: 'skill',
        getOptions: function(category, build, datas) {
          var items = findData(category, build, datas, 1);
          
          // eventually show all the skills
          // but for now
          if(items.length > 0) {
            return [{id: items[0].skillId, name: items[0].skillId}];
          }
          else {
            return [];
          }
        },
        matchesItem: function(id, item) {
          return item.skillId == id;
        }
      },
      itemNameStep: {
        name: 'item',
        getOptions: function(category, build, datas) {
          var items = findData(category, build, datas);
          var itemNames = {};
          var itemNamesList = [];
          for(var i=0;i<items.length;++i) {
            var name = items[i].name;
            if(!(name in itemNames)) {
              itemNames[name] = true;
              itemNamesList.push({
                id: name,
                name: name,
              });
            }
          }
          
          return itemNamesList;
        },
        matchesItem: function(id, item) {
          return item.name == id;
        },
        isItemStep: true,
      },
      distinctItemNameStep: {
        name: 'item',
        getOptions: function(category, build, datas) {
          var items = findData(category, build, datas);
          var itemNames = {};
          var itemNamesList = [];
          
          for(var i=0;i<build.items.length;++i) {
            var item = build.items[i];
            itemNames[item.name] = true;
          }
          
          for(var i=0;i<items.length;++i) {
            var name = items[i].name;
            if(!(name in itemNames)) {
              itemNames[name] = true;
              itemNamesList.push({
                id: name,
                name: name,
              });
            }
          }
          
          return itemNamesList;
        },
        matchesItem: function(id, item) {
          return item.name == id;
        },
        isItemStep: true,
      },
      numStatsStep: {
        name: 'Num Stats',
        getOptions: function(category, build, datas) {
          var items = findData(category, build, datas);
          var numStats = {};
          
          for(var i=0;i<items.length;++i) {
            var len = 0;
            for(var j=0;j<items[i].stats.length;++j) {
              var stat = hCodeValues.stats[items[i].stats[j].id];
              if(stat && !stat.hide) {
                len++;
              }
            }
            numStats[len + 'x stats'] = len;
          }
          
          var retVal = [];
          for(var val in numStats) {
            retVal.push({
              id: numStats[val],
              name: val,
            });
          }
          
          retVal = retVal.sort(function(a, b) {
              return a.id - b.id;
            });
          
          return retVal;
        },
        matchesItem: function(id, item) {
          var len = 0;
          for(var j=0;j<item.stats.length;++j) {
            var stat = hCodeValues.stats[item.stats[j].id];
            if(stat && !stat.hide) {
              len++;
            }
          }
            
          return len == id;
        },
        isItemStep: true,
      },
      customStep: {
        name: 'misc',
        getOptions: function(category, build, datas) {
          return hCodeValues.customItems;
        },
        isItemStep: true,
      },
    },
    // end of step defs
    
    categorySteps: {
      titles: ['titleStep'],
      weapons: ['exchangeStep','sixtyLevelStep','equipRankStep','itemStep','enhanceStep'],
      armour: ['exchangeStep','sixtyLevelStep','equipRankStep','itemStep','enhanceStep'],
      accessories: ['accExchangeStep','allLevelStep','equipRankStep','itemNameStep','itemStep'],
      'offensive gems': ['sixtyLevelStep','gemRankStep','itemNameStep','numStatsStep','itemStep','enhanceStep'],
      'increasing gems': ['sixtyLevelStep','gemRankStep','itemNameStep','numStatsStep','itemStep','enhanceStep'],
      'enhancement plates': ['allLevelStep','otherRankStep','distinctItemNameStep','numStatsStep','itemStep'],
      'expedition plates': ['sixtyLevelStep','distinctItemNameStep','numStatsStep','itemStep'],
      talisman: ['sixtyLevelStep','talismanRankStep','distinctItemNameStep','numStatsStep','itemStep','enhanceTalismanStep'],
      costume: ['exchangeStep','otherRankStep','itemNameStep','itemStep'],
      cash: ['accExchangeStep','cashRankStep','itemNameStep','itemStep'],
      techs: ['exchangeStep','allLevelStep','techRankStep','techSkillStep','itemStep'],
      custom: ['customStep'],
    },
    getOptions: function(category, build, datas) {
      if(category.name in this.categorySteps) {
        var stepName = this.getStepName(category, datas.length);
        return this.stepDefs[stepName].getOptions(category, build, datas);
      }
      else {
        return [];
      }
    },
    hasOptions: function(category, build, datas) {
      if(category.name in this.categorySteps) {
        var stepName = this.getStepName(category, datas.length);
        if(this.stepDefs[stepName].hasOptions) {
          return this.stepDefs[stepName].hasOptions(category, build, datas);
        }
        else {
          return this.stepDefs[stepName].getOptions(category, build, datas).length > 0;
        }
      }
      else {
        return false;
      }
    },
    isValidStepNumber: function(category, stepNumber) {
      return this.categorySteps[category.name].length > stepNumber;
    },
    createData: function(value, category, stepNumber) {
      var stepName = this.getStepName(category, stepNumber);
      var def = this.stepDefs[stepName];
      
      return {
        step: stepName,
        value: value,
        def: def,
        matchesItem: function(item) {
          return def.matchesItem(value.id, item);
        }
      };
    },
    getItem: getItem,
    getStepName: function(category, stepNumber) {
      return this.categorySteps[category.name][stepNumber];
    }
  };
  
  function getItem(datas) {
    var item = null;
    for(var d=0;d<datas.length;++d) {
      if(datas[d].def.isItemStep) {
        item = datas[d].value;
      }
    }
    
    for(var d=0;d<datas.length;++d) {
      if(datas[d].def.alterItem) {
        datas[d].def.alterItem(datas[d].value.id, item);
      }
    }
    
    return item;
  }
  
  function findData(category, build, datas, maxItems) {
    if(!maxItems) {
      maxItems = 9999;
    }
    
    var allItems = itemCategory.getItems(category.name);
    var retVal = [];
    // console.log('looking at ' + allItems.length + ' items');
    var numItems = allItems.length;
    
    for(var i=0;i<numItems;++i) {
      
      var item = allItems[i];
      
      if(build.job.id > 0 && item.needJobClass > 0 && !jobs.isClassJob(build.job.d, item.needJobClass)) {
        continue;
      }
      itemFactory.initItem(item);
      
      var addItem = true;
      for(var d=0;d<datas.length;++d) {
        if(datas[d].matchesItem && !datas[d].matchesItem(item)) {
          addItem = false;
          break;
        }
      }
      
      if(addItem) {
        retVal.push(item);
      }
      
      if(retVal.length >= maxItems) {
        break;
      }
    }
    
    retVal = retVal.sort(function(item1, item2) {
      return item1.name.localeCompare(item2.name);
    });
    
    // console.log('found ' + retVal.length + ' items');
    return retVal;
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('region', ['translations','dntReset','dntData','$route',region]);
function region(translations,dntReset,dntData,$route) {
  
  var alternativeFiles = {region: 'ALT', name: 'Alternative user specified files', url : ''};
  var hostedFiles =[
      {region: 'sea', name: 'south east asia', url : 'https://seadnfiles.firebaseapp.com'},
      {region: 'na', name: 'north america', url : 'https://dnna.firebaseapp.com'},
      {region: 'eu', name: 'europe', url : 'https://eufiles.firebaseapp.com'},
      {region: 'ina', name: 'indonesia ', url : 'https://inafiles-da491.firebaseapp.com'},
      {region: 'th', name: 'thailand', url : 'https://thdnfiles.firebaseapp.com'},
      {region: 'tw', name: 'taiwan 臺灣', url : 'https://twdnfiles.firebaseapp.com'},
      // {region: 'jdn', name: 'japan 日本', url : 'https://jdnfiles.firebaseapp.com'},
      {region: 'cdn', name: 'china 中國', url : 'https://cdnfiles.firebaseapp.com'},
      {region: 'kdn', name: 'korea 대한민국', url : 'https://kdnfiles.firebaseapp.com'},
    ];
  
  var dntLocationRegion = localStorage.getItem('lastDNTRegion');
  var dntLocation = null;
  if(dntLocationRegion) {
    angular.forEach(hostedFiles, function(hostedFile, index) {
      if(hostedFile.region == dntLocationRegion) {
        dntLocation = hostedFile;
      }
    });
  }

  var lastTFile = localStorage.getItem('UIStrings_file');
  var tlocation = null;
  if(lastTFile) {
    angular.forEach(hostedFiles, function(hostedFile, index) {
      if(hostedFile.region != alternativeFiles.region && lastTFile.indexOf(hostedFile.url) > -1) {
        tlocation = hostedFile;
        return;
      }
    });
  }
  
  if(tlocation == null) {
    tlocation = dntLocation;
  }

  return {
    hostedFiles : hostedFiles,
    alternativeFiles : alternativeFiles,
    dntLocation : dntLocation,
    tlocation : tlocation,
    
    setCustomUrl: function(url) {
      // console.log('setting custom location');
      this.alternativeFiles.url = url;

      var newFiles = [];
      angular.forEach(hostedFiles, function(hostedFile, index) {
        if(hostedFile.region != alternativeFiles.region) {
          newFiles.push(hostedFile);
        }
      });
  
      newFiles.push(alternativeFiles);
      hostedFiles = newFiles;
      this.hostedFiles = newFiles;
    },
    
    setLocationByName: function(locationName) {
      var newLocation = null;
      
      angular.forEach(hostedFiles, function(hostedFile, index) {
        if(hostedFile.region == locationName) {
          newLocation = hostedFile;
        }
      });
        
      this.setLocation(newLocation);
    },
    
    setLocation: function(location) {
      if(location && location != this.dntLocation) {
        this.dntLocation = location;
        dntReset();
        localStorage.setItem('lastDNTRegion', location.region);
        dntReset();
        $route.reload();
      }

      if(this.tlocation == null) {
        this.setTLocation(location);
      }
      
      this.init();
      
      // $route.reload();
    },
    
    setTLocation: function(location) {
      
      if(location != this.tlocation) {
        
        this.tlocation = location;
        sessionStorage.removeItem('UIStrings');
        localStorage.removeItem('UIStrings_file');
        dntReset();
        translations.reset();
        if(location) {
          var override = this.getOverride();
          translations.small = !override;
          translations.location = this.tlocation.url;
          translations.init(function() {}, function() { $route.reload(); });
        }
      }
    },
    
    getOverride: function() {
      if(localStorage.getItem('tOverride')) {
        return true;
      }
      else {
        return false;
      }
    },
    
    setOverride: function(value) {
      if(!value) {
        localStorage.removeItem('tOverride');
      }
      else {
        localStorage.setItem('tOverride', '1');
      }
      this.setTLocation(this.dntLocation);
    },
    
    init: function() {
      if(this.getOverride()) {
        translations.small = false;
      }
      else {
        this.tLocation = this.dntLocation;
        translations.small = true;
      }
      
      if(this.tlocation) {
        translations.location = this.tlocation.url;
      }
      dntData.setLocation(this.dntLocation);
    }
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('saveHelper', ['itemCategory',saveHelper]);
function saveHelper(itemCategory) {
  return {
    saveItem: function(groupName, item) {
      var groups = this.getSavedItems();
      if(groupName in groups && Array.isArray(groups[groupName].items)) {
        
        groups[groupName].items.push(item);
        groups[groupName].lastUpdate = (new Date()).getTime();
        this.updatedSavedItems(groupName, groups[groupName].items);
      }
      else {
        this.updatedSavedItems(groupName, [item]);
      }
      
      localStorage.setItem('lastSavedGroup', groupName);
    },
    
    saveBuildSelection : function(buildName, builds) {
      this.setCurrentBuild(buildName);
      if(builds && buildName in builds && builds[buildName].job && builds[buildName].job.id) {
        localStorage.setItem('jobNumber', builds[buildName].job.id);
      }
    },
    
    importGroup: function(groupName, updatedItems) {
      var items = this.getSavedItems();
      groupName = this.getUniqueGroupName(groupName, items);
      this.updatedSavedItems(groupName, updatedItems);
      return groupName;
    },
    
    getUniqueGroupName: function(groupName, existingGroups) {
      var groupNameIndex = 0;
      if(groupName.lastIndexOf(')') == groupName.length-1) {
        var startIndex = groupName.lastIndexOf('(');
        if(startIndex > 0) {
          var foundIndex = Number(groupName.substr(startIndex+1, groupName.length-startIndex-2));
          if(foundIndex > 0) {
            groupNameIndex = foundIndex + 1;
            groupName = groupName.substr(0, startIndex - 1);
          }
        }
      }
      
      var originalName = groupName;
      for(;;) {
        var groupName = originalName;
        if(groupNameIndex > 0) {
          groupName = originalName + ' (' + groupNameIndex + ')';
        }
        
        if(groupName in existingGroups) {
          groupNameIndex++;
        }
        else {
          break;
        }
      }
      
      return groupName;
    },
    
    updatedSavedItems: function(groupName, updatedItems) {
      var items = this.getSavedItems();
      if(groupName in items) {
        if(!updatedItems.length) {
          delete items[groupName];
          this.setCurrentBuild(null);
          // console.log('no items to update');
        }
        else {
          items[groupName].items = updatedItems;
          items[groupName].lastUpdate = (new Date()).getTime();
          localStorage.setItem('lastSavedGroup', groupName);
          // console.log('set group');
        }
      }
      else {
        items[groupName] = {items : updatedItems, lastUpdate: (new Date()).getTime()};
        localStorage.setItem('lastSavedGroup', groupName);
          // console.log('created group');
      }
      
      var stringifiedData = JSON.stringify(items);
      // console.log('saving: ' + stringifiedData);
      localStorage.setItem('savedItems', LZString.compressToUTF16(stringifiedData));
    },
    
    renameSavedGroup: function(
      oldGroupName, newGroupName, enemyLevel, playerLevel, heroLevel, job, damageType, element, secondaryElement,
      enemyStatCaps, playerStatCaps, conversions, baseStats, heroStats) {
        
      var savedItems = this.getSavedItems();
      
      if(newGroupName in savedItems || oldGroupName == newGroupName) {
        // console.log('not changing name');
        newGroupName = oldGroupName;
      }
      else if(oldGroupName in savedItems) {
        var group = savedItems[oldGroupName];
        savedItems[newGroupName] = group;
        delete savedItems[oldGroupName];
      }
      
      savedItems[newGroupName].enemyLevel = enemyLevel;
      savedItems[newGroupName].playerLevel = playerLevel;
      savedItems[newGroupName].heroLevel = heroLevel;
      savedItems[newGroupName].job = job;
      savedItems[newGroupName].damageType = damageType;
      savedItems[newGroupName].element = element;
      savedItems[newGroupName].secondaryElement = secondaryElement;
      savedItems[newGroupName].enemyStatCaps = enemyStatCaps;
      savedItems[newGroupName].playerStatCaps = playerStatCaps;
      savedItems[newGroupName].conversions = conversions;
      savedItems[newGroupName].baseStats = baseStats;
      savedItems[newGroupName].heroStats = heroStats;
      
      var stringifiedData = JSON.stringify(savedItems);
      localStorage.setItem('savedItems', LZString.compressToUTF16(stringifiedData));
    },
    
    getSavedItems: function() {
      try {
        var stringifiedData = LZString.decompressFromUTF16(localStorage.getItem('savedItems'));
        var savedItems = JSON.parse(stringifiedData);
        return savedItems;
      }
      catch(ex) {
      }
      
      return {};
    },
    
    getCustomItems: function() {
      try {
        var stringifiedData = LZString.decompressFromUTF16(localStorage.getItem('customItems'));
        var savedItems = JSON.parse(stringifiedData);
        return savedItems;
      }
      catch(ex) {
      }
      
      return [];
    },
    
    saveCustomItems: function(items) {
      var stringifiedData = JSON.stringify(items);
      // console.log('saving: ' + stringifiedData);
      localStorage.setItem('customItems', LZString.compressToUTF16(stringifiedData));
    },
    
    getHiddenTypes: function() {
      try {
        var stringifiedData = LZString.decompressFromUTF16(localStorage.getItem('hiddenTypes'));
        var savedItems = JSON.parse(stringifiedData);
        return savedItems;
      }
      catch(ex) {
      }
      
      return {};
    },
    
    saveHiddenTypes: function(items) {
      var stringifiedData = JSON.stringify(items);
      // console.log('saving: ' + stringifiedData);
      localStorage.setItem('hiddenTypes', LZString.compressToUTF16(stringifiedData));
    },
    
    currentBuild: null,
    getCurrentBuild: function() {
      if(!this.currentBuild) {
        this.currentBuild = localStorage.getItem('currentGroup');
        if(this.currentBuild) {
          var savedItems = this.getSavedItems();
          if(!(this.currentBuild in savedItems)) {
            localStorage.removeItem('currentGroup');
            this.currentBuild = null;
          }
        }
      }
      
      return this.currentBuild;
    },
    
    setCurrentBuild: function(buildName) {
      this.currentBuild = buildName;
      localStorage.setItem('currentGroup', buildName);
    }
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('statHelper', ['hCodeValues',statHelper]);
function statHelper(hCodeValues) {

  return {
    
    getSetStats: function(groupItems) {
      var stats = [];
      var sets = {};
      
      angular.forEach(groupItems, function(value, key) {
        if(value !== null && value.setStats != null) {
          if(value.setId in sets) {
            sets[value.setId].numItems++;
          }
          else {
            sets[value.setId] = { numItems : 1, stats : value.setStats };
          }
        }
      });
      
      angular.forEach(sets, function(value, key) {
        angular.forEach(value.stats, function(stat, index) {
          if(stat.needSetNum <= value.numItems) {
            stats.push(stat);
          }
        });
      });
      
      return hCodeValues.mergeStats(stats);
    },
    
    getCombinedStats: function(groupItems) {
      var stats = [];
      
      angular.forEach(groupItems, function(value, key) {
        if(value) {
          
          if(value.fullStats) {
            stats = stats.concat(value.fullStats);
          }
          else if(value.stats) {
            stats = stats.concat(value.stats);
          }
        }
      });
      
      return hCodeValues.mergeStats(stats);
    },
    
    getCalculatedStatsFromItems: function(group, items) {
      var nakedStats = this.getNakedStats(group);
      var combinedStats = this.getCombinedStats(items);
      var setStats = this.getSetStats(items);
      var allStats = nakedStats.concat(combinedStats).concat(setStats);
      if(group.heroStats != null && group.heroStats.length > 0) {
        allStats = allStats.concat(group.heroStats);
      }
      allStats = hCodeValues.mergeStats(allStats);
      
      return this.getCalculatedStats(group, allStats);
    },
    
    getCalculatedStats: function(group, combinedStats) {
      
      var retVal = [];
      var statLookup = {};
      if(!group.conversions || !group.enemyStatCaps || !group.playerStatCaps) {
        return [];
      }
      
      angular.forEach(combinedStats, function(stat, index) {
        statLookup[stat.id] = stat;
      });
      
      function getPc(stat) {
        var statDef = hCodeValues.stats[stat.id];
        if(statLookup[statDef.pc]) {
          return Number(statLookup[statDef.pc].max);
        }
        else {
          return 0;
        }
      }
      
      function getSkillPc(stat) {
        var statDef = hCodeValues.stats[stat.id];
        if(statLookup[statDef.skPc]) {
          return Number(statLookup[statDef.skPc].max);
        }
        else {
          return 0;
        }
      }
      
      function applyPc(stat) {
        stat.max = Math.floor(
          stat.max * (1+getPc(stat)) * (1+getSkillPc(stat))
          );
      }
      
      function dupeStat(id) {
        var stat = statLookup[id];
        if(stat) {
          return {id: id, max: Number(stat.max), pc: stat.pc};
        }
        else {
          return {id: id, max: 0, pc: 0};
        }
      }
      
      function addStat(stat) {
        if(stat.max > 0) {
          retVal.push(stat);
        }
      }
      
      // base stats
      var str = dupeStat(0);
      applyPc(str);
      addStat(str);
      
      var agi = dupeStat(1);
      applyPc(agi);
      addStat(agi);
      
      var int = dupeStat(2);
      applyPc(int);
      addStat(int);

      var vit = dupeStat(3);
      applyPc(vit);
      addStat(vit);

      // add vit to hp
      var hp = dupeStat(25);
      hp.max += (vit.max * Number(group.conversions.HP));
      applyPc(hp);
      addStat(hp);
      
      // defs
      var def = dupeStat(8);
      def.max += (vit.max * Number(group.conversions.PhysicalDefense));
      applyPc(def);
      addStat(def);
      
      var defpc = dupeStat(1008);
      // defpc.max = Math.max(0.85, Number(def.max)/Number(group.enemyStatCaps.Cdefense));
      defpc.max = Math.min(0.85,def.max/Number(group.enemyStatCaps.Cdefense));
      addStat(defpc);
      
      var mdef = dupeStat(9);
      mdef.max += (int.max * Number(group.conversions.MagicDefense));
      applyPc(mdef);
      addStat(mdef);
      
      var mdefpc = dupeStat(1009);
      // mdefpc.max = Math.max(0.85, Number(mdef.max)/Number(group.enemyStatCaps.Cdefense));
      mdefpc.max = Math.min(0.85,mdef.max/Number(group.enemyStatCaps.Cdefense));
      addStat(mdefpc);
      
      // attack power - like fd but for bufs
      // this shows as blue damage
      // i think there are magic and phis variants of this but doesnt matter
      var aPwr = dupeStat(3000);
      
      var minPdmg = dupeStat(4);
      var maxPdmg = dupeStat(5);

      // physical damage
      if(!group.damageType || group.damageType.id != 2) {
        var extraPdmg = dupeStat(32);
        var extraPdmgMod= dupeStat(101);
        var paPwr = dupeStat(3001);
        
        // special stats for zeal
        var intToPdmg = dupeStat(10164);
        
        minPdmg.max += extraPdmg.max;
        minPdmg.max += Math.floor(str.max*Number(group.conversions.StrengthAttack));
        minPdmg.max += Math.floor(agi.max*Number(group.conversions.AgilityAttack));
        
        minPdmg.max = Math.floor(minPdmg.max*(1+(getPc(minPdmg) + extraPdmgMod.max)));
        minPdmg.max = Math.floor(minPdmg.max * (1+aPwr.max+paPwr.max));
        minPdmg.max += Math.floor(intToPdmg.max * int.max);
        addStat(minPdmg);
  
        maxPdmg.max += extraPdmg.max;
        maxPdmg.max += Math.floor(str.max*Number(group.conversions.StrengthAttack));
        maxPdmg.max += Math.floor(agi.max*Number(group.conversions.AgilityAttack));
        
        maxPdmg.max = Math.floor(maxPdmg.max*(1+(getPc(maxPdmg) + extraPdmgMod.max)));
        maxPdmg.max = Math.floor(maxPdmg.max * (1+aPwr.max+paPwr.max));
        maxPdmg.max += Math.floor(intToPdmg.max * int.max);
        addStat(maxPdmg);
      }
      
      var minMdmg = dupeStat(6);
      var maxMdmg = dupeStat(7);
      
      // magic damage
      if(!group.damageType || group.damageType.id != 1) {
        var extraMdmg = dupeStat(33);
        var extraMdmgMod = dupeStat(102);
        var maPwr = dupeStat(3002);
        
        // special stats for zeal
        var strToMdmg = dupeStat(10165);
        
        minMdmg.max += extraMdmg.max;
        minMdmg.max += Math.floor(int.max*Number(group.conversions.IntelligenceAttack));

        minMdmg.max = Math.floor(minMdmg.max*(1+(getPc(minMdmg) + extraMdmgMod.max)));
        minMdmg.max = minMdmg.max * (1+aPwr.max+maPwr.max);
        minMdmg.max += Math.floor(strToMdmg.max * str.max);
        addStat(minMdmg);
        
        maxMdmg.max += extraMdmg.max;
        maxMdmg.max += (int.max*Number(group.conversions.IntelligenceAttack));
        
        maxMdmg.max = Math.floor(maxMdmg.max*(1+(getPc(maxMdmg) + extraMdmgMod.max)));
        maxMdmg.max = maxMdmg.max * (1+aPwr.max+maPwr.max);
        maxMdmg.max += Math.floor(strToMdmg.max * str.max);
        addStat(maxMdmg);
      }
      
      
      // crit chance %
      var crit = dupeStat(12);
      crit.max += (agi.max*Number(group.conversions.Critical));
      applyPc(crit);
      
      var skCrit = dupeStat(4012);
      crit.max += skCrit.max;
      addStat(crit);
      var itemCrit = dupeStat(1012);
      
      var critChance = Math.min(0.89, (crit.max / Number(group.enemyStatCaps.Ccritical)) + itemCrit.max);
      retVal.push({id: 1012, max: critChance});

      // crit damage %
      var cDmg = dupeStat(103);
      cDmg.max += ((str.max+int.max) * Number(group.conversions.StrengthIntelligenceToCriticalDamage));
      applyPc(cDmg);
      addStat(cDmg);

      var critDamagePc = cDmg.max / group.playerStatCaps.CcriticalDamage;
      addStat({id: 1103, max: critDamagePc + 2});

      // fd
      var fd = dupeStat(29);
      addStat(fd);
      var maxFd = Number(group.enemyStatCaps.Cfinaldamage);
      
      var fdPc = dupeStat(1029);
      fdPc.max += Math.min(Math.max(0.35*Number(fd.max)/maxFd,Math.pow(Number(fd.max)/maxFd,2.2)),1);
      addStat(fdPc);
      
      // elements
      var firePc = dupeStat(16);
      addStat(firePc);
      
      var icePc = dupeStat(17);
      addStat(icePc);
      
      var lightPc = dupeStat(18);
      addStat(lightPc);
      
      var darkPc = dupeStat(19);
      addStat(darkPc);
      
      // average damage
      function addAvgDamageStat(id, min, max) {
        
        var nonEleDamage = (min+max)/2;
        // add crit (assume 25% crit resist - ie. x0.75)
        nonEleDamage += (critChance * (critDamagePc+1) * nonEleDamage * 0.75);
        // apply fd
        nonEleDamage = nonEleDamage * (1 + fdPc.max);
        
        // apply element(s)
        // assume no elemental resist (since probably have resist reduction anyways)
        var avgDmg = nonEleDamage;
        if(group.element && group.element.id > 0) {
          var elementStat = statLookup[hCodeValues.elements[group.element.id].dmgStat];
          if(elementStat) {
            avgDmg = avgDmg * (1+Number(elementStat.max));
          }
        }
        addStat({id: id, max: avgDmg});
        var secElementId = 0;
        var priElementId = 0;
        if(group.element) {
          priElementId = group.element.id;
        }
        else {
          priElementId = 0;
        }
        if(group.secondaryElement) {
          secElementId = group.secondaryElement.id;
        }
        else {
          secElementId = 0;
        }
        
        if(secElementId != priElementId) {
          if(secElementId > 0) {
            var secondaryElementStat = statLookup[hCodeValues.elements[group.secondaryElement.id].dmgStat];
            if(secondaryElementStat) {
              var secAvgDmg = nonEleDamage * (1+Number(secondaryElementStat.max));
              addStat({id: id + 1000, max: secAvgDmg});
            }
          }
          else {
            addStat({id: id + 1000, max: nonEleDamage});
          }
        }
      }
      
      // average damages
      if(!group.damageType || group.damageType.id == 1 || group.damageType.id == 0) {
        addAvgDamageStat(1004, minPdmg.max, maxPdmg.max);
      }

      if(!group.damageType || group.damageType.id == 2 || group.damageType.id == 0) {
        addAvgDamageStat(1006, minMdmg.max, maxMdmg.max);
      }
      
      if(!group.damageType || group.damageType.id == 3) {
        addAvgDamageStat(1001, minMdmg.max+minPdmg.max, maxMdmg.max+maxPdmg.max);
      }
      
      // Equivalent HP
      var pdefEqHp = dupeStat(2008);
      pdefEqHp.max = hp.max / (1-defpc.max);
      
      var mdefEqHp = dupeStat(2009);
      mdefEqHp.max = hp.max / (1-mdefpc.max);
      
      var eqHp = dupeStat(3008);
      eqHp.max = (pdefEqHp.max + mdefEqHp.max) / 2;
      addStat(eqHp);
      
      return retVal;
    },
    
    getNakedStats: function(group) {
      
      if(
        group.baseStats && 
        group.baseStats.Strength > 0) {

        return [
          {id:0, max:group.baseStats.Strength},
          {id:1, max:group.baseStats.Agility},
          {id:2, max:group.baseStats.Intelligence},
          {id:3, max:group.baseStats.Stamina}
          ];
      }
      else {
        return [];
      }
    },
    
    getSkillStats : function (item, data, skillData) {

      var skillLevelVals = null;
      angular.forEach(skillData, function(value, index) {
        if(value.SkillIndex == item.id && value.SkillLevel == item.enchantmentNum) {
          skillLevelVals = value;
          return;
        }
      });
      
      if(!skillLevelVals) {
        return null;
      }
      
      var index = 1;
      var effects = [];
      var stillCols = true;
      
      while(stillCols) {
        var colName = 'EffectClass' + index;
        var valColName = 'EffectClassValue' + index;
        if(data && colName in data && valColName in skillLevelVals) {
          if(data[colName] > 0) {
            
            var val = skillLevelVals[valColName];
            
            // for now add 10k
            var effectId = data[colName];
            var map = hCodeValues.skillEffectMapping[effectId];
            if(map && map.getVals) {
              var vals = map.getVals(val);
              for(var i=0;i<vals.length;++i) {
                effects.push(vals[i]);
              }
            }
            else {
              var statId;
              if(map && map.mapTo) {
                statId = map.mapTo;
              }
              else {
                statId = 10000 + effectId;
              }
              
              if(val > 0) {
                effects.push({ id: statId, effect: effectId, max: val });
              }
              else {
                if(val.toString().indexOf(';') > 0) {
                  var vals = val.split(';');
                  if(vals.length > 0 && vals[0] > 0) {
                    effects.push({ id: statId, effect: effectId, max: vals[0] });
                  }
                }
              }
            }
          }
        }
        else {
          stillCols = false;
        }
        
        index++;
      }
      
      return effects;
    },

    getBuildStats: function(build) {
      var stats = {};
      stats.nakedStats = this.getNakedStats(build);
      stats.combinedStats = this.getCombinedStats(build.items);
      stats.setStats = this.getSetStats(build.items);
      stats.allStats = stats.nakedStats.concat(stats.combinedStats).concat(stats.setStats);
      if(build.heroStats && build.heroStats.length) {
        stats.heroStats = build.heroStats;
        stats.allStats = stats.allStats.concat(build.heroStats);
      }
      stats.allStats = hCodeValues.mergeStats(stats.allStats);
      
      stats.calculatedStats = this.getCalculatedStats(build, stats.allStats);
      return stats;
    }
  };
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('translations', ['$routeParams', '$rootScope', translations]);
function translations($routeParams, $rootScope) {

  var dnTranslations = new DnTranslations();
  var smallFile = 'uistring.optimised.lzjson';
  var bigFile = 'uistring.lzjson';

  var completeCallback = [];
  var progressCallback = [];

  return {
    
    reset : function() {
      dnTranslations = new DnTranslations();
      dnTranslations.sizeLimit = 100;
      this.loaded = false;
      this.startedLoading = false;
      completeCallback = [];
      progressCallback = [];
    },
    
    getFileName: function() {
      if(this.small) {
        // console.log('loading optimised translations');
        return smallFile;
      }
      else {
        // console.log('loading full translations');
        return bigFile;
      }
    },
    
    loaded : false,
    startedLoading : false,
    small: false,
    
    location : null,
  
    init : function(progress, complete) {

      if(this.isLoaded()) {
        complete();
      }
      else {
        progressCallback = [];
        if(progress) {
          progressCallback.push(progress);
        }
        if(complete) {
          completeCallback.push(complete);
        }
  
        if(!this.startedLoading) {
          this.startedLoading = true;
          var t = this;
          
          var fileName = null;
          if(this.location && this.location != '') {
            fileName = this.location + '/' + this.getFileName();
            
            if(fileName != localStorage.getItem("UIStrings_file")) {
              sessionStorage.removeItem('UIStrings');
              localStorage.removeItem('UIStrings_file');
            }
          }
          
          $rootScope.$broadcast('TRANSLATION_LOAD_EVENT');
          dnTranslations.loadDefaultFile(
            fileName, 
            function(msg) {
              angular.forEach(progressCallback, function(value, key) { value(msg); });
            }, 
            function() {
              t.loaded = true;
              angular.forEach(completeCallback, function(value, key) { value(); });
              completeCallback = [];
              $rootScope.$broadcast('TRANSLATION_LOAD_EVENT');
            },
            function(msg) {
              angular.forEach(progressCallback, function(value, key) { value(msg); });
              $rootScope.$broadcast('TRANSLATION_LOAD_ERROR');
              t.startedLoading = false;
              t.loaded = false;
            }
          );
        }
      }
    },
    
    isLoaded : function() {
      if(!this.loaded) {
        var fileName = this.location + '/' + this.getFileName();
        
        if(fileName != localStorage.getItem("UIStrings_file")) {
          sessionStorage.removeItem('UIStrings');
          localStorage.removeItem('UIStrings_file');
        }

        this.loaded = dnTranslations.loadFromSession();
        if(this.loaded) {
          this.startedLoading = true;
        }
      }
      return this.loaded;
    },
    
    translate : function(id,idParam) {
      if(this.loaded) {
        
        var name;
        if(!id) {
          return '';
        }
        else {
          name = dnTranslations.translate(id);
          
          if(typeof name != 'string') {
            return 'm' + name;
          }
        }
        
        if(idParam) {
          var params = idParam.split(',');
          for(var p=0;p<params.length;++p) {
            var pid = params[p];
            if(pid.indexOf('{') == 0) {
              pid = params[p].replace(/\{|\}/g,'');
              pid = dnTranslations.translate(pid);
            }
            
            name = name.replace('{' + p + '}', pid);
          }
        }

        return name;
      }
      else {
        return 'm' + id;
      }
    }
  }
}

})();
(function () {
'use strict';

angular.module('dnsim').factory('hCodeValues', [hCodeValues]);
function hCodeValues() {

  function toOneDec(stat) {
    return Math.round(stat.max*10)/10;
  }
  function toNoDec(stat) {
    return Math.floor(stat.max);
  }
  function inThousands(stat) {
    var val = Number(stat.max);
    if(val < 100) {
      return val;
    }
    else if(val < 100000) {
      return Math.round(val/100)/10 + 'k';
    }
    else if(val < 1000000) {
      return Math.round(val/1000) + 'k';
    }
    else if(val < 10000000) {
      return Math.round(val/10000)/100 + 'm';
    }
    else {
      return Math.round(val/1000000) + 'm';
    }
  }
  function toPercent(stat) {
    return (Math.floor(stat.max*100000)/1000) + '%';
  }
  
  return {
    stats : {
      0  : {id: 0, name: 'str', display: toNoDec, dps: true, pc: 50, skPc: 4050, searchable: true },
      1  : {id: 1, name: 'agi', display: toNoDec, dps: true, pc: 51, skPc: 4051, searchable: true },
      2  : {id: 2, name: 'int', display: toNoDec, dps: true, pc: 52, skPc: 4052, searchable: true },
      3  : {id: 3, name: 'vit', display: toNoDec, def: true, pc: 53, skPc: 4053, searchable: true },
      4  : {id: 4, name: 'pdmg', display: toNoDec, combineWith: 5, dps: true, pc: 54, searchable: true, altStat: 32 },
      5  : {id: 5, name: 'maxPdmg', display: toNoDec, hide: true, pc: 55 },
      6  : {id: 6, name: 'mdmg', display: toNoDec, combineWith: 7, dps: true, pc: 56, searchable: true, altStat: 33 },
      7  : {id: 7, name: 'maxMdmg', display: toNoDec, hide: true, pc: 57 },
      8  : {id: 8, name: 'pdef', display: inThousands, def: true, pc: 58, searchable: true },
      9  : {id: 9, name: 'mdef', display: inThousands, def: true, pc: 59, searchable: true },
      10 : {id: 10, name: 'para', display: inThousands, pc: 60, noCustom: true },
      11 : {id: 11, name: 'para resist', display: inThousands, pc: 61, noCustom: true },
      12 : {id: 12, name: 'crit', display: toNoDec, dps: true, pc: 62, searchable: true },
      13 : {id: 13, name: 'crit resist', display: inThousands, pc: 63, noCustom: true },
      14 : {id: 14, name: 'stun', display: inThousands, pc: 64, noCustom: true },
      15 : {id: 15, name: 'stun resist', display: inThousands, pc: 65, noCustom: true },
      16 : {id: 16, name: 'fire%', display: toPercent, dps: true, searchable: true },
      17 : {id: 17, name: 'ice%', display: toPercent, dps: true, searchable: true },
      18 : {id: 18, name: 'light%', display: toPercent, dps: true, searchable: true },
      19 : {id: 19, name: 'dark%', display: toPercent, dps: true, searchable: true },
      20 : {id: 20, name: 'fire def', display: toPercent, def: true, searchable: true },
      21 : {id: 21, name: 'ice def', display: toPercent, def: true, searchable: true },
      22 : {id: 22, name: 'light def', display: toPercent, def: true, searchable: true },
      23 : {id: 23, name: 'dark def', display: toPercent, def: true, searchable: true },
      25 : {id: 25, name: 'hp', display: inThousands, def: true, pc: 75, skPc: 4075, searchable: true },
      26 : {id: 26, name: 'mp', display: inThousands, def: true, pc: 76, skPc: 4076 },
      29 : {id: 29, name: 'fd', display: toNoDec, dps: true, searchable: true },
      
      // these are both min and max
      // shows with the same name but these are used really just for set bonus I think
      32 : {id: 32, name: 'pdmg', display: toNoDec, dps: true, pc: 54 },
      33 : {id: 33, name: 'mdmg', display: toNoDec, dps: true, pc: 56 },
      
      50 : {id: 50, name: 'str%', display: toPercent, dps: true },
      51 : {id: 51, name: 'agi%', display: toPercent, dps: true },
      52 : {id: 52, name: 'int%', display: toPercent, dps: true },
      53 : {id: 53, name: 'vit%', display: toPercent, def: true },
      54 : {id: 54, name: 'pdmg%', display: toPercent, combineWith: 55, dps: true },
      55 : {id: 55, name: 'maxPdmg%', display: toPercent, hide: true },
      56 : {id: 56, name: 'mdmg%', display: toPercent, combineWith: 57, dps: true },
      57 : {id: 57, name: 'maxMdmg%', display: toPercent, hide: true },
      58 : {id: 58, name: 'pdef%', display: toPercent, def: true },
      59 : {id: 59, name: 'mdef%', display: toPercent, def: true },
      60 : {id: 60, name: 'para%', display: toPercent, noCustom: true, def: true },
      61 : {id: 61, name: 'para resist%', display: toPercent, noCustom: true, def: true },
      62 : {id: 62, name: 'crit%', display: toPercent, dps: true },
      63 : {id: 63, name: 'crit resist%', display: toPercent, def: true },
      64 : {id: 64, name: 'stun%', display: toPercent, noCustom: true, def: true },
      65 : {id: 65, name: 'stun resist%', display: toPercent, noCustom: true, def: true },
      74 : {id: 74, name: 'move%', display: toPercent, noCustom: true, def: true },
      75 : {id: 75, name: 'hp%', display: toPercent, def: true },
      76 : {id: 76, name: 'mp%', display: toPercent, def: true },
      77 : {id: 77, name: 'mp recover%', display: toPercent, def: true },
      81 : {id: 81, name: 'safe move%', display: toPercent, noCustom: true, def: true },

      // these are both min and max
      // shows with the same name but these are used really just for set bonus I think
      101 : {id: 101, name: 'pdmg%', display: toPercent, noCustom: true, dps: true },
      102 : {id: 102, name: 'mdmg%', display: toPercent, noCustom: true, dps: true },

      103: {id: 103, name: 'crit dmg', display: toNoDec, dps: true, pc: 104 },
      104: {id: 104, name: 'crit dmg%', display: toPercent, noCustom: true, dps: true },
      105: {id: 104, name: 'pvp dmg', display: inThousands, noCustom: true, dps: true },
      106: {id: 106, name: 'pvp def', display: inThousands, noCustom: true, def: true },
      107: {id: 107, name: 'mp?', display: toNoDec, noCustom: true, hide: true, def: true },
      
      // stats below here are ones I made up
      1001: {id: 1001, name: 'dmg', display: inThousands, summaryDisplay: true, element: 'primary', noCustom: true, hide: true },
      1004: {id: 1004, name: 'pdmg', display: inThousands, summaryDisplay: true, element: 'primary', noCustom: true, hide: true },
      1006: {id: 1006, name: 'mdmg', display: inThousands, summaryDisplay: true, element: 'primary', noCustom: true, hide: true },
      
      1008: {id: 1008, name: 'pdef', display: toPercent, noCustom: true },
      1009: {id: 1009, name: 'mdef', display: toPercent, noCustom: true },
      
      1012: {id: 1012, name: 'crit chance', display: toPercent, noCustom: true },
      1029: {id: 1029, name: 'fd', display: toPercent, noCustom: true },
      1103: {id: 1103, name: 'crit dmg', display: toPercent, noCustom: true },
      
      2001: {id: 2001, name: 'dmg', display: inThousands, summaryDisplay: true, element: 'secondary', noCustom: true, hide: true },
      2004: {id: 2004, name: 'pdmg', display: inThousands, summaryDisplay: true, element: 'secondary', noCustom: true, hide: true },
      2006: {id: 2006, name: 'mdmg', display: inThousands, summaryDisplay: true, element: 'secondary', noCustom: true, hide: true },
      
      2008: {id: 2008, name: 'pdef eqhp', display: inThousands, noCustom: true },
      2009: {id: 2009, name: 'mdef eqhp', display: inThousands, noCustom: true },
      
      3000: {id: 3000, name: 'skDmg%', display: toPercent, dps: true },
      3001: {id: 3001, name: 'skPDmg%', display: toPercent, dps: true },
      3002: {id: 3002, name: 'skMDmg%', display: toPercent, dps: true },
      
      3008: {id: 3008, name: 'eqhp', display: inThousands, summaryDisplay: true, noCustom: true, hide: true },
      
      4012: {id: 4012, name: 'skCrit', display: inThousands, dps: true },
      4050: {id: 4050, name: 'skStr%', display: toPercent, dps: true },
      4051: {id: 4051, name: 'skAgi%', display: toPercent, dps: true },
      4052: {id: 4052, name: 'skInt%', display: toPercent, dps: true },
      4053: {id: 4053, name: 'skVit%', display: toPercent, def: true },
      4075: {id: 4075, name: 'skHp%', display: toPercent, def: true },
      4076: {id: 4076, name: 'skMp%', display: toPercent, def: true },
      
      // special cases for skills
      10164: {id: 10164, name: 'intToPdmg', display: toPercent, noCustom: true },
      10165: {id: 10165, name: 'strToMdmg', display: toPercent, noCustom: true },
      
      // items over 10000 are unknown skill effects
    },
  
    rankNames : {
      0 : { id: 0, name : 'normal' },
      1 : { id: 1, name : 'magic' },
      2 : { id: 2, name : 'rare' },
      3 : { id: 3, name : 'epic' },
      4 : { id: 4, name : 'unique' },
      5 : { id: 5, name : 'legendary' },
    },
    
    shopNames : {
      28001: 'lament',28002: 'lament',28003: 'lament',28004: 'lament',28005: 'lament',28006: 'lament',28007: 'lament',28008: 'lament',28009: 'lament',
      29001: 'aura',29002: 'aura',29003: 'aura',29004: 'aura',29005: 'aura',29006: 'aura',29007: 'aura',29008: 'aura',29009: 'aura',
      5001: 'medal',5002: 'medal',5003: 'medal',5004: 'medal',5005: 'medal',5006: 'medal',5007: 'medal',5008: 'medal',5009: 'medal',
      5101: 'ladder',5102: 'ladder',5103: 'ladder',5104: 'ladder',5105: 'ladder',5106: 'ladder',5107: 'ladder',5108: 'ladder',5109: 'ladder',
      59001: 'garden bunny',
      52001 : 'nightmare', 52002 : 'nightmare', 52003 : 'nightmare', 52004 : 'nightmare', 52005 : 'nightmare', 52006 : 'nightmare', 52007 : 'nightmare', 52008 : 'nightmare', 52009 : 'nightmare',
      21: 'blacksmith', 22: 'blacksmith', 23: 'blacksmith', 24: 'blacksmith', 25: 'blacksmith', 26: 'blacksmith', 27: 'blacksmith', 28: 'blacksmith', 29: 'blacksmith', 
      89001: 'guild master',
      88001: 'battlefield', 88002: 'battlefield', 88003: 'battlefield', 88004: 'battlefield', 88005: 'battlefield', 88006: 'battlefield', 88007: 'battlefield', 88008: 'battlefield', 88009: 'battlefield', 
      66001: 'erosion',
      35006: 'plate',
      14051: 'abyss', 14052: 'abyss', 14053: 'abyss', 14054: 'abyss', 14055: 'abyss', 14056: 'abyss', 14057: 'abyss', 14058: 'abyss', 14059: 'abyss', 
      40011: 'daredevil faire', 40012: 'daredevil faire', 40013: 'daredevil faire', 40014: 'daredevil faire', 40015: 'daredevil faire', 40016: 'daredevil faire', 40017: 'daredevil faire', 40018: 'daredevil faire',
      40001: 'daredevil faire', 40002: 'daredevil faire', 
      91001: 'wrath',
      45001: 'farm',
    },
    
    checkedRank : {
      0 : true,
      1 : true,
      2 : true,
      3 : true,
      4 : true,
      5 : true,
    },
    
    typeNames : {
      0 : 'weapons',
      1 : 'equipment',
      5 : 'plates',
      8 : 'pouch',
      38 : 'plates',
      90 : 'welspring',
      132 : 'talisman',
      139 : 'gems',
    },
    
    elements : {
      0 : { id: 0, name: 'non-ele' },
      1 : { id: 1, name: 'fire', dmgStat: 16 },
      2 : { id: 2, name: 'ice', dmgStat: 17 },
      3 : { id: 3, name: 'light', dmgStat: 18 },
      4 : { id: 4, name: 'dark', dmgStat: 19 },
    },
    
    damageTypes : {
      0 : { id: 0, name: 'both separate' },
      1 : { id: 1, name: 'physical' },
      2 : { id: 2, name: 'magical' },
      3 : { id: 3, name: 'both combined' },
    },
    
    // note: skills shown on-screen have 1k added to their id
    skillEffectMapping : {
      2 : { id: 2, name: 'phyisical attack power', mapTo: 3001 },
      13 : { id: 13, name: 'mp', mapTo: 26 },
      25 : { id: 25, name: 'action speed' },
      29 : { id: 29, name: 'magic attack power', mapTo: 3002 },
      32 : { id: 32, name: 'fire %', mapTo: 16 },
      33 : { id: 33, name: 'ice %', mapTo: 17 },
      34 : { id: 34, name: 'light %', mapTo: 18 },
      35 : { id: 35, name: 'dark %', mapTo: 19 },
      36 : { id: 36, name: 'fire def', mapTo: 20 },
      37 : { id: 37, name: 'ice def', mapTo: 21 },
      38 : { id: 38, name: 'light def', mapTo: 22 },
      39 : { id: 39, name: 'dark def', mapTo: 23 },
      58 : { id: 58, name: 'hp%', mapTo: 4075 },
      59 : { id: 59, name: 'mp%', mapTo: 4076 },
      65 : { id: 65, name: 'range' },
      76 : { id: 76, name: 'movement speed', mapTo: 74 },
      87 : { id: 87, name: 'str%', mapTo: 4050 },
      88 : { id: 88, name: 'agi%', mapTo: 4051 },
      89 : { id: 89, name: 'int%', mapTo: 4052 },
      90 : { id: 90, name: 'vit%', mapTo: 4053 },
      // 134 : { id: 134, name: 'p dmg reduction%' },
      // 135 : { id: 135, name: 'm dmg reduction%' },
      185 : { id: 185, name: 'wots attack power', mapTo: 3000 },
      251 : { id: 251, name: 'critical chance%', mapTo: 1012 },
      164 : { id: 164, name: 'intToPdmg', mapTo: 10164 },
      165 : { id: 165, name: 'strToMdmg', mapTo: 10165 },
      222: {
        id: 222, 
        name: 'hellfire', 
        getVals: function(val) {
          if(val.indexOf(';') > 0) {
            var vals = val.split(';');
            return [
              {id: 62, effect: 222, max: Number(vals[0])/100.0},
              {id: 4012, effect: 222, max: Number(vals[1])},
              ];
          }
          else {
            return [{id: 62, effect: 222, max: Number(val)/100.0}];
          }
        }
      },
      389: { id: 389, name: 'fd buf', mapTo: 1029 },
    },
    
    gemExchanges: [
      {id: 2, name: 'Weapon'},
      {id: 3, name: 'Off-Hand Weapon'},
      {id: 4, name: 'Headgear'},
      {id: 5, name: 'Body Armor'},
      {id: 6, name: 'Leg Armor'},
      {id: 7, name: 'Gloves'},
      {id: 8, name: 'Shoes'},
      {id: 101, name: 'Necklace'},
      {id: 102, name: 'Earrings'},
      {id: 103, name: 'Ring'},
    ],
    
    customItems: 
    [
    {id: 0, typeName:'custom', name: 'wise plate fix', stats: [{id: 52, max:-0.001}]},
    {id: 0, typeName:'custom', name: 'hp unified', stats: [{id: 4075, max:0.05}]},
    ],
  
    getStats : function(data) {

      var useMax=false;
      var useStateXVal=false;
      var mightHaveSets=true;
      var prop = 'State1_Max';
      if(prop in data) {
        useMax = true;
      }
      else {
        prop = 'State1Value';
        if(prop in data) {
          useStateXVal = true;
        }
      }
      
      var currentState = 0;
      var statVals = [];
      for(;;) {
        currentState++;
        
        var stateProp = 'State' + currentState;
        if(!(stateProp in data)) {
          break;
        }

        var stateId = data[stateProp];
        if(stateId == -1) {
          break;
        }
        
        if(stateId == 107) {
          // is this mp?
        }
        else {
          
          var currentData = { id: stateId };
          
          var prop;
        
          if(useMax) {
            prop = 'State' + currentState + '_Max';
            currentData.max = data[prop];
          }
          else if(useStateXVal) {
            prop = 'State' + currentState + 'Value';
            currentData.max = data[prop];
          }
          else {
            prop = 'StateValue' + currentState;
            currentData.max = Number(data[prop]);
          }
          
          if(currentData.max > 0 || currentData.max < 0) {
            if(mightHaveSets) {
              prop = 'NeedSetNum' + currentState;
              if(prop in data) {
                if(data[prop] == 0) {
                  break;
                }
                currentData.needSetNum = data[prop];
              }
              else {
                mightHaveSets = false;
              }
            }
          
            statVals.push(currentData);
          }
        }
      }
      
      return statVals;
    },
    
    setupStat : function(stat, id) {
      stat.id = Number(id);
    },
    
    mergeStats : function(stats1, stats2) {
      var statMap = {};
      
      var self = this;
      function add(value) {
        
        var amount = Number(value.max);
        if(self.stats[value.id] && 'pc' in self.stats[value.id]) {
          amount = Math.floor(amount);
        }
        
        if(value.id in statMap) {
          statMap[value.id] += amount;
        }
        else {
          statMap[value.id] = amount;
        }
      }
      
      angular.forEach(stats1, function(value, key) {
        if(value) {
          add(value);
        }
      });
      
      if(stats2) {
        angular.forEach(stats2, function(value, key) {
          if(value) {
            add(value);
          }
        });
      }
      
      var newStats = [];
      
      for(var key in statMap) {
        var stat = { max : statMap[key], id: Number(key) };
        newStats.push(stat);
      }
        
      return newStats;
    }
  }
}

})();
//# sourceMappingURL=app.min.js.map
