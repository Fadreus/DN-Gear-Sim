'use strict';

(function () {
  'use strict';

  angular.module('dnsim').config(['$routeProvider', config]);

  function config($routeProvider) {

    $routeProvider.when('/about', {
      templateUrl: 'ui/about/about.html',
      controller: 'AboutCtrl as about'
    }).when('/setup', {
      templateUrl: 'ui/nav/setup.html',
      controller: 'SetupCtrl'
    }).when('/test', {
      templateUrl: 'ui/nav/test.html',
      controller: 'TestCtrl'
    }).when('/items', {
      templateUrl: 'ui/search/everything-search.html',
      controller: 'ItemsCtrl as items',
      reloadOnSearch: false
    }).when('/', {
      templateUrl: 'ui/welcome.html'
    }).when('/builds', {
      templateUrl: 'ui/builds/build-list.html',
      controller: 'BuildListCtrl as buildList'
    }).when('/build', {
      templateUrl: 'ui/builds/build-list.html',
      controller: 'BuildListCtrl as buildList'
    }).when('/view-group', {
      templateUrl: 'ui/builds/view-group.html',
      controller: 'ViewGroupCtrl'
    }).when('/edit-build', {
      templateUrl: 'ui/builds/edit-build.html',
      controller: 'EditBuildCtrl as editGroup'
    }).when('/new-build', {
      templateUrl: 'ui/builds/edit-build.html',
      controller: 'EditBuildCtrl as editGroup'
    }).when('/delete-build', {
      templateUrl: 'ui/builds/delete-build.html',
      controller: 'DeleteBuildCtrl as deleteBuild'
    }).when('/reload-build', {
      templateUrl: 'ui/builds/reload-build.html',
      controller: 'ReloadBuildCtrl as ctrl'
    }).when('/search', {
      templateUrl: 'ui/search/search.html',
      controller: 'ItemSearchCtrl as ctrl',
      reloadOnSearch: false
    }).when('/item', {
      templateUrl: 'ui/item/item.html',
      controller: 'ItemCtrl'
    }).when('/item', {
      templateUrl: 'ui/item/item.html',
      controller: 'ItemCtrl'
    }).when('/export', {
      templateUrl: 'ui/nav/export.html',
      controller: 'ExportCtrl'
    }).when('/talismans', {
      templateUrl: 'ui/builds/build-talismans.html',
      controller: 'BuildTalismansCtrl as ctrl'
    }).when('/publish', {
      templateUrl: 'ui/online/publish.html',
      controller: 'PublishCtrl as ctrl'
    }).when('/profile', {
      templateUrl: 'ui/online/profile.html',
      controller: 'ProfileCtrl as ctrl'
    }).when('/published', {
      templateUrl: 'ui/online/published.html',
      controller: 'PublishedCtrl as ctrl'
    }).when('/import', {
      templateUrl: 'ui/builds/build-import.html',
      controller: 'BuildImportCtrl as ctrl'
    }).when('/published', {
      templateUrl: 'ui/online/published.html',
      controller: 'PublishedCtrl as ctrl'
    }).when('/build-search', {
      templateUrl: 'ui/online/build-search.html',
      controller: 'BuildSearchCtrl as ctrl'
    }).otherwise({
      redirectTo: '/'
    });
  }
})();
'use strict';

angular.module('dnsim').controller('buildActionsCtrl', ['$location', 'saveHelper', 'exportLinkHelper', function ($location, saveHelper, exportLinkHelper) {
  'use strict';

  var vm = this;

  this.deleteGroup = function () {
    $location.path('/delete-build');
    $location.search('name', vm.buildName);
  };

  this.editGroup = function () {
    $location.path('/edit-build');
    $location.search('buildName', vm.buildName);
  };

  this.copyGroup = function () {
    var newGroupName = saveHelper.importGroup(vm.buildName, vm.build.items);

    saveHelper.saveBuild(newGroupName, newGroupName, vm.build);

    $location.path('/build');
    $location.search('buildName', newGroupName);
  };

  this.reloaded = false;
  this.reloadGroup = function () {
    $location.path('/reload-build');
    $location.search('name', vm.buildName);
  };

  function progress() {}

  this.setShortUrl = function () {
    if (vm.build) {
      var longUrl = exportLinkHelper.createGroupLink(vm.buildName, vm.build);
      vm.build.shortUrl = sessionStorage.getItem(longUrl);
    }
  };

  this.setShortUrl();
}]).directive('dngearsimBuildActions', function () {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build',
      onChange: '&onChange'
    },
    controller: 'buildActionsCtrl',
    controllerAs: 'buildActions',
    templateUrl: 'ui/builds/build-actions.html'
  };
});
'use strict';

angular.module('dnsim').controller('buildExportActionCtrl', ['$timeout', '$location', 'hCodeValues', 'statHelper', 'itemCategory', 'saveHelper', 'exportLinkHelper', 'groupHelper', 'translations', 'dntData', 'dntReset', function ($timeout, $location, hCodeValues, statHelper, itemCategory, saveHelper, exportLinkHelper, groupHelper, translations, dntData, dntReset) {
  'use strict';

  var vm = this;

  vm.export = exportBuild;

  function exportBuild() {
    var blob = new Blob([JSON.stringify(vm.build, null, 1)], { type: "text/plain;charset=utf-8" });
    saveAs(blob, 'dngearsim-' + vm.buildName + '.json');
  }
}]).directive('dngearsimBuildExportAction', function () {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build'
    },
    controller: 'buildExportActionCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/builds/build-export-action.html'
  };
});
'use strict';

angular.module('dnsim').controller('BuildImportCtrl', ['$timeout', '$location', 'hCodeValues', 'statHelper', 'itemCategory', 'saveHelper', 'exportLinkHelper', 'groupHelper', 'translations', 'dntData', 'dntReset', function ($timeout, $location, hCodeValues, statHelper, itemCategory, saveHelper, exportLinkHelper, groupHelper, translations, dntData, dntReset) {
  'use strict';

  var vm = this;

  vm.onFileChange = onFileChange;
  vm.copyLocally = copyLocally;

  function onFileChange(event) {
    var files = event.target.files;
    console.log('importing files', files);
    if (files && files.length) {

      var fileName = files[0].name;
      var reader = new FileReader();
      reader.readAsText(files[0]);
      reader.onload = function () {
        vm.build = JSON.parse(reader.result);
        if (fileName && fileName.length > 5) {
          vm.buildName = fileName.substr(0, fileName.length - 5);
          vm.buildName = vm.buildName.replace('dngearsim-', '');
        } else {
          vm.buildName = 'imported build';
        }
        $timeout();
      };
    }
  }

  function copyLocally() {
    var newGroupName = saveHelper.importGroup(vm.buildName, vm.build.items);

    saveHelper.saveBuild(newGroupName, newGroupName, vm.build);

    $location.path('/build');
    $location.search('buildName', newGroupName);
  }
}]);
'use strict';

buildItemListController.$inject = ["hCodeValues", "itemCategory", "saveHelper"];
angular.module('dnsim').directive('dngearsimBuildItemList', function () {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build',
      category: '=category',
      server: '=server',
      onChange: '&onChange'
    },
    controller: buildItemListController,
    controllerAs: 'buildCtrl',
    templateUrl: 'ui/builds/build-item-list.html'
  };
});

function buildItemListController(hCodeValues, itemCategory, saveHelper) {

  var vm = this;

  vm.getCategoryItems = function () {
    var itemsByCat = itemCategory.getItemsByCategory(vm.build.items);
    if (vm.category.name in itemsByCat) {
      return itemsByCat[vm.category.name];
    } else {
      return [];
    }
  };

  var subCats = {};
  var subCatCatName = '';
  vm.getSubCategories = function () {
    if (subCatCatName != vm.category.name) {
      subCats = {};
      subCatCatName = vm.category.name;
      var subCatList = [];

      var items = vm.build.items.sort(function (item1, item2) {
        return item1.exchangeType - item2.exchangeType;
      });
      if (vm.category.name == 'increasing gems') {
        subCatList = _.filter(items, function (item) {
          return item.increasingGemSlots > 0;
        });
      } else if (vm.category.name == 'offensive gems') {
        subCatList = _.filter(items, function (item) {
          return item.offensiveGemSlots > 0;
        });
      } else if (vm.category.name == 'imprint') {
        var costumeCat = itemCategory.byName('costume');
        subCatList = _.filter(items, function (item) {
          return itemCategory.isItemForCat(costumeCat, item);
        });
      }
      _.each(subCatList, function (item) {
        if (!(item.exchangeType in subCats)) {
          subCats[item.exchangeType] = {
            names: [],
            slots: 0,
            exchangeType: item.exchangeType
          };
        }

        subCats[item.exchangeType].names.push(item.name);
        if (vm.category.name == 'increasing gems') {
          subCats[item.exchangeType].slots += item.increasingGemSlots;
        } else if (vm.category.name == 'offensive gems') {
          subCats[item.exchangeType].slots += item.offensiveGemSlots;
        } else {
          subCats[item.exchangeType].slots = 1;
        }
      });
      subCats[0] = null;
    }

    return subCats;
  };

  vm.getNumTaken = function (subCat) {
    var retVal = 0;
    var exchangeId;
    if (vm.category.name == 'imprint') {
      exchangeId = subCat.exchangeType;
    } else {
      var gemExchange = _.find(hCodeValues.gemExchanges, function (e) {
        return e.exchange == subCat.exchangeType;
      });

      exchangeId = gemExchange.id;
    }

    if (exchangeId) {
      var items = vm.getCategoryItems();
      _.each(items, function (item) {
        if (item.gemSlot == exchangeId) {
          ++retVal;
        }
      });
    }
    return retVal;
  };

  vm.isInSubCat = function (item, subCat) {
    if (!subCat && !item.gemSlot) {
      return true;
    } else {
      var exchangeId;
      if (vm.category.name == 'imprint') {
        exchangeId = item.gemSlot;
      } else {
        var gemExchange = _.find(hCodeValues.gemExchanges, function (e) {
          return e.id == item.gemSlot;
        });
        if (gemExchange) {
          exchangeId = gemExchange.exchange;
        }
      }

      if (!subCat && exchangeId) {
        // check for invalid slot
        var allSubCatItems = vm.getSubCategories();
        var foundSubCatItem = _.find(allSubCatItems, function (subCatItem) {
          return subCatItem != null && exchangeId == subCatItem.exchangeType;
        });

        if (!foundSubCatItem) {
          return true;
        }
      } else if (subCat && exchangeId) {
        return exchangeId == subCat.exchangeType;
      } else {
        return false;
      }
    }
  };

  vm.canMove = function () {
    return vm.category.name == 'increasing gems' || vm.category.name == 'offensive gems' || vm.category.name == 'imprint';
  };

  vm.getGemSlot = function (subCat) {
    if (vm.category.name == 'imprint') {
      return subCat.exchangeType;
    } else if (subCat) {
      var gemExchange = _.find(hCodeValues.gemExchanges, function (e) {
        return e.exchange == subCat.exchangeType;
      });

      if (!gemExchange) {
        console.log('cannot find exchange for', subCat);
      }
      return gemExchange.id;
    }
  };

  vm.move = function (moveItem, destination) {
    moveItem.gemSlot = vm.getGemSlot(destination);
    saveHelper.updatedSavedItems(vm.buildName, vm.build.items);
    vm.handleChange();
  };

  vm.allowMoreItems = function () {
    return !vm.category.maxCat || vm.getCategoryItems().length < vm.category.maxCat;
  };

  vm.handleChange = function () {
    subCatCatName = '';
    vm.onChange();
  };

  vm.handleItemEdit = function () {
    saveHelper.updatedSavedItems(vm.buildName, vm.build.items);
    vm.handleChange();
  };

  vm.cancelEdit = function () {
    vm.onChange();
  };

  vm.canEdit = function (item) {
    return item.typeName == 'custom' || item.typeName == 'weapons' || item.typeName == 'armour' || item.typeName == 'offensive gems' || item.typeName == 'increasing gems';
  };

  vm.removeItem = function (item) {
    subCatCatName = '';
    item.removeItem = true;
    var newItemList = [];
    angular.forEach(vm.build.items, function (gItem, index) {
      if (gItem && !gItem.removeItem) {
        newItemList.push(gItem);
      }
    });

    vm.build.items = newItemList;
    saveHelper.updatedSavedItems(vm.buildName, newItemList);
    vm.handleChange();
  };
}
'use strict';

angular.module('dnsim').controller('buildItemCtrl', ['$timeout', 'statHelper', 'saveHelper', 'hCodeValues', function ($timeout, statHelper, saveHelper, hCodeValues) {
  'use strict';

  var vm = this;

  vm.updateItem = setFullStats;
  vm.gemSlots = hCodeValues.gemExchanges;
  vm.getGemSlotName = getGemSlotName;

  function getGemSlotName(item) {
    if (item.gemSlot) {
      for (var i = 0; i < vm.gemSlots.length; ++i) {
        if (vm.gemSlots[i].id == item.gemSlot) {
          return vm.gemSlots[i].name;
        }
      }
    }
  }

  function setFullStats() {
    // full stats are cleared when publishing builds
    vm.item.fullStats = vm.item.stats;

    if (vm.item.enchantmentStats != null && vm.item.enchantmentStats.length > 0) {
      vm.item.fullStats = hCodeValues.mergeStats(vm.item.enchantmentStats, vm.item.fullStats);
    }

    if (vm.item.sparkStats != null && vm.item.sparkStats.length > 0) {
      vm.item.fullStats = hCodeValues.mergeStats(vm.item.sparkStats, vm.item.fullStats);
    }
  }
}]).directive('dngearsimBuildItem', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      editMode: '=editMode',
      onChange: '&onChange',
      cancelEdit: '&cancelEdit'
    },
    controller: 'buildItemCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/builds/build-item.html'
  };
});
'use strict';

angular.module('dnsim').controller('BuildListCtrl', ['$window', '$location', '$routeParams', '$timeout', 'saveHelper', function ($window, $location, $routeParams, $timeout, saveHelper) {
  'use strict';

  var vm = this;
  document.body.className = 'saved-back';
  this.setupBuilds = function () {
    vm.savedItems = saveHelper.getSavedItems();
    vm.buildNames = Object.keys(vm.savedItems).sort();
    vm.builds = [];
    for (var i = 0; i < vm.buildNames.length; ++i) {
      vm.builds.push({
        name: vm.buildNames[i],
        build: vm.savedItems[vm.buildNames[i]]
      });
    }
  };
  this.setupBuilds();

  if ('buildName' in $routeParams) {
    if ($routeParams.buildName in vm.savedItems) {
      if ($routeParams.buildName != this.currentGroup) {
        this.currentGroup = $routeParams.buildName;
        saveHelper.saveBuildSelection(this.currentGroup, this.savedItems);
      }
    } else {
      this.currentGroup = null;
    }
  } else if (this.currentGroup && this.currentGroup in this.savedItems) {
    $location.path('/build');
    $location.search('buildName', this.currentGroup);
  } else {
    this.currentGroup = null;
  }

  if (this.currentGroup) {
    $window.document.title = 'dngearsim | ' + this.currentGroup;
  } else {
    $window.document.title = 'dngearsim | BUILDS';
  }

  this.anyItems = function () {
    return Object.keys(this.savedItems).length > 0;
  };

  this.createGroup = function () {
    $location.path('/new-build');
  };

  this.handleChange = function () {
    vm.setupBuilds();
    $timeout();
    // console.log('change');
  };

  this.toggleGroup = function (buildName) {
    saveHelper.saveBuildSelection(buildName, this.savedItems);
    $location.url('/build?buildName=' + buildName);
  };

  this.publish = function () {
    $location.url('/publish');
  };

  this.search = function () {
    $location.url('/build-search');
  };
}]);
'use strict';

buildStatsController.$inject = ["statHelper", "dvStatcardHelper"];
angular.module('dnsim').directive('dngearsimBuildStats', function () {
  return {
    scope: true,
    bindToController: {
      stats: '=stats',
      build: '=build',
      buildName: '=buildName'
    },
    controller: buildStatsController,
    controllerAs: 'statsCtrl',
    templateUrl: 'ui/builds/build-stats.html'
  };
});

function buildStatsController(statHelper, dvStatcardHelper) {
  var vm = this;

  vm.exportStatCard = function () {
    var dvCardStatHash = dvStatcardHelper.convertStats(vm.build, vm.buildName, vm.stats.calculatedStats);
    var url = dvStatcardHelper.cardImportUrl + '?dngsimport=' + btoa(JSON.stringify(dvCardStatHash));
    window.open(url);
  };
}
'use strict';

angular.module('dnsim').controller('buildSummaryCtrl', ['$routeParams', '$location', 'hCodeValues', 'statHelper', 'itemCategory', function ($routeParams, $location, hCodeValues, statHelper, itemCategory) {
  'use strict';

  var vm = this;

  this.stats = statHelper.getBuildStats(this.build);
  this.itemsByCategory = itemCategory.getItemsByCategory(this.build.items);

  this.getSaveDate = function (group) {
    if (vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleDateString();
    }
  };

  this.getSaveTime = function (group) {
    if (vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleTimeString();
    }
  };

  this.getBuildSummary = function (group) {
    var summary = '';

    var typeCounts = {};
    var cashItems = 0;
    var titles = 0;
    angular.forEach(vm.itemsByCategory, function (itemsByType, type) {
      if (itemsByType.length > 0) {
        if (summary.length > 0) {
          summary += ', ';
        }
        summary += itemsByType.length + ' ' + type;
      }
    });

    return summary;
  };
}]).directive('dngearsimBuildSummary', function () {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build'
    },
    controller: 'buildSummaryCtrl',
    controllerAs: 'buildCtrl',
    templateUrl: 'ui/builds/build-summary.html'
  };
});
'use strict';

angular.module('dnsim').controller('BuildTalismansCtrl', ['$window', '$location', '$routeParams', '$timeout', 'saveHelper', 'statHelper', 'jobs', 'hCodeValues', 'itemColumnsToLoad', 'character', function ($window, $location, $routeParams, $timeout, saveHelper, statHelper, jobs, hCodeValues, itemColumnsToLoad, character) {
  'use strict';

  var vm = this;

  $window.document.title = 'dngearsim | TALISMANS';
  $window.scrollTo(0, 0);

  this.savedItems = saveHelper.getSavedItems();
  this.groupNames = Object.keys(this.savedItems);
  if (!this.groupNames) {
    this.groupNames = [];
  }
  if (this.groupNames.length > 0) {
    this.groupName = saveHelper.getCurrentBuild();
  } else {
    this.groupName = null;
  }

  if (!this.groupName || !(this.groupName in this.savedItems)) {
    if (this.groupNames.length > 0) {
      this.groupName = this.groupNames[0];
    }
  }

  if (!this.groupName) {
    // console.log('cannot find build');
    return;
  }

  this.getGroupCalcStats = function () {
    if (this.groupCalcStats == null) {
      var group = vm.savedItems[vm.groupName];
      if (group) {
        this.groupCalcStats = statHelper.getCalculatedStatsFromItems(group, group.items);
      }
    }

    return this.groupCalcStats;
  };

  this.getBuild = function () {
    return vm.savedItems[vm.groupName];
  };

  this.pickup = function (index) {
    vm.selectedIndex = index;

    vm.replaceHPAffectAmount = [];
    vm.replaceMDmgAffectAmount = [];
    vm.replacePDmgAffectAmount = [];
    vm.replaceAvgDmgAffectAmount = [];
  };

  function saveGroup() {
    saveHelper.saveBuildSelection(vm.groupName, vm.savedItems);
  }

  this.headers = ['+100%', '+75%', '+25%', '+0%'];

  this.summaryStatIds = [];
  for (var id in hCodeValues.stats) {
    if (hCodeValues.stats[id].summaryDisplay) {
      this.summaryStatIds.push(id);
    }
  }

  this.pcIndexes = {};
  this.pcIndexes['100'] = 0;
  this.pcIndexes['75'] = 1;
  this.pcIndexes['25'] = 2;
  this.pcIndexes['0'] = 3;

  this.selectedIndex = -1;

  this.rows = [];

  this.updateRows = function () {
    vm.rows = [];

    angular.forEach(vm.savedItems[vm.groupName].items, function (item, index) {
      if (item.typeName == 'talisman') {
        var pcIndex = vm.pcIndexes[item.enchantmentNum];
        if (!pcIndex && pcIndex != 0) {
          pcIndex = 3;
        }

        var rowIndex = 0;
        for (;;) {
          if (!vm.rows[rowIndex]) {
            vm.rows[rowIndex] = vm.makeFakeCells();
          }

          if (vm.rows[rowIndex][pcIndex].index < 0) {
            if (!item.enchantmentNum) {
              item.enchantmentNum = 0;
            }

            var data = vm.makeCell(item, index);
            vm.rows[rowIndex][pcIndex] = data;
            break;
          } else {
            rowIndex++;
          }
        }
      }
    });

    if (vm.rows.length < 3) {
      vm.rows[vm.rows.length + 1] = vm.makeFakeCells();
    }
  };

  this.makeFakeCells = function (num) {
    return [vm.makeCell({ enchantmentNum: 100 }, -1), vm.makeCell({ enchantmentNum: 75 }, -2), vm.makeCell({ enchantmentNum: 25 }, -3), vm.makeCell({ enchantmentNum: 0 }, -4)];
  };

  this.makeCell = function (item, index) {
    return { item: item, index: index };
  };

  this.click = function (col) {
    if (vm.selectedIndex == -1) {
      if (col.index >= 0) {
        vm.pickup(col.index);
      }
    } else {
      vm.move(col);
    }
  };

  this.move = function (col) {

    var items = vm.savedItems[vm.groupName].items;
    if (col.index >= 0) {
      var swapEnchantmentNumber = col.item.enchantmentNum;

      vm.setTalisman(col.item, items[vm.selectedIndex].enchantmentNum);
      vm.setTalisman(items[vm.selectedIndex], swapEnchantmentNumber);
      items[col.index] = items[vm.selectedIndex];
      items[vm.selectedIndex] = col.item;
    } else {
      var item = items[vm.selectedIndex];
      vm.setTalisman(item, col.item.enchantmentNum);
      items.splice(vm.selectedIndex, 1);
      items.push(item);
    }

    vm.groupCalcStats = null;
    vm.selectedIndex = -1;
    vm.updateRows();
    vm.replaceAffectAmount = {};
    $timeout();
  };

  this.setTalisman = function (item, newEnhancementNum) {
    var extraStats = [];
    angular.forEach(item.stats, function (stat, index) {
      if (newEnhancementNum) {
        extraStats.push({ id: stat.id, max: stat.max * (newEnhancementNum / 100) });
      }
    });

    item.enchantmentStats = extraStats;
    item.enchantmentNum = newEnhancementNum;

    item.fullStats = hCodeValues.mergeStats(item.enchantmentStats, item.stats);
  };

  this.replaceAffectAmount = {};
  this.getReplaceAffectAmount = function (statId, itemIndex, item) {
    this.initReplaceAffects(itemIndex, item);
    if (this.replaceAffectAmount[itemIndex]) {
      return this.replaceAffectAmount[itemIndex][statId];
    }
  };

  this.initReplaceAffects = function (itemIndex, item) {
    if (vm.replaceAffectAmount[itemIndex] || vm.selectedIndex == -1) {
      return;
    }
    this.replaceAffectAmount[itemIndex] = {};

    var group = vm.savedItems[vm.groupName];
    var item2 = group.items[vm.selectedIndex];

    var extraStats = [];
    var fullStats1 = [];
    if (item.stats) {
      angular.forEach(item.stats, function (stat, index) {
        extraStats.push({ id: stat.id, max: stat.max * (item2.enchantmentNum / 100) });
      });
      fullStats1 = hCodeValues.mergeStats(extraStats, item.stats);
    }

    extraStats = [];
    angular.forEach(item2.stats, function (stat, index) {
      extraStats.push({ id: stat.id, max: stat.max * (item.enchantmentNum / 100) });
    });
    var fullStats2 = hCodeValues.mergeStats(extraStats, item2.stats);

    var newItems = [{ stats: fullStats1 }, { stats: fullStats2 }];
    angular.forEach(group.items, function (gItem, index) {
      if (item !== gItem && item2 !== gItem) {
        newItems.push(gItem);
      }
    });

    var newStats = statHelper.getCalculatedStatsFromItems(group, newItems);
    var origStats = vm.getGroupCalcStats();

    for (var id in hCodeValues.stats) {
      if (hCodeValues.stats[id].summaryDisplay) {
        vm.replaceAffectAmount[itemIndex][id] = calcStatPercent(vm.getStat(id, newStats).max, vm.getStat(id, origStats).max);
      }
    }
  };

  this.getStatName = function (id) {
    var retVal = '';
    if (hCodeValues.stats[id].element == 'primary') {
      var eleId = 0;
      if (vm.savedItems[vm.groupName].element) {
        eleId = vm.savedItems[vm.groupName].element.id;
      }
      retVal += hCodeValues.elements[eleId].name;
    } else if (hCodeValues.stats[id].element == 'secondary') {
      var eleId = 0;
      if (vm.savedItems[vm.groupName].secondaryElement) {
        eleId = vm.savedItems[vm.groupName].secondaryElement.id;
      }
      retVal += hCodeValues.elements[eleId].name;
    }
    return retVal + ' ' + hCodeValues.stats[id].name;
  };

  this.getStat = function (id, stats) {
    var len = stats.length;
    for (var i = 0; i < len; ++i) {
      if (stats[i].id == id) {
        return stats[i];
      }
    }
    return { id: id, max: 0 };
  };

  function calcStatPercent(newVal, origVal) {
    if (newVal && origVal) {
      return Math.round(10000 * (1 - origVal / newVal)) / 100;
    } else {
      return 0;
    }
  }

  this.save = function () {
    saveHelper.updatedSavedItems(vm.groupName, vm.savedItems[vm.groupName].items);
    $location.path('/build');
    $location.search('buildName', vm.groupName);
  };

  this.updateRows();
}]);
"use strict";

bulidController.$inject = ["$timeout", "statHelper", "itemCategory", "saveHelper"];angular.module('dnsim').directive('dngearsimBuild', function () {
  return {
    scope: true,
    bindToController: {
      buildName: '=buildName',
      build: '=build',
      onChange: '&onChange',
      server: '=server'
    },
    controller: bulidController,
    controllerAs: 'buildCtrl',
    templateUrl: 'ui/builds/build.html'
  };
});

function bulidController($timeout, statHelper, itemCategory, saveHelper) {
  'use strict';

  var vm = this;

  vm.stats = statHelper.getBuildStats(vm.build);

  var selectedCategory = localStorage.getItem('selectedItemCategory');
  vm.category = itemCategory.byName(selectedCategory);
  if (!vm.category || vm.category.hideInBuild) {
    selectedCategory = 'titles';
    vm.category = itemCategory.byName('titles');
  }

  vm.getCategoryItems = function () {
    var itemsByCat = itemCategory.getItemsByCategory(vm.build.items);
    if (vm.category.name in itemsByCat) {
      return itemsByCat[vm.category.name];
    } else {
      return [];
    }
  };

  vm.changeCategory = function () {
    vm.xsView = null;
    vm.moveItem = null;
    vm.categoryChanging = true;
    $timeout(function () {
      vm.categoryChanging = false;
    }, 0);
  };

  vm.getCategories = function () {
    return itemCategory.categories;
  };

  vm.setSelectedCategory = function (value) {
    vm.category = itemCategory.byName(value);
    localStorage.setItem('selectedItemCategory', value);
  };

  vm.getSaveDate = function (group) {
    if (vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleDateString();
    }
  };

  vm.getSaveTime = function (group) {
    if (vm.build.lastUpdate > 0) {
      var lastUpdate = new Date(vm.build.lastUpdate);
      return lastUpdate.toLocaleTimeString();
    }
  };

  vm.allowMoreItems = function () {
    return !vm.category.maxCat || vm.getCategoryItems().length < vm.category.maxCat;
  };

  vm.getItemCount = function () {
    var itemCountText = '';
    var allItems = vm.build.items;

    if (vm.category.name == 'offensive gems') {
      var numOffensiveSlots = 0;
      var numOffensiveGems = 0;
      angular.forEach(allItems, function (item, index) {
        if (item.typeName == vm.category.name) {
          numOffensiveGems++;
        } else if (item.offensiveGemSlots) {
          numOffensiveSlots += item.offensiveGemSlots;
        }
      });

      itemCountText = numOffensiveGems + ' / ' + numOffensiveSlots;
    } else if (vm.category.name == 'increasing gems') {

      var totalIncreasingGems = 0;
      var numIncreasingSlots = 0;
      var numIncreasingGems = {};
      angular.forEach(allItems, function (item, index) {
        if (item.typeName == vm.category.name) {
          var gemType = item.sparkTypeId;
          if (!gemType) {
            gemType = 0;
          }

          if (!(gemType in numIncreasingGems)) {
            numIncreasingGems[gemType] = 0;
          }
          numIncreasingGems[gemType]++;
          totalIncreasingGems++;
        } else if (item.increasingGemSlots) {
          numIncreasingSlots += item.increasingGemSlots;
        }
      });

      itemCountText = '';
      angular.forEach(numIncreasingGems, function (number, gemType) {
        if (itemCountText.length > 0) {
          itemCountText += '+';
        }
        itemCountText += number;
      });

      itemCountText = totalIncreasingGems + ' (' + itemCountText + ') / ' + numIncreasingSlots;
    } else {
      var numItems = 0;
      angular.forEach(allItems, function (item, index) {
        if (item && item.typeName == vm.category.name) {
          numItems++;
        }
      });

      itemCountText = numItems;
      var cat = itemCategory.byName(vm.category.name);
      if (cat && 'numItemText' in cat) {
        itemCountText += ' / ' + cat.numItemText;
      }
    }

    return itemCountText;
  };

  vm.newCustom = function () {
    var newCustom = { id: 0, typeName: 'custom', name: 'new custom item', stats: [] };
    vm.build.items = vm.build.items.concat(newCustom);
    saveHelper.updatedSavedItems(vm.buildName, vm.build.items);
    vm.handleChange();
  };

  vm.handleChange = function () {
    vm.stats = statHelper.getBuildStats(vm.build);
    vm.onChange();
  };
}
'use strict';

angular.module('dnsim').controller('DeleteBuildCtrl', ['$location', '$routeParams', '$timeout', 'saveHelper', 'dntData', 'jobs', 'hCodeValues', 'itemColumnsToLoad', function ($location, $routeParams, $timeout, saveHelper, dntData, jobs, hCodeValues, itemColumnsToLoad) {
  'use strict';

  var vm = this;
  this.newGroup = true;
  if ('name' in $routeParams) {
    this.name = $routeParams.name;
  }

  this.delete = function () {
    saveHelper.deleteBuild(this.name);
    $location.path('/builds/');
  };
}]);
"use strict";

(function () {
  'use strict';

  editBuildCtrl.$inject = ["$window", "$location", "$routeParams", "$timeout", "saveHelper", "dntData", "jobs", "hCodeValues", "itemColumnsToLoad", "character", "region"];
  angular.module('dnsim').controller('EditBuildCtrl', editBuildCtrl);

  function editBuildCtrl($window, $location, $routeParams, $timeout, saveHelper, dntData, jobs, hCodeValues, itemColumnsToLoad, character, region) {
    'use strict';

    var vm = this;
    vm.savedItems = saveHelper.getSavedItems();
    vm.group = {};
    vm.newGroup = true;
    if ('buildName' in $routeParams) {
      vm.groupName = $routeParams.buildName;
      if (vm.groupName in vm.savedItems) {
        vm.group = vm.savedItems[vm.groupName];
        vm.newGroup = false;
      }
    } else {
      vm.groupName = '';
    }
    vm.oldGroupName = vm.groupName;
    vm.heroStats = [];
    vm.elements = hCodeValues.elements;
    vm.damageTypes = hCodeValues.damageTypes;

    vm.initDamageType = function () {
      if (vm.job) {
        if (vm.group.damageType) {
          vm.damageType = vm.group.damageType;
        } else if (vm.newGroup && 'DamageType' in vm.job.d) {
          if (vm.job.d.DamageType) {
            vm.damageType = hCodeValues.damageTypes[2];
          } else {
            vm.damageType = hCodeValues.damageTypes[1];
          }
        } else {
          vm.damageType = hCodeValues.damageTypes[0];
        }
      }
    };

    vm.initDefaultElement = function () {
      var defaultElement = hCodeValues.elements[0];
      var defaultSecondaryElement = hCodeValues.elements[0];

      if (vm.job && vm.job.d) {
        var jobName = vm.job.d.EnglishName;
        if (jobName == 'CRUSADES' || jobName == 'INQUISITOR' || jobName == 'GUARDIAN' || jobName == 'SAINT' || jobName == 'SILVERHUNTER' || jobName == 'STINGBREEZER') {
          defaultElement = hCodeValues.elements[3];
          defaultSecondaryElement = hCodeValues.elements[3];
        } else if (jobName == 'RAVEN' || jobName == 'MAJESTY' || jobName == 'SOULEATER' || jobName == 'DARKSUMMONER' || jobName == 'ABYSSWALKER' || jobName == 'BLACKMARA' || jobName == 'PHYSICIAN') {
          defaultElement = hCodeValues.elements[4];
          defaultSecondaryElement = hCodeValues.elements[4];
        } else if (jobName == 'SALEANA' || jobName == 'RIPPER' || jobName == 'DARKAVENGER') {
          defaultElement = hCodeValues.elements[1];
          defaultSecondaryElement = hCodeValues.elements[1];
        } else if (jobName == 'ELESTRA') {
          defaultElement = hCodeValues.elements[2];
          defaultSecondaryElement = hCodeValues.elements[2];
        } else if (jobName == 'ADEPT') {
          defaultElement = hCodeValues.elements[1];
          defaultSecondaryElement = hCodeValues.elements[2];
        } else if (jobName == 'LIGHTFURY') {
          defaultElement = hCodeValues.elements[3];
          defaultSecondaryElement = hCodeValues.elements[4];
        }
      }

      if (vm.newGroup) {
        vm.element = defaultElement;
        vm.secondaryElement = defaultSecondaryElement;
      }

      if (!vm.element) {
        vm.element = defaultElement;
      }

      if (!vm.secondaryElement) {
        vm.secondaryElement = defaultElement;
      }
    };

    if (vm.group.element) {
      vm.element = vm.group.element;
    } else {
      vm.element = hCodeValues.elements[0];
    }

    if (vm.group.secondaryElement) {
      vm.secondaryElement = vm.group.secondaryElement;
    } else {
      vm.secondaryElement = hCodeValues.elements[0];
    }

    if (!('critResist' in vm.group)) {
      vm.critResist = 20;
    } else {
      vm.critResist = vm.group.critResist;
    }

    if (!('eleResist' in vm.group)) {
      vm.eleResist = 0;
    } else {
      vm.eleResist = vm.group.eleResist;
    }

    if (vm.group.enemyLevel) {
      vm.enemyLevel = vm.group.enemyLevel;
    } else {
      vm.enemyLevel = 93;
    }

    if (vm.group.playerLevel) {
      vm.playerLevel = vm.group.playerLevel;
    } else {
      vm.playerLevel = 93;
    }

    if (vm.group.heroLevel && vm.group.heroLevel > 0) {
      vm.heroLevel = vm.group.heroLevel;
    } else {
      vm.heroLevel = 1;
    }

    vm.init = function () {
      var newJobs = jobs.getFinalJobs();
      if (newJobs.length > 0) {
        $timeout(function () {

          if ('job' in vm.group) {
            angular.forEach(newJobs, function (value, key) {
              if (value.id == vm.group.job.id) {
                vm.job = value;
              }
            });
          }

          vm.initDamageType();
          vm.initDefaultElement();
          vm.setHeroStats();
        });
      }
    };

    vm.setJob = function () {
      $window.scrollTo(0, 0);
      $timeout(function () {
        vm.initDamageType();
        vm.initDefaultElement();
      });
    };

    region.init();
    character.init(function () {
      vm.init();
    });

    vm.getStatCap = function (colName, useLevel) {
      return character.getStatCaps(useLevel)[colName];
    };
    vm.getJobConversion = function (colName) {
      return character.getConversions(vm.job.id)[colName];
    };
    vm.getJobBaseStat = function (colName) {
      return character.getBaseStats(vm.playerLevel, vm.job.id)[colName];
    };

    vm.invalidGroupName = function () {
      if (!vm.groupName) {
        return true;
      }

      if (vm.groupName in vm.savedItems) {
        if (vm.newGroup || vm.groupName != vm.oldGroupName) {
          return true;
        }
      }

      return false;
    };

    vm.ok = function () {
      var enemyStatCaps = character.getStatCaps(vm.enemyLevel);
      var playerStatCaps = character.getStatCaps(vm.playerLevel);
      var conversions = character.getConversions(vm.job.id);
      var baseStats = character.getBaseStats(vm.playerLevel, vm.job.id);
      var heroStats = character.getHeroStats(vm.heroLevel);

      if (vm.newGroup) {
        vm.oldGroupName = vm.groupName;
        saveHelper.importGroup(vm.groupName, []);
      }

      saveHelper.saveBuild(vm.oldGroupName, vm.groupName, {
        enemyLevel: vm.enemyLevel,
        playerLevel: vm.playerLevel,
        heroLevel: vm.heroLevel,
        job: vm.job,
        damageType: vm.damageType,
        element: vm.element,
        secondaryElement: vm.secondaryElement,
        critResist: vm.critResist,
        eleResist: vm.eleResist,
        enemyStatCaps: enemyStatCaps,
        playerStatCaps: playerStatCaps,
        conversions: conversions,
        baseStats: baseStats,
        heroStats: heroStats
      });

      $location.path('/build');
      $location.search('buildName', vm.groupName);
    };

    vm.setHeroStats = function () {
      vm.heroStats = character.getHeroStats(vm.heroLevel);
      // console.log('got ' + vm.heroStats.length + ' hero stats');
    };

    $timeout(function () {
      var input = document.getElementById('groupNameInput');
      if (input) {
        input.focus();
        input.setSelectionRange(0, 9999);
      }
    });
  }
})();
'use strict';

angular.module('dnsim').controller('quickAddCtrl', ['$timeout', 'statHelper', 'saveHelper', 'quickAdd', 'itemCategory', 'jobs', 'dntData', 'exportLinkHelper', function ($timeout, statHelper, saveHelper, quickAdd, itemCategory, jobs, dntData, exportLinkHelper) {
  'use strict';

  var vm = this;
  vm.startedForCat = '';
  vm.stepNumber = 0;
  vm.datas = [];
  vm.options = [];

  this.setOptions = function () {
    if (vm.hasStarted()) {
      vm.options = quickAdd.getOptions(vm.category, vm.build, vm.datas);
      if (vm.options.length == 1) {
        vm.selectOption(vm.options[0]);
      }
    }
  };

  this.selectOption = function (value) {
    var data = quickAdd.createData(value, vm.category, vm.stepNumber);
    vm.datas.push(data);
    vm.stepNumber++;
    if (!quickAdd.isValidStepNumber(vm.category, vm.stepNumber)) {

      var newItem = quickAdd.getItem(vm.datas);
      var dntFiles = exportLinkHelper.getDntFiles(newItem);
      angular.forEach(dntFiles, function (columns, fileName) {
        dntData.init(fileName, columns, function () {}, function () {
          vm.tryToAddItem(dntFiles, newItem);
        });
      });
      vm.tryToAddItem(dntFiles, newItem);
    } else {
      vm.setOptions();
      // console.log('setup next step');
    }
  };

  this.tryToAddItem = function (dntFiles, item) {
    if (!dntData.anyLoading()) {

      var allLoaded = true;
      angular.forEach(dntFiles, function (columns, fileName) {
        if (!dntData.isLoaded(fileName)) {
          allLoaded = false;
        }
      });

      if (allLoaded) {
        if (vm.datas.length > 0) {
          vm.cancel();
          var newItem = exportLinkHelper.reloadItem(item);
          newItem.gemSlot = vm.gemSlot;
          saveHelper.saveItem(vm.buildName, newItem);
          vm.build.items.push(newItem);
          vm.onChange();
        }
      }
    }
  };

  this.reset = function () {
    vm.stepNumber = 0;
    vm.datas = [];
    $timeout(function () {
      vm.setOptions();
    });
  };

  this.hasStarted = function () {
    return vm.startedForCat == vm.category.name;
  };

  this.start = function () {
    vm.startedForCat = vm.category.name;

    jobs.init(function () {}, vm.reset);
    itemCategory.init(vm.category.name, vm.reset);
  };

  this.hasOptions = function () {
    return quickAdd.hasOptions(vm.category, vm.build, []);
  };

  this.cancel = function () {
    vm.startedForCat = '';
    vm.reset();
  };

  this.back = function () {
    if (vm.stepNumber == 0) {
      vm.cancel();
    } else {
      do {
        vm.stepNumber--;
        vm.datas.pop();

        var testOptions = quickAdd.getOptions(vm.category, vm.build, vm.datas);
      } while (testOptions.length <= 1 && vm.stepNumber > 0);

      vm.setOptions();
    }
  };
  dntData.init('exchange.lzjson', null, function () {}, vm.reset);
}]).directive('dngearsimQuickAdd', function () {
  return {
    scope: true,
    bindToController: {
      category: '=category',
      build: '=build',
      buildName: '=buildName',
      gemSlot: '=gemSlot',
      onChange: '&onChange'
    },
    controller: 'quickAddCtrl',
    controllerAs: 'quickAdd',
    templateUrl: 'ui/builds/quick-add.html'
  };
});
'use strict';

angular.module('dnsim').controller('ReloadBuildCtrl', ['$location', '$routeParams', '$timeout', 'saveHelper', 'dntData', 'dntReset', 'groupHelper', 'translations', reloadBuildCtrl]);

function reloadBuildCtrl($location, $routeParams, $timeout, saveHelper, dntData, dntReset, groupHelper, translations) {
  'use strict';

  var vm = this;
  if ('name' in $routeParams) {
    vm.name = $routeParams.name;
  }

  var savedItems = saveHelper.getSavedItems();
  if (vm.name in savedItems) {
    vm.build = savedItems[vm.name];
  }

  vm.reloaded = false;
  vm.reload = function () {
    dntReset();
    vm.reloaded = false;

    translations.init(progress, tryInit);

    var files = groupHelper.getDntFiles(vm.build);
    angular.forEach(files, function (columns, fileName) {
      dntData.init(fileName, columns, progress, tryInit);
    });
  };

  vm.goToBuild = function () {
    $location.path('/build');
    $location.search('buildName', vm.name);
  };

  function progress() {}

  function tryInit() {
    if (vm.reloaded) {
      return;
    }

    var allLoaded = true;
    var files = groupHelper.getDntFiles(vm.build);
    angular.forEach(files, function (columns, fileName) {
      if (!dntData.isLoaded(fileName)) {
        allLoaded = false;
        return;
      }
    });

    if (allLoaded && translations.isLoaded()) {
      var newItems = groupHelper.reloadGroup(vm.name, vm.build);
      saveHelper.updatedSavedItems(vm.name, newItems);
      vm.build.items = newItems;

      vm.reloaded = true;
    }
  }
}
'use strict';

angular.module('dnsim').controller('ViewGroupCtrl', ['$scope', '$window', 'region', '$location', '$routeParams', 'saveHelper', 'dntData', '$timeout', 'translations', 'dntReset', 'exportLinkHelper', 'groupHelper', 'jobs', 'character', 'statHelper', 'hCodeValues', function ($scope, $window, region, $location, $routeParams, saveHelper, dntData, $timeout, translations, dntReset, exportLinkHelper, groupHelper, jobs, character, statHelper, hCodeValues) {
  'use strict';

  document.body.className = 'saved-back';

  region.setLocationByName($routeParams.region);

  $scope.buildName = '';
  $scope.build = {};

  if ('g' in $routeParams && 'i' in $routeParams) {
    $scope.buildName = $routeParams.g;
    $window.document.title = 'dngearsim | ' + $routeParams.g;

    $scope.enemyLevel = $routeParams.e;
    $scope.playerLevel = $routeParams.p;
    $scope.heroLevel = $routeParams.h;
    $scope.job = { id: $routeParams.j };
    $scope.damageType = hCodeValues.damageTypes[$routeParams.d];
    $scope.element = hCodeValues.elements[$routeParams.t];
    $scope.secondaryElement = hCodeValues.elements[$routeParams.s];

    var items = [];

    var itemString = $routeParams.i;

    angular.forEach(itemString.split(','), function (itemStr, index) {
      var item = exportLinkHelper.decodeItem(itemStr);

      if (item.id > 0) {
        items.push(item);
      }
    });

    $scope.build = {};
    $scope.savedItems = {};
    $scope.savedItems[$scope.buildName] = $scope.build;
    $scope.build.items = items;
    $scope.isLoading = true;

    angular.forEach(groupHelper.getDntFiles($scope.build), function (columns, fileName) {
      dntData.init(fileName, columns, progress, tryInit);
    });

    translations.init(progress, tryInit);
    jobs.init(progress, tryInit);
    character.init(tryInit);

    $timeout();
  }

  $scope.anyItems = Object.keys($scope.savedItems).length > 0;

  function tryInit() {

    var allInit = true;
    angular.forEach(groupHelper.getDntFiles($scope.build), function (columns, fileName) {
      if (!dntData.isLoaded(fileName)) {
        allInit = false;
      }
    });

    if (!allInit || dntData.anyLoading() || !translations.isLoaded() || !jobs.isLoaded()) {
      return;
    }

    $timeout(function () {
      var groupName = $scope.buildName;
      var group = $scope.build;

      $scope.job = jobs.getById($scope.job.id);

      $scope.enemyStatCaps = character.getStatCaps($scope.enemyLevel);
      $scope.playerStatCaps = character.getStatCaps($scope.playerLevel);
      if ($scope.job) {
        $scope.conversions = character.getConversions($scope.job.id);
        $scope.baseStats = character.getBaseStats($scope.playerLevel, $scope.job.id);
      }
      $scope.heroStats = character.getHeroStats($scope.heroLevel);

      var newItems = groupHelper.reloadGroup(groupName, group);

      $scope.savedItems = {};
      $scope.build = {
        items: newItems,
        lastUpdate: group.lastUpdate,

        enemyLevel: $scope.enemyLevel,
        playerLevel: $scope.playerLevel,
        heroLevel: $scope.heroLevel,
        job: $scope.job,
        damageType: $scope.damageType,
        element: $scope.element,
        secondaryElement: $scope.secondaryElement,
        enemyStatCaps: $scope.enemyStatCaps,
        playerStatCaps: $scope.playerStatCaps,
        conversions: $scope.conversions,
        baseStats: $scope.baseStats,
        heroStats: $scope.heroStats
      };
      $scope.savedItems[groupName] = $scope.build;
      $scope.stats = statHelper.getBuildStats($scope.build);

      var longUrl = exportLinkHelper.createGroupLink($scope.buildName, $scope.build);
      $scope.build.shortUrl = sessionStorage.getItem(longUrl);
    });
  }

  function progress() {}

  $scope.copyGroup = function () {
    var newBuildName = saveHelper.importGroup($scope.buildName, $scope.build.items);
    // console.log('copying in as ' + newBuildName);

    saveHelper.saveBuild(newBuildName, newBuildName, {
      enemyLevel: $scope.enemyLevel,
      playerLevel: $scope.playerLevel,
      heroLevel: $scope.heroLevel,
      job: $scope.job,
      damageType: $scope.damageType,
      element: $scope.element,
      secondaryElement: $scope.secondaryElement,
      critResist: $scope.critResist,
      eleResist: $scope.eleResist,
      enemyStatCaps: $scope.enemyStatCaps,
      playerStatCaps: $scope.playerStatCaps,
      conversions: $scope.conversions,
      baseStats: $scope.baseStats,
      heroStats: $scope.heroStats
    });

    $location.url('/build?buildName=' + newBuildName);
  };
}]);
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').filter('escape', [function () {
    'use strict';

    function escapeFilter(input) {
      if (input) {
        return window.encodeURIComponent(input);
      }
      return '';
    }

    return escapeFilter;
  }]);
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').filter('percentage', [function () {
    'use strict';

    function percentageFilter(input) {
      if (typeof input == 'number') {
        return Math.round(input * 100 * 100) / 100 + '%';
      } else {
        return input;
      }
    }
    percentageFilter.$stateful = false;

    return percentageFilter;
  }]);
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').controller('AboutCtrl', ['$window', function ($window) {
    'use strict';

    document.body.className = 'default-back';
    $window.document.title = 'dngearsim | ABOUT/FAQ';
  }]);
})();
"use strict";

(function () {
  'use strict';

  groupAssignment.$inject = ["hCodeValues", "statHelper", "saveHelper", "itemCategory", "$scope", "exportLinkHelper", "dntData"];
  angular.module('dnsim').directive('dngearsimGroupAssignment', function () {
    return {
      scope: true,
      bindToController: {
        item: '=item',
        compact: '=compact',
        onChange: '&onChange'
      },
      controller: groupAssignment,
      controllerAs: 'editCtrl',
      templateUrl: 'ui/item/group-assignment.html'
    };
  });

  function groupAssignment(hCodeValues, statHelper, saveHelper, itemCategory, $scope, exportLinkHelper, dntData) {

    var vm = this;

    this.savedItems = saveHelper.getSavedItems();
    this.groupNames = Object.keys(this.savedItems);
    if (!this.groupName) {
      this.groupName = saveHelper.getCurrentBuild();
    }

    if (!(this.groupName in this.savedItems)) {
      this.groupName = null;
    }

    if (!this.groupName && this.savedItems) {
      for (var savedGroup in this.savedItems) {
        this.groupName = savedGroup;
        break;
      }
    }

    if (!this.groupName) {
      return;
    }

    this.summaryStatIds = [];
    for (var id in hCodeValues.stats) {
      if (hCodeValues.stats[id].summaryDisplay) {
        this.summaryStatIds.push(id);
      }
    }

    this.clearGroup = function () {
      vm.addAffectAmount = null;
      vm.replaceAffectAmount = {};

      vm.groupItems = null;
      vm.groupCalcStats = null;
    };

    vm.tryToSetItem = function (dntFiles) {
      if (!dntData.anyLoading()) {

        var allLoaded = true;
        angular.forEach(dntFiles, function (columns, fileName) {
          if (!dntData.isLoaded(fileName)) {
            allLoaded = false;
          }
        });

        if (allLoaded) {
          vm.item = exportLinkHelper.reloadItem(vm.item);
        }
      }
    };

    var dntFiles = exportLinkHelper.getDntFiles(vm.item);
    angular.forEach(dntFiles, function (columns, fileName) {
      dntData.init(fileName, columns, function () {}, function () {
        vm.tryToSetItem(dntFiles);
      });
    });
    vm.tryToSetItem(dntFiles);

    $scope.$watch('editCtrl.item', function () {
      vm.clearGroup();
    });

    this.getAddAffectAmount = function (stat) {
      this.initAddAffects();
      // console.log('add affect: ', this.addAffectAmount[stat], this.item);
      return this.addAffectAmount[stat];
    };

    this.getReplaceAffectAmount = function (statId, itemIndex, item) {
      this.initReplaceAffects(itemIndex, item);
      return this.replaceAffectAmount[itemIndex][statId];
    };

    this.getGroupCalcStats = function () {

      if (this.groupCalcStats == null) {

        var group = vm.savedItems[vm.groupName];
        if (group) {
          this.groupCalcStats = statHelper.getCalculatedStatsFromItems(group, group.items);
        }
      }

      return this.groupCalcStats;
    };

    this.getBuild = function () {
      return vm.savedItems[vm.groupName];
    };

    this.initAddAffects = function () {

      if (vm.addAffectAmount) {
        return;
      }

      // console.log('initialising add affects ');

      var origStats = vm.getGroupCalcStats();
      var group = vm.savedItems[vm.groupName];
      var newItems = [];
      if (group.items) {
        newItems = group.items.concat([vm.item]);
      }
      var newStats = statHelper.getCalculatedStatsFromItems(group, newItems);

      this.addAffectAmount = {};
      for (var id in hCodeValues.stats) {
        if (hCodeValues.stats[id].summaryDisplay) {
          vm.addAffectAmount[id] = calcStatPercent(vm.getStat(id, newStats).max, vm.getStat(id, origStats).max);
        }
      }
    };

    this.initReplaceAffects = function (itemIndex, item) {
      if (vm.replaceAffectAmount[itemIndex]) {
        return;
      }

      var group = vm.savedItems[vm.groupName];
      var newItems = [vm.item];
      angular.forEach(group.items, function (gItem, index) {
        if (item !== gItem) {
          newItems.push(gItem);
        }
      });

      var newStats = statHelper.getCalculatedStatsFromItems(group, newItems);
      var origStats = vm.getGroupCalcStats();

      this.replaceAffectAmount[itemIndex] = {};
      for (var id in hCodeValues.stats) {
        if (hCodeValues.stats[id].summaryDisplay) {
          vm.replaceAffectAmount[itemIndex][id] = calcStatPercent(vm.getStat(id, newStats).max, vm.getStat(id, origStats).max);
        }
      }
    };

    function calcStatPercent(newVal, origVal) {
      if (newVal && origVal) {
        // console.log('orig: ' + origVal + ',new: ' + newVal);
        return Math.round(10000 * (1 - origVal / newVal)) / 100;
      } else {
        return 0;
      }
    }

    this.getStat = function (id, stats) {
      var len = stats.length;
      for (var i = 0; i < len; ++i) {
        if (stats[i].id == id) {
          return stats[i];
        }
      }
      return { id: id, max: 0 };
    };

    this.getStatName = function (id) {
      var retVal = '';
      if (hCodeValues.stats[id].element == 'primary') {
        var eleId = 0;
        if (vm.savedItems[vm.groupName].element) {
          eleId = vm.savedItems[vm.groupName].element.id;
        }
        retVal += hCodeValues.elements[eleId].name;
      } else if (hCodeValues.stats[id].element == 'secondary') {
        var eleId = 0;
        if (vm.savedItems[vm.groupName].secondaryElement) {
          eleId = vm.savedItems[vm.groupName].secondaryElement.id;
        }
        retVal += hCodeValues.elements[eleId].name;
      }
      return retVal + ' ' + hCodeValues.stats[id].name;
    };

    this.getGroupItems = function () {

      var itemSplit;
      function numMatches(str) {
        if (str) {
          var matches = 0;
          for (var i = 0; i < itemSplit.length; ++i) {
            if (str.indexOf(itemSplit[i]) > 0) {
              matches++;
            }
          }
          return matches;
        } else {
          return -1;
        }
      }

      if (vm.groupItems == null && vm.groupName && vm.groupName in vm.savedItems && vm.item && vm.item.typeName) {
        vm.groupItems = [];

        var existing;
        if (vm.item.itemSource == 'plate' || vm.item.itemSource == 'tman') {
          existing = _.find(vm.savedItems[vm.groupName].items, function (item) {
            return item.sparkTypeId == vm.item.sparkTypeId && vm.item.itemSource == item.itemSource;
          });
        }

        var items = [];
        if (existing) {
          items.push(existing);
        } else {
          _.each(vm.savedItems[vm.groupName].items, function (item) {
            if (item.exchangeType && item.itemSource != 'gem' && item.itemSource != 'plate' && item.itemSource != 'tman') {
              if (item.exchangeType == vm.item.exchangeType) {
                items.push(item);
              }
            } else if (item.typeName == vm.item.typeName) {
              items.push(item);
            }
          });

          if (vm.item.name) {
            itemSplit = vm.item.name.split(' ');
          }
          items.sort(function (a, b) {
            return numMatches(b.name) - numMatches(a.name);
          });
        }

        angular.forEach(items, function (item, index) {
          if (item.name == vm.item.name) {
            vm.groupItems.push(item);
          }
        });

        angular.forEach(items, function (item, index) {
          if (item.name != vm.item.name) {
            vm.groupItems.push(item);
          }
        });
      }
      return vm.groupItems;
    };

    this.hasMaxExchangable = function () {
      var cat = itemCategory.byName(this.item.typeName);
      var items = this.getGroupItems();

      if (vm.item.itemSource == 'plate' || vm.item.itemSource == 'tman') {
        if (_.find(items, function (item) {
          return item.sparkTypeId == vm.item.sparkTypeId;
        })) {
          return true;
        }
      }

      if (cat && cat.maxCat) {
        if (items.length >= cat.maxCat) {
          return true;
        }
      }

      if (cat && cat.maxExchange) {
        if (items.length >= cat.maxExchange) {
          for (var i = 0; i < items.length; ++i) {
            if (!items[i].exchangeType) {
              return false;
            }
          }
          // console.log('maxexchange reached ' + items.length + '>=' + cat.maxExchange + ' for ' + cat.name);
          return true;
        }
      }
      return false;
    };

    this.nextGroup = function () {

      var uptoItem = false;
      var nextGroup = null;
      angular.forEach(vm.groupNames, function (groupName, index) {
        if (uptoItem) {
          if (nextGroup == null) {
            nextGroup = groupName;
          }
        }
        if (groupName == vm.groupName) {
          uptoItem = true;
        }
      });

      if (nextGroup == null) {
        nextGroup = vm.groupNames[0];
      }

      vm.groupName = nextGroup;
      saveGroup();
      vm.clearGroup();
    };

    this.prevGroup = function () {

      var foundGroup = false;
      var prevGroup = null;
      angular.forEach(vm.groupNames, function (groupName, index) {
        if (groupName == vm.groupName) {
          foundGroup = true;
        }

        if (!foundGroup) {
          prevGroup = groupName;
        }
      });

      if (prevGroup == null) {
        prevGroup = vm.groupNames[vm.groupNames.length - 1];
      }

      vm.groupName = prevGroup;
      saveGroup();
      vm.clearGroup();
    };

    this.addToGroup = function () {
      saveHelper.saveItem(vm.groupName, vm.item);
      this.savedItems = saveHelper.getSavedItems();
      vm.clearGroup();
      vm.onChange();
    };

    this.replace = function (item) {
      item.replaceItem = true;
      var newItemList = [];
      angular.forEach(vm.savedItems[vm.groupName].items, function (gItem, index) {
        if (gItem.replaceItem) {
          // console.log('found replace item');
          newItemList.push(vm.item);
        } else {
          newItemList.push(gItem);
        }
      });

      saveHelper.updatedSavedItems(vm.groupName, newItemList);
      this.savedItems = saveHelper.getSavedItems();
      vm.clearGroup();
      vm.onChange();
    };

    function saveGroup() {
      saveHelper.saveBuildSelection(vm.groupName, vm.savedItems);
    }
  };
})();
'use strict';

angular.module('dnsim').controller('itemEditCustomCtrl', ['hCodeValues', '$scope', function (hCodeValues, $scope) {
  'use strict';

  if (this.item == null) return;
  if (this.item.itemSource != 'custom' && this.item.typeName != 'custom') {
    return;
  }

  var vm = this;

  this.statMap = {};

  // console.log(vm.item.stats);
  _.forEach(vm.item.stats, function (stat) {
    // console.log('got stat', stat.id);
    vm.statMap[stat.id] = stat.max;
  });

  for (var statId in hCodeValues.stats) {
    $scope.$watch('editCtrl.statMap[' + statId + ']', function (newValue, oldValue) {

      if (newValue != oldValue) {
        // console.log(statId);
        // console.log('watch got stat value', newValue);

        var anyChange = false;
        var newStats = [];
        for (var statId in vm.statMap) {

          if (!vm.statMap[statId] || !Number(vm.statMap[statId])) {
            _.each(vm.item.stats, function (stat) {
              if (stat.id == statId) {
                anyChange = true;
              }
            });
          } else {
            newStats.push({
              id: Number(statId),
              max: Number(vm.statMap[statId])
            });

            var found = false;
            _.each(vm.item.stats, function (stat) {
              if (stat.id == statId) {
                found = true;
                // console.log('comparing', stat.max, vm.statMap[statId]);
                if (!(statId in vm.statMap) || stat.max != vm.statMap[statId]) {
                  anyChange = true;
                }
              }
            });

            if (!found) {
              anyChange = true;
            }
          }
        }

        if (anyChange) {
          // console.log('GOT CHANGES!', newStats);
          vm.item.stats = newStats;
          vm.onChange();
        }
      }
    });
  }
}]).directive('dngearsimItemEditCustom', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange'
    },
    controller: 'itemEditCustomCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-custom.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemEditEnchantmentCtrl', ["dntData", "hCodeValues", "items", "$timeout", "translations", "itemColumnsToLoad", "itemFactory", function (dntData, hCodeValues, items, $timeout, translations, itemColumnsToLoad, itemFactory) {
  'use strict';

  var vm = this;

  if (!vm.item || !vm.item.enchantmentId) {
    return;
  }

  if ('itemSource' in this.item) {
    vm.itemType = items[vm.item.itemSource];
  }

  if (!vm.itemType) {
    return;
  }
  if (!('enchantDnt' in vm.itemType) && !('petLevelDnt' in vm.itemType)) {
    return;
  }

  if (vm.itemType.enchantDnt) {
    dntData.init(vm.itemType.enchantDnt, itemColumnsToLoad.enchantDnt, null, vm.getEnchantments);
  }
  if (vm.itemType.enchantDnt2) {
    dntData.init(vm.itemType.enchantDnt2, itemColumnsToLoad.enchantDnt, null, vm.getEnchantments);
  }

  if (vm.itemType.petLevelDnt) {
    dntData.init(vm.itemType.petDnt, itemColumnsToLoad.petDnt, null, vm.getEnchantments);
    dntData.init(vm.itemType.petLevelDnt, itemColumnsToLoad.petLevelDnt, null, vm.getEnchantments);
  }

  vm.enchantments = null;
  vm.enchantment = null;
  vm.enchantmentAfter = null;
  vm.enchantmentCost = '';
  vm.enhancementOptions = [];
  if (vm.item.enchantmentStats == null) {
    vm.item.enchantmentStats = [];
  }

  this.setEnchantment = function () {
    vm.item.enchantmentStats = [];

    if (vm.enchantments && vm.enchantments.length > 0) {

      if (typeof vm.item.enchantmentNum != 'number') {
        vm.item.enchantmentNum = 0;
        vm.onChange();
      }

      for (var i = 0; i < vm.enchantments.length; ++i) {
        if (vm.item.enchantmentNum == getEnchantLevel(i)) {
          vm.enchantment = vm.enchantments[i];

          vm.item.enchantmentStats = hCodeValues.getStats(vm.enchantment);
        } else if (vm.item.enchantmentNum + 1 == getEnchantLevel(i)) {
          vm.enchantmentAfter = vm.enchantments[i];
          if (vm.enchantmentAfter.NeedCoin < 10000) {
            vm.enchantmentCost = Math.round(vm.enchantmentAfter.NeedCoin / 1000) / 10 + 'g';
          } else {
            vm.enchantmentCost = Math.round(vm.enchantmentAfter.NeedCoin / 10000) + 'g';
          }
        }
      }
    }
  };

  function getEnchantLevel(num) {
    if ('petLevelDnt' in vm.itemType) {
      return vm.enchantments[num].PetLevel;
    } else {
      return vm.enchantments[num].EnchantLevel;
    }
  }

  this.setPetLevel = function () {
    vm.item.enchantmentStats = [];

    if (vm.enchantments && vm.enchantments.length > 0) {

      if (typeof vm.item.enchantmentNum != 'number') {
        vm.item.enchantmentNum = 6;
        vm.onChange();
      }

      for (var i = 0; i < vm.enchantments.length; ++i) {
        if (vm.item.enchantmentNum == vm.enchantments[i].PetLevel) {
          vm.enchantment = vm.enchantments[i];

          vm.item.enchantmentStats = hCodeValues.getStats(vm.enchantment);
        }
      }
    }
  };

  this.isMaxEnchantLevel = function () {

    if (vm.enchantments != null && vm.enchantments.length > 0 && typeof vm.item.enchantmentNum == 'number') {

      for (var i = 0; i < vm.enchantments.length; ++i) {
        if (vm.item.enchantmentNum + 1 == getEnchantLevel(i)) {
          return false;
        }
      }
      return true;
    } else {
      return false;
    }
  };

  this.setEnchantmentNum = function (enhancementOption) {
    vm.item.enchantmentNum = enhancementOption;
    vm.enhancementOptions = [];
    if ('petLevelDnt' in vm.itemType) {
      vm.setPetLevel();
    } else {
      vm.setEnchantment();
    }
    vm.onChange();
  };

  this.nextEnchantment = function () {
    for (var i = vm.item.enchantmentNum; i == 0 || vm.enchantments[i - 1]; ++i) {
      if (i == 0) {
        vm.enhancementOptions.push({ number: 0 });
      } else {
        vm.enhancementOptions.push(vm.getOption(i - 1));
      }
    }
  };

  this.prevEnchantment = function () {
    vm.enhancementOptions = [];
    for (var i = vm.item.enchantmentNum; i > 0; --i) {
      vm.enhancementOptions.push(vm.getOption(i - 1));
    }

    vm.enhancementOptions.push({ number: 0 });
  };

  this.getOption = function (enchantmentNum) {
    return {
      number: getEnchantLevel(enchantmentNum),
      stats: hCodeValues.getStats(vm.enchantments[enchantmentNum])
    };
  };

  this.getEnchantments = function () {
    if (!vm.enchantments && vm.item && vm.item.enchantmentId) {
      if (vm.itemType.enchantDnt && dntData.isLoaded(vm.itemType.enchantDnt)) {
        vm.enchantments = dntData.find(vm.itemType.enchantDnt, 'EnchantID', vm.item.enchantmentId);
        if (!vm.enchantments.length && vm.itemType.enchantDnt2) {
          vm.enchantments = dntData.find(vm.itemType.enchantDnt2, 'EnchantID', vm.item.enchantmentId);
        }
        vm.setEnchantment();
      }
      if (vm.itemType.petLevelDnt && dntData.isLoaded(vm.itemType.petLevelDnt)) {
        vm.enchantments = dntData.find(vm.itemType.petLevelDnt, 'PetLevelTypeID', vm.item.enchantmentId);
        vm.setPetLevel();
      }
    }

    return vm.enchantments;
  };

  var fileName = 'all-items.lzjson';

  this.showMaterials = function () {
    dntData.init(fileName, null, function () {}, function () {
      $timeout(function () {

        if (!vm.enchantmentAfter) {
          return;
        }

        vm.materials = [];
        for (var i = 1; i <= 5; ++i) {
          var itemId = vm.enchantmentAfter['NeedItemID' + i];
          var itemCount = vm.enchantmentAfter['NeedItemCount' + i];
          if (itemId > 0 && itemCount > 0) {

            var items = dntData.find(fileName, 'id', itemId);
            if (items.length == 0) {
              vm.materials.push({ num: itemCount, name: 'unknown (' + itemId + ')' });
            } else {
              var item = items[0];
              if (item) {
                var material = {
                  item: itemFactory.createBasicItem(item),
                  num: itemCount
                };
                vm.materials.push(material);
              }
            }
          }
        }
      });
    });
  };

  if (dntData.isLoaded(fileName)) {
    this.showMaterials();
  }

  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
}]).directive('dngearsimItemEditEnchantment', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange'
    },
    controller: 'itemEditEnchantmentCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-enchantment.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemEditPotentialCtrl', ['dntData', 'items', 'hCodeValues', 'itemColumnsToLoad', function (dntData, items, hCodeValues, itemColumnsToLoad) {
  'use strict';

  var vm = this;

  this.potentials = null;
  this.potential = null;
  this.changingPotentials = false;
  this.potentialStats = {};

  if (this.item == null) return;

  if ('itemSource' in this.item) {
    this.itemType = items[this.item.itemSource];
  }

  if (!this.itemType || !this.item.pid || !('potentialDnt' in this.itemType)) {
    return;
  }

  if (vm.itemType.potentialDnt) {
    dntData.init(vm.itemType.potentialDnt, itemColumnsToLoad.potentialDnt, null, vm.getPotentials);
  }

  this.getPotentials = function () {
    if (!vm.potentials) {
      if (vm.item && vm.item.pid && 'potentialDnt' in vm.itemType) {
        var potentials = dntData.find(vm.itemType.potentialDnt, 'id', vm.item.pid);

        if (potentials.length == 1) {
          vm.potential = potentials[0];
          vm.potentials = dntData.find(vm.itemType.potentialDnt, 'PotentialID', vm.potential.PotentialID);
          vm.potentialStats = getPotentialStats(vm.potentials);
        } else if ('potentialDntEx' in vm.itemType) {
          potentials = dntData.find(vm.itemType.potentialDntEx, 'id', vm.item.pid);

          if (potentials.length == 1) {
            vm.potential = potentials[0];
            vm.potentials = dntData.find(vm.itemType.potentialDntEx, 'PotentialID', vm.potential.PotentialID);
            vm.potentialStats = getPotentialStats(vm.potentials);
          }
        }
      }
    }

    return vm.potentials;
  };

  this.nextPotential = function () {
    for (var i = 0; i < vm.potentials.length; ++i) {
      if (vm.potential.id == vm.potentials[i].id) {
        vm.potential = vm.potentials[i + 1];
        vm.item.pid = vm.potential.id;
        vm.onChange();
        this.changingPotentials = true;
        return;
      }
    }
  };

  this.prevPotential = function () {
    for (var i = 0; i < vm.potentials.length; ++i) {
      if (vm.potential.id == vm.potentials[i].id) {
        vm.potential = vm.potentials[i - 1];
        vm.item.pid = vm.potential.id;
        vm.onChange();
        this.changingPotentials = true;
        return;
      }
    }
  };

  this.changePotential = function (pid) {
    for (var i = 0; i < vm.potentials.length; ++i) {
      if (pid == vm.potentials[i].id) {
        vm.potential = vm.potentials[i];
        vm.item.pid = vm.potential.id;
        vm.changingPotentials = false;
        vm.onChange();
        return;
      }
    }
  };

  this.isFirstPotential = function () {
    this.getPotentials();
    return !vm.potentials || vm.potentials.length <= 1 || !vm.potential || vm.potential.id == vm.potentials[0].id;
  };

  this.isLastPotential = function () {
    this.getPotentials();
    return !vm.potentials || vm.potentials.length <= 1 || !vm.potential || vm.potential.id == vm.potentials[vm.potentials.length - 1].id;
  };

  function getPotentialStats() {
    var pStats = {};
    var emptyStatId = null;

    if (vm.potentials != null) {
      angular.forEach(vm.potentials, function (p, index) {
        var stats = [];
        angular.forEach(hCodeValues.getStats(p), function (stat, sIndex) {
          if (!hCodeValues.stats[stat.id].hide) {
            stats.push(stat);
          }
        });

        if (stats.length > 0) {
          pStats[p.id] = stats;
        } else if (!emptyStatId) {
          pStats[p.id] = [];
          emptyStatId = p.id;
        }
      });
    }

    return pStats;
  }

  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
}]).directive('dngearsimItemEditPotential', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange'
    },
    controller: 'itemEditPotentialCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-potential.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemEditSkillCtrl', ['$timeout', 'dntData', 'statHelper', function ($timeout, dntData, statHelper) {
  'use strict';

  if (this.item == null) return;
  if (this.item.itemSource != 'skills') {
    return;
  }

  if (!this.item.enchantmentNum) {
    this.item.enchantmentNum = 1;
  }

  var vm = this;

  function getDntFile() {
    return 'skillleveltable_character' + vm.item.baseJobName + vm.item.pve + '.lzjson';
  }

  this.initSkills = function () {
    var dntFile = getDntFile();
    dntData.init(dntFile, null, reportProgress, function () {
      $timeout(function () {
        vm.skillData = dntData.find(dntFile, 'SkillIndex', vm.item.id);
      });
    });
  };

  this.nextEnchantment = function () {
    if (this.skillData && this.item.enchantmentNum < this.skillData.length) {
      this.item.enchantmentNum++;
      vm.onChange();
    }
  };

  this.isMaxSkillLevel = function () {
    return this.skillData && this.item && this.item.enchantmentNum >= this.skillData.length;
  };

  this.prevEnchantment = function () {
    if (this.item.enchantmentNum > 0) {
      this.item.enchantmentNum--;
    } else {
      this.item.enchantmentNum = 0;
    }

    vm.onChange();
  };

  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }

  dntData.init(getDntFile(), null, null, vm.initSkills);
}]).directive('dngearsimItemEditSkill', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange'
    },
    controller: 'itemEditSkillCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-skill.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemEditSparkCtrl', ['dntData', 'hCodeValues', 'items', 'itemColumnsToLoad', function (dntData, hCodeValues, items, itemColumnsToLoad) {
  'use strict';

  var vm = this;

  if (this.item == null) return;
  if ('itemSource' in this.item) {
    this.itemType = items[this.item.itemSource];
  }

  if (!vm.itemType || !vm.itemType.sparkDnt) {
    return;
  }

  if (vm.itemType.sparkDnt) {
    dntData.init(vm.itemType.sparkDnt, itemColumnsToLoad.sparkDnt, null, vm.getSparks);
  }

  this.sparks = null;

  this.nextSpark = function () {
    var index = getPotentialIndex();
    index++;
    if (index >= vm.sparks.length) {
      index = 0;
    }
    var spark = vm.sparks[index];
    vm.item.sparkId = spark.id;
    vm.item.sparkStats = hCodeValues.getStats(spark);
    vm.onChange();
  };

  this.isMoreSparks = function () {
    return vm.sparks != null && getPotentialIndex() >= vm.sparks.length - 1;
  };

  this.isFirstSpark = function () {
    return getPotentialIndex() == 0;
  };

  this.prevSpark = function () {
    var index = getPotentialIndex();
    index--;
    if (index < 0) {
      index = vm.sparks.length - 1;
    }
    var spark = vm.sparks[index];
    vm.item.sparkId = spark.id;
    vm.item.sparkStats = hCodeValues.getStats(spark);
    vm.onChange();
  };

  this.removeSpark = function () {
    vm.item.sparkId = null;
    vm.item.sparkStats = null;
    vm.onChange();
  };

  this.getSparks = function () {
    if (vm.item == null || vm.itemType == null) return null;
    if (vm.sparks == null) {
      var sid = vm.item.sparkTypeId;
      if (sid) {
        if (dntData.isLoaded(vm.itemType.sparkDnt)) {
          vm.sparks = dntData.find(vm.itemType.sparkDnt, 'PotentialID', sid);
        }
      }
    }

    return vm.sparks;
  };

  function getPotentialIndex() {
    var potentialIndex = -1;
    if (vm.item.sparkId > 0) {
      angular.forEach(vm.sparks, function (spark, index) {
        if (spark.id == vm.item.sparkId) {
          potentialIndex = index;
          return;
        }
      });
    }

    return potentialIndex;
  }

  function reportProgress(msg) {
    // console.log('progress: ' + msg);
  }
}]).directive('dngearsimItemEditSpark', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange'
    },
    controller: 'itemEditSparkCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-spark.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemEditTalismanCtrl', [function () {
  'use strict';

  if (this.item == null) return;
  if (this.item.itemSource != 'tman') {
    return;
  }

  this.setTalisman = function (amount) {
    if (amount == 0) {
      this.item.enchantmentNum = null;
      this.item.enchantmentStats = [];
    } else {
      this.item.enchantmentNum = amount;

      var extraStats = [];
      angular.forEach(this.item.stats, function (stat, index) {
        extraStats.push({ id: stat.id, max: stat.max * (amount / 100) });
      });

      this.item.enchantmentStats = extraStats;
    }
    this.onChange();
  };
}]).directive('dngearsimItemEditTalisman', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange'
    },
    controller: 'itemEditTalismanCtrl',
    controllerAs: 'editCtrl',
    templateUrl: 'ui/item/item-edit-talisman.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemEditCtrl', ['hCodeValues', function (hCodeValues) {
  'use strict';

  var vm = this;

  if (!vm.item) {
    return;
  }

  vm.onUpdateItem = function () {
    vm.updateItem();
  };
}]).directive('dngearsimItemEdit', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item',
      onChange: '&onChange',
      updateItem: '&updateItem'
    },
    controller: 'itemEditCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-edit.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewAttainmentCtrl', ['$timeout', 'dntData', 'itemFactory', 'hCodeValues', 'translations', function ($timeout, dntData, itemFactory, hCodeValues, translations) {
  'use strict';

  if (this.item == null) return;

  var vm = this;
  vm.attainments = [];

  var files = ['itemgaintable.lzjson', 'itemgaintable_dragonjewel.lzjson', 'itemgaintable_enchant.lzjson', 'itemgaintable_etc.lzjson', 'itemgaintable_reboot.lzjson', 'itemgaintable_talisman.lzjson'];

  for (var i = 0; i < files.length; ++i) {
    dntData.init(files[i], null, function () {}, function () {
      $timeout(function () {
        vm.init();
      });
    });
  }

  this.init = function () {
    for (var i = 0; i < files.length; ++i) {
      if (!dntData.isLoaded(files[i]) && !dntData.hasFailed(files[i])) {
        return;
      }
    }

    vm.attainments = [];
    files.forEach(function (file) {
      var attainments = dntData.find(file, 'id', vm.item.id);
      if (attainments.length) {
        attainments.forEach(function (attainment) {
          var text = attainment.ItemGainText;
          if (text) {
            var texts = text.split('{');
            texts.forEach(function (singleText) {
              var splitVal = singleText.split('}');
              if (splitVal.length) {
                if (splitVal[0].indexOf('#') == -1) {
                  vm.attainments.push(translations.translate(splitVal[0]));
                }
              }
            });
          }
        });
      }
    });
  };
}]).directive('dngearsimItemViewAttainment', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewAttainmentCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-attainment.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewBoxCtrl', ['$timeout', 'dntData', 'itemFactory', 'region', function ($timeout, dntData, itemFactory, region) {
  'use strict';

  if (this.item == null) return;
  if (this.item.typeId != 46 && this.item.typeId != 8 && this.item.typeId != 112 && this.item.typeId != 122 && this.item.typeId != 142 && this.item.typeId != 160) {
    console.log('not box item type ' + this.item.typeId);
    return;
  }

  var vm = this;

  var pouchFileNames = ['itemdroptable.lzjson', 'itemdroptable_abyss.lzjson', 'itemdroptable_apprentice.lzjson', 'itemdroptable_cook.lzjson', 'itemdroptable_darklair.lzjson', 'itemdroptable_dimension.lzjson', 'itemdroptable_disjoint.lzjson', 'itemdroptable_dnexpedition.lzjson', 'itemdroptable_event.lzjson', 'itemdroptable_farm.lzjson', 'itemdroptable_fishing.lzjson', 'itemdroptable_guildwar.lzjson', 'itemdroptable_item.lzjson', 'itemdroptable_monsteritem.lzjson', 'itemdroptable_propdrop.lzjson', 'itemdroptable_pvp.lzjson', 'itemdroptable_randomcompound.lzjson', 'itemdroptable_stageclear.lzjson', 'itemdroptable_themepark.lzjson', 'itemdroptable_union.lzjson'];

  var allItemFileName = 'all-items.lzjson';
  var charmItemtable = 'charmitemtable.lzjson';
  var commonCharmItemtable = 'charmitemtable_common.lzjson';
  this.usedFiles = {};
  this.lookupId = null;

  var files;
  if (this.item.typeId == 46 || this.item.typeId == 112 || this.item.typeId == 122 || this.item.typeId == 142 || this.item.typeId == 160) {
    files = [allItemFileName, charmItemtable, commonCharmItemtable];
  } else if (this.item.typeId == 8) {
    files = [allItemFileName].concat(pouchFileNames);
  }

  for (var i = 0; i < files.length; ++i) {
    dntData.init(files[i], null, function () {}, function () {
      $timeout(function () {
        vm.initBoxContents();
      });
    });
  }

  this.initBoxContents = function () {
    // console.log('init contents', this.item.fileName);

    for (var i = 0; i < files.length; ++i) {
      if (!dntData.isLoaded(files[i])) {
        return;
      }
    }

    var datas = dntData.find(this.item.fileName + '.lzjson', 'id', this.item.id);
    if (datas.length > 0) {
      var d = datas[0];
      this.lookupId = d.TypeParam1;
      vm.items = [];

      if (vm.item.typeId == 46 || vm.item.typeId == 112 || vm.item.typeId == 122 || vm.item.typeId == 142 || vm.item.typeId == 160) {
        vm.getCharmItems(d.TypeParam1);
      } else if (vm.item.typeId == 8) {
        vm.getPouchItems(d.TypeParam1);
      }
    }
  };

  this.getPouchItems = function (boxType) {
    for (var f = 0; f < pouchFileNames.length; ++f) {
      vm.getPouchItemsFromFile(boxType, pouchFileNames[f]);
    }
  };

  this.getPouchItemsFromFile = function (boxType, pouchFileName) {

    var pouchData = dntData.find(pouchFileName, 'id', boxType);
    if (pouchData.length == 0) {} else {
      var gold = pouchData[0].GoldMin;

      var itemIndex = 0;
      do {
        itemIndex++;
        var isGroup = pouchData[0]['IsGroup' + itemIndex];
        var pouchItem = pouchData[0]['Item' + itemIndex + 'Index'];
        var pouchItemCount = pouchData[0]['Item' + itemIndex + 'Info'];
        //console.log('pouch contains ' + pouchItem);
        if (pouchItem) {
          if (isGroup) {
            vm.getPouchItems(pouchItem, pouchFileName);
          } else {
            // console.log('adding item ' + pouchItem);
            var itemds = dntData.find(allItemFileName, 'id', pouchItem);
            if (itemds.length > 0) {
              var basicItem = itemFactory.createBasicItem(itemds[0]);
              // console.log('found item ' + basicItem.name);

              vm.items.push({
                count: pouchItemCount,
                gold: gold,
                item: basicItem
              });
              this.usedFiles[pouchFileName] = true;
            }
          }
        }
      } while (pouchItem);
    }
  };

  this.getCharmItems = function (boxType) {
    var charmFiles = [charmItemtable, commonCharmItemtable];
    for (var i = 0; i < charmFiles.length; ++i) {

      var charmData = dntData.getData(charmFiles[i]);
      // console.log('box: ' + boxType, charmData);

      for (var c = 0; c < charmData.length; ++c) {
        var cd = charmData[c];
        if (cd.CharmNum == boxType && cd.Look) {

          if (cd.CharmType) {
            this.getCharmItems(cd.ItemID);
          } else {
            var itemds = dntData.find(allItemFileName, 'id', cd.ItemID);
            if (itemds.length > 0) {
              vm.items.push({
                count: cd.Count,
                gold: cd.Gold,
                item: itemFactory.createBasicItem(itemds[0])
              });
              this.usedFiles[charmFiles[i]] = true;
            }
          }
        }
      }
    }
  };

  this.getFileLink = function (fileName) {
    return 'https://spacem.github.io/dntviewer/#dnt=' + fileName + '&location=' + region.dntLocation.url;
  };
}]).directive('dngearsimItemViewBox', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewBoxCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-box.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewCraftCtrl', ['$timeout', 'dntData', 'itemFactory', 'hCodeValues', 'translations', function ($timeout, dntData, itemFactory, hCodeValues, translations) {
  'use strict';

  if (this.item == null) return;

  var vm = this;
  vm.crafts = [];

  var cFiles = ['itemcompoundtable.lzjson', 'itemcompoundtable_custom.lzjson', 'itemcompoundtable_glyph.lzjson', 'itemcompoundtable_glyph95.lzjson', 'itemcompoundtable_jewel.lzjson', 'itemcompoundtable_renewal.lzjson', 'itemcompoundtable_set.lzjson'];

  var dropFile = 'itemdroptable.lzjson';

  var allItemFileName = 'all-items.lzjson';

  var files = cFiles.concat([allItemFileName, dropFile]);
  for (var i = 0; i < files.length; ++i) {
    dntData.init(files[i], null, function () {}, function () {
      $timeout(function () {
        vm.initCrafts();
      });
    });
  }

  this.initCrafts = function () {
    for (var i = 0; i < files.length; ++i) {
      if (!dntData.isLoaded(files[i]) && !dntData.hasFailed(files[i])) {
        return;
      }
    }

    vm.crafts = [];
    for (var i = 0; i < cFiles.length; ++i) {
      vm.initCraft(cFiles[i], vm.item.id);
    }

    for (var di = 1; di <= 20; ++di) {
      var drops = dntData.find(dropFile, 'Item' + di + 'Index', vm.item.id);
      if (drops.length) {
        drops.forEach(function (drop) {
          for (var i = 0; i < cFiles.length; ++i) {
            vm.initCraft(cFiles[i], drop.id);
          }
        });
      }
    }

    var newCrafts = [];
    for (var i = 0; i < vm.crafts.length; ++i) {
      var found = false;
      for (var j = 0; j < newCrafts.length; ++j) {
        if (vm.crafts[i].gold == newCrafts[j].gold && vm.crafts[i].items.length == newCrafts[j].items.length) {

          found = true;
          for (var k = 0; k < vm.crafts[i].items.length; ++k) {
            if (vm.crafts[i].items[k].item.id != newCrafts[j].items[k].item.id || vm.crafts[i].items[k].num != newCrafts[j].items[k].num) {
              found = false;
            }
          }
        }
      }

      if (!found) {
        newCrafts.push(vm.crafts[i]);
      }
    }

    vm.crafts = newCrafts;
  };

  this.initCraft = function (fileName, id) {
    var fCrafts = dntData.find(fileName, 'SuccessItemID1', id);

    for (var i = 0; i < fCrafts.length; ++i) {
      var c = fCrafts[i];

      var craft = {
        id: c.id,
        fileName: fileName.replace('.lzjson', ''),
        gold: c.Cost / 100 / 100,
        items: []
      };

      var j = 0;
      for (;;) {
        j++;
        var itemColName = 'Slot' + j + 'Id';
        var qtyColName = 'Slot' + j + 'Num';
        if (!(itemColName in c)) {
          break;
        }

        var items = dntData.find(allItemFileName, 'id', c[itemColName]);
        if (items.length > 0) {
          craft.items.push({
            item: itemFactory.createBasicItem(items[0]),
            num: c[qtyColName]
          });
        }
      }

      vm.crafts.push(craft);
    }
  };
}]).directive('dngearsimItemViewCraft', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewCraftCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-craft.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewExtractionCtrl', ['$timeout', 'dntData', 'itemFactory', 'items', function ($timeout, dntData, itemFactory, items) {
  'use strict';

  if (this.item == null) return;

  var vm = this;

  var extractFileName = 'itemdroptable_disjoint.lzjson';
  var allItemFileName = 'all-items.lzjson';

  var files = [extractFileName, allItemFileName];
  for (var i = 0; i < files.length; ++i) {
    dntData.init(files[i], null, function () {}, function () {
      $timeout(function () {
        vm.initExtract();
      });
    });
  }

  this.initExtract = function () {
    for (var i = 0; i < files.length; ++i) {
      if (!dntData.isLoaded(files[i])) {
        return;
      }
    }

    var disjoint;
    var d = itemFactory.getItemData(vm.item);
    if (d && d.DisjointDrop1 > 0) {
      disjoint = d.DisjointDrop1;
    }

    var itemType = items[vm.item.itemSource];
    if (itemType && d.EnchantID) {
      var enchantments = dntData.find(itemType.enchantDnt, 'EnchantID', d.EnchantID);
      if (!enchantments.length && itemType.enchantDnt2) {
        enchantments = dntData.find(itemType.enchantDnt2, 'EnchantID', d.EnchantID);
      }

      for (var i = 0; i < enchantments.length; ++i) {
        if (enchantments[i].EnchantLevel == vm.item.enchantmentNum) {
          disjoint = enchantments[i].DisjointDrop;
          break;
        }
      }
    }

    vm.items = [];
    if (disjoint) {
      vm.getItems(disjoint);
    }
  };

  this.getGold = function () {
    var d = itemFactory.getItemData(this.item);
    return Number(d.Disjointamount) / 100 / 100;
  };

  this.getItems = function (disjoint) {
    // console.log('checking ' + pouchFileName + ' for ' + boxType);

    var pouchData = dntData.find(extractFileName, 'id', disjoint);
    if (pouchData.length == 0) {} else {
      var gold = pouchData[0].GoldMin;

      var itemIndex = 1;
      while ('Item' + itemIndex + 'Index' in pouchData[0]) {
        var isGroup = pouchData[0]['IsGroup' + itemIndex];
        var pouchItem = pouchData[0]['Item' + itemIndex + 'Index'];
        var pouchItemCount = pouchData[0]['Item' + itemIndex + 'Info'];
        //console.log('pouch contains ' + pouchItem);
        if (pouchItem) {
          if (isGroup) {
            vm.getItems(pouchItem);
          } else {
            var itemds = dntData.find(allItemFileName, 'id', pouchItem);
            if (itemds.length > 0) {
              //console.log('found item ');

              vm.items.push({
                count: pouchItemCount,
                gold: gold,
                item: itemFactory.createBasicItem(itemds[0])
              });
            }
          }
        }
        itemIndex++;
      }
    }
  };
}]).directive('dngearsimItemViewExtraction', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewExtractionCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-extraction.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewPlateCtrl', ['$timeout', 'dntData', 'itemFactory', 'hCodeValues', 'translations', function ($timeout, dntData, itemFactory) {
  'use strict';

  if (this.item == null) return;

  var vm = this;
  vm.items = [];

  var plateFile = 'platetable.lzjson';
  var allItemFileName = 'all-items.lzjson';

  var allFiles = [plateFile, allItemFileName];
  for (var i = 0; i < allFiles.length; ++i) {
    dntData.init(allFiles[i], null, function () {}, function () {
      $timeout(function () {
        vm.initSets();
      });
    });
  }

  this.initSets = function () {
    for (var i = 0; i < allFiles.length; ++i) {
      if (!dntData.isLoaded(allFiles[i])) {
        return;
      }
    }

    vm.items = [];
    getPlates();
  };

  function getPlates() {
    var rows = dntData.find(plateFile, 'ItemID', vm.item.id);
    for (var r = 0; r < rows.length; ++r) {
      var row = rows[r];
      var col = 0;
      for (;;) {
        col++;
        var colName = 'CompoundTableIndex' + col;
        if (!(colName in row)) {
          break;
        }

        var itemData = dntData.find(allItemFileName, 'id', row[colName]);
        if (itemData.length > 0) {
          vm.items.push(itemFactory.createBasicItem(itemData[0]));
        }
      }
    }
  }
}]).directive('dngearsimItemViewPlate', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewPlateCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-plate.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewSetCtrl', ['$timeout', 'dntData', 'itemFactory', 'hCodeValues', 'translations', function ($timeout, dntData, itemFactory) {
  'use strict';

  if (this.item == null) return;

  var vm = this;
  vm.items = [];

  var files = ['partstable.optimised.json', 'partstable_cash.optimised.json', 'partstable_common2014.optimised.json', 'partstable_common2015.optimised.json', 'partstable_common2016.lzjson', 'partstable_commoncash.lzjson', 'partstable_equipment.optimised.json', 'partstable_event.lzjson', 'partstable_guild.lzjson', 'partstable_pvp.optimised.json', 'partstable_reboot.optimised.json', 'partstable_skilllevelup.lzjson', 'weapontable.optimised.json', 'weapontable_cash.optimised.json', 'weapontable_common2014.optimised.json', 'weapontable_common2015.optimised.json', 'weapontable_common2016.lzjson', 'weapontable_commoncash.lzjson', 'weapontable_equipment.optimised.json', 'weapontable_event.lzjson', 'weapontable_guild.lzjson', 'weapontable_pvp.optimised.json', 'weapontable_reboot.optimised.json'];

  var allItemFileName = 'all-items.lzjson';

  var allFiles = files.concat([allItemFileName]);
  for (var i = 0; i < allFiles.length; ++i) {
    dntData.init(allFiles[i], null, function () {}, function () {
      $timeout(function () {
        vm.initSets();
      });
    });
  }

  this.initSets = function () {
    for (var i = 0; i < allFiles.length; ++i) {
      if (!dntData.isLoaded(allFiles[i])) {
        return;
      }
    }

    vm.items = [];
    for (var i = 0; i < files.length; ++i) {
      getSetItems(files[i]);
    }
  };

  function getSetItems(fileName) {
    var rows = dntData.find(fileName, 'SetItemID', vm.item.setId);
    for (var r = 0; r < rows.length; ++r) {
      var itemData = dntData.find(allItemFileName, 'id', rows[r].id);
      if (itemData.length > 0) {
        vm.items.push(itemFactory.createBasicItem(itemData[0]));
      }
    }
  }
}]).directive('dngearsimItemViewSet', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewSetCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-set.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewShopCtrl', ['$timeout', 'dntData', 'itemFactory', 'hCodeValues', 'translations', function ($timeout, dntData, itemFactory, hCodeValues, translations) {
  'use strict';

  if (this.item == null) return;

  var vm = this;
  vm.shopCosts = [];

  var cShopFileName = 'combinedshoptable.lzjson';
  var cSysShopFileName = 'combinedshoptable_system.lzjson';
  var cCashShopFileName = 'combinedshoptable_cash.lzjson';
  // var shopFileName = 'shoptable.lzjson';
  var allItemFileName = 'all-items.lzjson';

  var files = [cCashShopFileName, cSysShopFileName, cShopFileName, allItemFileName];
  for (var i = 0; i < files.length; ++i) {
    dntData.init(files[i], null, function () {}, function () {
      $timeout(function () {
        vm.initShops();
      });
    });
  }

  this.initShops = function () {
    for (var i = 0; i < files.length; ++i) {
      if (!dntData.isLoaded(files[i])) {
        return;
      }
    }

    vm.shopCosts = [];
    getCombinedCosts(cShopFileName);
    getCombinedCosts(cSysShopFileName);
    getCombinedCosts(cCashShopFileName);
    // getShopCosts();

    var newShopCosts = [];
    for (var i = 0; i < vm.shopCosts.length; ++i) {
      var found = false;
      for (var j = 0; j < newShopCosts.length; ++j) {
        if (vm.shopCosts[i].tabName == newShopCosts[j].tabName && vm.shopCosts[i].gold == newShopCosts[j].gold && vm.shopCosts[i].item1.id == newShopCosts[j].item1.id && vm.shopCosts[i].numItem1.id == newShopCosts[j].numItem1.id && vm.shopCosts[i].item2.id == newShopCosts[j].item2.id && vm.shopCosts[i].numItem2.id == newShopCosts[j].numItem2.id) {
          found = true;
          break;
        }
      }

      if (!found) {
        newShopCosts.push(vm.shopCosts[i]);
      }
    }

    vm.shopCosts = newShopCosts;
  };

  /*
  function getShopCosts() {
    var shops = dntData.getData(shopFileName);
    
    for(var i=0;i<shops.length;++i) {
      var s = shops[i];
      
      var c = 0;
      for(;;) {
        ++c;
        
        var colName = 'itemIndex' + c;
        if(!(colName in s)) {
          break;
        }
        
        var itemId = s[colName];
        if(!itemId) {
          break;
        }
        
        if(itemId == vm.item.id) {
          s = {
            shopName: s.ShopID,
            tabName: translations.translate(s.TabNameID),
            gold: s['Quantity' + c],
          };
          
      
          if(s.shopName in hCodeValues.shopNames) {
            s.shopName = hCodeValues.shopNames[s.shopName];
          }
      
          if(!s.shopName) {
            s.shopName = s.ShopId;
          }
          vm.shopCosts.push(s);
        }
      }
    }
  }*/

  function getCombinedCosts(fileName) {
    var shops = dntData.find(fileName, 'itemindex', vm.item.id);

    for (var i = 0; i < shops.length; ++i) {
      var s = shops[i];

      var item1s = dntData.find(allItemFileName, 'id', s.PurchaseItem1);
      var item2s = dntData.find(allItemFileName, 'id', s.PurchaseItem2);

      var shopCost = {
        shopName: s.ShopID,
        tabName: translations.translate(s.TabNameID),
        gold: 0,
        nightmarePoints: 0,
        dungeonPoints: 0,
        nestPoints: 0,
        ladderPoints: 0,
        item1: itemFactory.createBasicItem(item1s[0]),
        item2: itemFactory.createBasicItem(item2s[0]),
        numItem1: 0,
        numItem2: 0
      };

      if (shopCost.shopName in hCodeValues.shopNames) {
        shopCost.shopName = hCodeValues.shopNames[shopCost.shopName];
      }

      if (s.PurchaseType1 == 1) {
        shopCost.gold += s.PurchaseItemValue1;
      } else if (s.PurchaseType1 == 3) {
        shopCost.ladderPoints += s.PurchaseItemValue1;
      } else if (s.PurchaseType1 == 8) {
        shopCost.nightmarePoints += s.PurchaseItemValue1;
      } else if (s.PurchaseType1 == 13) {
        shopCost.nestPoints += s.PurchaseItemValue1;
      } else if (s.PurchaseType1 == 14) {
        shopCost.dungeonPoints += s.PurchaseItemValue1;
      } else {
        shopCost.numItem1 = s.PurchaseItemValue1;
        shopCost.pointsId1 = s.PurchaseType1;
      }

      if (s.PurchaseType2 == 1) {
        shopCost.gold += s.PurchaseItemValue2;
      } else if (s.PurchaseType2 == 3) {
        shopCost.ladderPoints += s.PurchaseItemValue2;
      } else if (s.PurchaseType2 == 8) {
        shopCost.nightmarePoints += s.PurchaseItemValue2;
      } else if (s.PurchaseType1 == 13) {
        shopCost.nestPoints += s.PurchaseItemValue2;
      } else if (s.PurchaseType1 == 14) {
        shopCost.dungeonPoints += s.PurchaseItemValue2;
      } else {
        shopCost.numItem2 = s.PurchaseItemValue2;
        shopCost.pointsId2 = s.PurchaseType2;
      }

      shopCost.gold = shopCost.gold / 100 / 100;

      vm.shopCosts.push(shopCost);
    }
  }
}]).directive('dngearsimItemViewShop', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewShopCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-shop.html'
  };
});
'use strict';

angular.module('dnsim').controller('itemViewTransferCtrl', ['$timeout', 'dntData', 'itemFactory', 'hCodeValues', function ($timeout, dntData, itemFactory, hCodeValues) {
  'use strict';

  if (this.item == null) return;

  var vm = this;
  vm.matchingTransfers = [];

  var transferFileName = 'enchanttransfertable.lzjson';
  var allItemFileName = 'all-items.lzjson';
  var transferItemsFileName = 'enchanttransferitemtable.lzjson';

  var files = [transferFileName, allItemFileName, transferItemsFileName];
  for (var i = 0; i < files.length; ++i) {
    dntData.init(files[i], null, function () {}, function () {
      $timeout(function () {
        vm.initTransfers();
      });
    });
  }

  this.initTransfers = function () {
    for (var i = 0; i < files.length; ++i) {
      if (!dntData.isLoaded(files[i])) {
        return;
      }
    }
    vm.matchingTransfers = [];

    var transferItem = dntData.find(transferItemsFileName, 'ItemID', vm.item.id);
    if (transferItem && transferItem.length > 0) {
      var transfers = dntData.find(transferFileName, 'EnchantLevel', vm.item.enchantmentNum);

      for (var i = 0; i < transfers.length; ++i) {
        var t = transfers[i];
        if (t.Rank == vm.item.rank.id && t.LevelLimit == vm.item.levelLimit) {

          var item1s = dntData.find(allItemFileName, 'id', t.NeedItemID1);
          var item2s = dntData.find(allItemFileName, 'id', t.NeedItemID2);

          vm.matchingTransfers.push({
            level: t.ResultLevel,
            enchantmentNum: t.ResultEnchantLevel,
            gold: t.NeedCoin / 100 / 100,
            rank: hCodeValues.rankNames[t.ResultRank],
            numItem1: t.NeedItemCount1,
            item1: itemFactory.createBasicItem(item1s[0]),
            numItem2: t.NeedItemCount2,
            item2: itemFactory.createBasicItem(item2s[0])
          });
        }
      }
    }
  };
}]).directive('dngearsimItemViewTransfer', function () {
  return {
    scope: true,
    bindToController: {
      item: '=item'
    },
    controller: 'itemViewTransferCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'ui/item/item-view-transfer.html'
  };
});
'use strict';

angular.module('dnsim').controller('ItemCtrl', ['$scope', '$window', 'dntData', 'hCodeValues', 'items', 'jobs', 'exportLinkHelper', '$routeParams', 'translations', '$location', 'region', 'itemFactory', '$timeout', 'statHelper', 'saveHelper', function ($scope, $window, dntData, hCodeValues, items, jobs, exportLinkHelper, $routeParams, translations, $location, region, itemFactory, $timeout, statHelper, saveHelper) {
  'use strict';

  region.setLocationByName($routeParams.region);

  $window.scrollTo(0, 0);

  $scope.jobName = null;
  // console.log('search string: ', $routeParams.i);
  $scope.item = exportLinkHelper.decodeItem($routeParams.i);
  if ('itemSource' in $scope.item) {
    $scope.itemType = items[$scope.item.itemSource];
  }

  $scope.item.setStats = null;
  $scope.item.setId = null;
  $scope.detail = null;

  $scope.getDescription = function () {
    if ($scope.item.description) {
      return $scope.item.description;
    } else if ($scope.itemType && $scope.itemType.name == 'title' && translations.isLoaded() && dntData.isLoaded($scope.itemType.mainDnt)) {

      var itemData = dntData.find($scope.itemType.mainDnt, 'id', $scope.item.id);
      if (itemData && itemData.length > 0 && itemData[0].DescriptionID > 0) {
        return translations.translate(itemData[0].DescriptionID, itemData[0].DescriptionIDParam);
      }
    } else if ($scope.item.fileName && dntData.isLoaded($scope.item.fileName + '.lzjson')) {

      var itemData = dntData.find($scope.item.fileName + '.lzjson', 'id', $scope.item.id);
      if (itemData && itemData.length > 0 && itemData[0].DescriptionID > 0) {
        return translations.translate(itemData[0].DescriptionID, itemData[0].DescriptionIDParam);
      }
    }
    return '';
  };

  $scope.getExchangeType = function () {
    // console.log('getting exchange');
    var exchangeDnt = 'exchange.lzjson';
    if (translations.isLoaded() && dntData.isLoaded(exchangeDnt) && $scope.item.exchangeType > 0) {

      // console.log('finding exchange ' + $scope.item.exchangeType);

      var exchange = dntData.find(exchangeDnt, 'ExchangeType', $scope.item.exchangeType);
      // console.log('got ' + exchange.length);
      if (exchange && exchange.length > 0 && exchange[0].NameID > 0) {
        // console.log('exchange name: ' + exchange[0].NameID);
        return translations.translate(exchange[0].NameID).toLowerCase();
      }
    }
    return '';
  };

  $scope.setDetail = function (detail) {
    $scope.detail = detail;
  };

  $scope.getNumInSet = function () {

    var buildName = $scope.getBuildName();
    if (buildName && $scope.item && $scope.item.setId) {
      return statHelper.getNumItemsForSet($scope.builds[buildName].items, $scope.item.setId);
    }

    return 0;
  };

  $scope.getBuildName = function () {
    var buildName = saveHelper.getCurrentBuild();
    if ($scope.builds) {
      if (!buildName || !(buildName in $scope.builds)) {
        var allBuildNames = Object.keys($scope.builds);
        if (allBuildNames.length) {
          buildName = allBuildNames[0];
        }
      }
    }

    return buildName;
  };

  $scope.getSellingPrice = function () {
    var itemData = itemFactory.getItemData($scope.item);
    var retVal = '';
    if ('SellAmount' in itemData && itemData.SellAmount > 0) {

      var gold = Math.floor(itemData.SellAmount / 10000);
      if (gold) {
        retVal += gold + 'gold ';
      }

      var silver = Math.floor(itemData.SellAmount / 100) % 100;
      if (silver) {
        retVal += silver + 'silver ';
      }

      var copper = itemData.SellAmount % 100;
      if (copper) {
        retVal += copper + 'copper ';
      }
    }
    return retVal;
  };

  $scope.getServerStorage = function () {
    var itemData = itemFactory.getItemData($scope.item);
    var retVal = '';

    if (itemData && 'IsCash' in itemData && itemData.IsCash == 0) {
      if (itemData && 'AbleWStorage' in itemData) {
        if (itemData.AbleWStorage == 1) {
          retVal = 'can server storage';
        } else if (itemData.AbleWStorage == 0) {
          if (itemData && 'Reversion' in itemData && itemData.Reversion) {
            retVal = 'not transferable';
          }
        }
      }

      if (itemData && 'Reversion' in itemData) {
        if (retVal.length) {
          retVal += ', ';
        }

        if (itemData.Reversion == 0) {
          retVal += 'can trade';
        } else if (itemData.Reversion == 1) {
          retVal += 'not tradable ';
        }
      }
    }
    return retVal;
  };

  $scope.getMoreInfo = function () {
    var sealTimes = 0;
    var numStamps = 0;

    if ($scope.moreInfoLoaded()) {
      var itemData = itemFactory.getItemData($scope.item);

      if (itemData && 'IsCash' in itemData && itemData.IsCash == 0) {
        if (itemData && 'SealID' in itemData && 'SealCount' in itemData) {
          sealTimes = itemData.SealCount;

          var sealData = dntData.find('sealcounttable.lzjson', 'Type2', itemData.SealID);
          if (sealData && sealData.length > 0 && sealData[0].Type1 == 0) {

            var colName = 'Count0';
            if ($scope.item.enchantmentNum) {
              colName = 'Count' + $scope.item.enchantmentNum;
            }

            if (colName in sealData[0]) {
              numStamps = sealData[0][colName];
            }
          }
        }
      } else if (itemData && 'IsCash' in itemData && 'CashTradeCount' in itemData && 'Reversion' in itemData && 'AbleWStorage' in itemData) {
        if (itemData.Reversion == 2) {
          if (itemData.CashTradeCount) {
            return 'can server storage, cash trade count: ' + itemData.CashTradeCount;
          } else {
            return 'can server storage, can use warranty';
          }
        } else if (itemData.AbleWStorage) {
          return 'can server storage';
        } else {
          return 'not tradable';
        }
      }
    }

    if (sealTimes && numStamps) {
      return 'can stamp ' + sealTimes + ' times using ' + numStamps + '  stamps';
    } else {
      return '';
    }
  };

  $scope.moreInfoLoaded = function () {
    return dntData.isLoaded($scope.item.fileName + '.lzjson') && dntData.isLoaded('sealcounttable.lzjson');
  };

  $scope.loadMoreInfo = function () {
    dntData.init($scope.item.fileName + '.lzjson', null, $timeout);
    dntData.init('sealcounttable.lzjson', null, $timeout);
  };

  $scope.handleChange = function () {
    // console.log('changes');
    if ($scope.item.itemSource != 'custom') {
      $location.search('i', exportLinkHelper.encodeItem($scope.item));
    } else {
      setFullStats();
      $scope.item = angular.copy($scope.item);
    }
    getBuilds();
  };

  function getJobName() {
    var allJobs = jobs.getAllJobs();
    angular.forEach(allJobs, function (job, index) {
      if (job.id == $scope.item.needJobClass) {
        $scope.jobName = job.name;
      }
    });
  }

  function init() {
    getBuilds();
    $scope.preInitItem = $scope.item;
    $scope.item = null;

    var anyToLoad = false;

    angular.forEach(exportLinkHelper.getDntFiles($scope.preInitItem), function (columns, fileName) {
      if (!dntData.isLoaded(fileName)) {
        dntData.init(fileName, columns, reportProgress, tryInit);
        anyToLoad = true;
      }
    });

    if (!translations.isLoaded()) {
      translations.init(reportProgress, tryInit);
      anyToLoad = true;
    }

    if (!jobs.isLoaded()) {
      jobs.init(reportProgress, tryInit);
      anyToLoad = true;
    }

    if (!anyToLoad) {
      tryInit();
    }
  }
  init();

  function isLoaded() {
    var anyDntToLoad = false;
    angular.forEach(exportLinkHelper.getDntFiles($scope.preInitItem), function (columns, fileName) {
      if (!dntData.isLoaded(fileName)) {
        anyDntToLoad = true;
      }
    });

    return !anyDntToLoad && translations.isLoaded() && jobs.isLoaded();
  }

  function tryInit() {
    if (isLoaded()) {
      $scope.item = exportLinkHelper.reloadItem($scope.preInitItem);
      if ($scope.item == null) {
        return;
      }

      setFullStats();
      $window.document.title = 'dngearsim | ' + $scope.item.name;
      if ($scope.item.itemSource != 'custom') {

        if ($scope.item.typeName == 'skills') {
          if (!$scope.item.pve || $scope.item.pve != 'pvp') {
            $scope.item.pve = 'pve';
          } else {
            $scope.item.pve = 'pvp';
          }
        } else {
          if ($scope.item.needJobClass > 0) {
            getJobName();
          }
        }

        setFileName();
      }

      setupTabs();
    }
  }

  function setupTabs() {
    var itemData = itemFactory.getItemData($scope.item);
    if (itemData.DisjointDrop1 > 0) {
      $scope.canExtract = true;
    }

    if ((itemData.Type == 0 || itemData.Type == 1) && $scope.item.enchantmentNum > 0) {
      $scope.canTransfer = true;
    }

    if ($scope.item.setId) {
      $scope.isInSet = true;
    }

    if ($scope.item.typeId == 5) {
      $scope.isPlate = true;
    }

    if ($scope.item.typeId == 46 || $scope.item.typeId == 8 || $scope.item.typeId == 112 || $scope.item.typeId == 122 || $scope.item.typeId == 142 || $scope.item.typeId == 160) {
      $scope.hasContents = true;
      $scope.detail = 'contents';
    } else if ($scope.item.typeName != null) {
      $scope.canUse = true;
      $scope.detail = 'use';
    } else if ($scope.canExtract) {
      $scope.detail = 'extract';
    } else if ($scope.canTransfer) {
      $scope.detail = 'transfer';
    } else if ($scope.isPlate) {
      $scope.detail = 'plate';
    } else {
      $scope.detail = 'attainment';
    }
  }

  function setFileName() {
    if (!$scope.item.fileName) {
      if ($scope.item.itemSource in items && items[$scope.item.itemSource].mainDnt) {
        $scope.item.fileName = items[$scope.item.itemSource].mainDnt.replace('.lzjson', '').replace('.json', '').replace('.optimised', '');
      }
    }
  }

  function setFullStats() {
    // full stats are cleared when publishing builds
    $scope.item.fullStats = $scope.item.stats;

    if ($scope.item.enchantmentStats != null && $scope.item.enchantmentStats.length > 0) {
      $scope.item.fullStats = hCodeValues.mergeStats($scope.item.enchantmentStats, $scope.item.fullStats);
    }

    if ($scope.item.sparkStats != null && $scope.item.sparkStats.length > 0) {
      $scope.item.fullStats = hCodeValues.mergeStats($scope.item.sparkStats, $scope.item.fullStats);
    }
  }

  function reportProgress(msg) {
    // $scope.progress += '|' + msg;
    // console.log('progress: ' + msg);
  }

  function getBuilds() {
    var builds = saveHelper.getSavedItems();
    $scope.builds = builds;
  }
}]);
'use strict';

angular.module('dnsim').controller('ExportCtrl', ['$scope', '$window', 'saveHelper', function ($scope, $window, saveHelper) {
  'use strict';

  document.body.className = 'default-back';
  $window.document.title = 'dngearsim | EXPORT';

  var rawSavedData = saveHelper.getSavedItems();
  $scope.exportData = JSON.stringify(rawSavedData, null, 1);

  $scope.save = function () {
    localStorage.setItem('savedItems', LZString.compressToUTF16($scope.exportData));
  };
}]);
'use strict';

angular.module('dnsim').controller('HeaderCtrl', [function () {
  'use strict';

  var vm = this;
}]).directive('dngearsimHeader', function () {
  return {
    templateUrl: 'ui/nav/header.html'
  };
});
'use strict';

angular.module('dnsim').controller('NavCtrl', ['$scope', '$location', 'translations', 'region', 'itemCategory', 'saveHelper', function ($scope, $location, translations, region, itemCategory, saveHelper) {
  'use strict';

  try {
    var noLocationMenu = [];
    var normalMenu = [{ path: 'builds', name: 'builds', icon: 'menu-hamburger' }, { path: 'search', name: 'search', icon: 'search' }];

    var buildAction = { path: 'build', name: 'build' };

    var withBuildMenu = [{ path: 'builds', name: 'builds', icon: 'menu-hamburger' }, { path: 'search', name: 'search', icon: 'search' }, buildAction];

    region.init();

    $scope.isSearch = function () {
      return $location.path().indexOf('/search') == 0;
    };

    $scope.isLoading = function () {
      return translations.startedLoading && !translations.isLoaded() && region.tlocation != null && region.tlocation.url != '' && !$scope.noRegion();
    };

    $scope.noRegion = function () {
      return region.dntLocation == null;
    };

    $scope.isHttpOnly = function () {
      return location.protocol != 'https:' && location.hostname != 'localhost';
    };

    $scope.getActions = function () {
      try {
        var menu = null;

        var currentBuild = saveHelper.getCurrentBuild();
        if (currentBuild) {
          if (!$scope.savedItems || !(currentBuild in $scope.savedItems)) {
            // console.log('loading saved items');
            $scope.savedItems = saveHelper.getSavedItems();
          }

          if (!(currentBuild in $scope.savedItems)) {
            currentBuild = null;
          }
        }

        if (region.dntLocation != null && region.dntLocation.url == '') {
          menu = noLocationMenu;
        } else if (region.tlocation != null && region.tlocation.url == '') {
          menu = noLocationMenu;
        } else if (currentBuild && currentBuild != 'null') {
          menu = withBuildMenu;
          buildAction.path = 'build?buildName=' + currentBuild;
          buildAction.name = currentBuild;
          if (currentBuild in $scope.savedItems) {
            buildAction.build = $scope.savedItems[currentBuild];
          }
        } else if ($location.path() == '/view-group' || region.dntLocation == null) {
          menu = normalMenu;
        } else {
          menu = normalMenu;
        }

        var path = $location.path;
        angular.forEach(menu, function (value, key) {
          delete value.extraCss;
          if (path && path.length == 1) {
            if (value.path.length == 1) {
              value.extraCss = 'active';
            }
          } else if (value.path && value.path.length > 1 && path.indexOf('/' + value.path) == 0) {
            if (value.path != 'builds' || path == '/builds') {
              value.extraCss = 'active';
            }
          }
        });

        return menu;
      } catch (ex) {
        $scope.simError = ex.message;
        console.error(ex);
      }
    };
  } catch (ex) {
    $scope.simError = ex.message;
    console.error(ex);
  }
}]).directive('dngearsimNav', function () {
  return {
    templateUrl: 'ui/nav/nav.html'
  };
});
'use strict';

angular.module('dnsim').controller('SetupCtrl', ['$scope', '$window', '$route', '$timeout', 'translations', 'dntInit', 'dntReset', 'region', function ($scope, $window, $route, $timeout, translations, dntInit, dntReset, region) {
  'use strict';

  document.body.className = 'default-back';
  $window.document.title = 'dngearsim | SETUP';

  $scope.advancedSetup = false;
  $scope.isLoading = translations.startedLoading && !translations.isLoaded();
  $scope.translationResults = [];
  $scope.hostedFiles = region.hostedFiles;

  var noLocation = '';
  var sessionLocation = region.alternativeFiles.url;
  if (sessionLocation == null) {
    sessionLocation = noLocation;
  }

  $scope.location = sessionLocation;
  if ($scope.location == noLocation) {
    $scope.testResults = ['No location set'];
  } else {
    $scope.testResults = ['Using location ' + $scope.location];
  }

  $scope.setLocation = function (url) {
    $scope.location = url;
    $scope.isLoading = true;
    $scope.saveLocation();
    dntReset();

    $scope.translationResults = [];
    var existingFile = localStorage.getItem('UIStrings_file');
    if (existingFile == null || existingFile.indexOf(url) == -1) {
      sessionStorage.removeItem('UIStrings');
    }
    translations.reset();
    translations.location = url;
    translations.init(progressTranslations, translationsStatus);
  };

  $scope.resetSessionData = function () {
    $scope.testResults = ['session data reset.. reloading page'];
    region.tlocation = null;
    region.dntLocation = null;
    translations.reset();
    sessionStorage.clear();
    localStorage.clear();
    this.saveLocation();
    $timeout(function () {
      location.hash = '';
      location.reload(true);
    });
  };

  $scope.loadUiString = function () {
    $scope.translationResults = [];
    sessionStorage.removeItem('UIStrings');
    dntReset();
    translations.reset();
    translations.location = region.tlocation.url;
    translations.region = region.tlocation.region;
    translations.init(progressTranslations, translationsStatus);
  };

  function translationsStatus() {
    progressTranslations('current translations contain words like ' + translations.translate(329) + ', ' + translations.translate(323) + ' and ' + translations.translate(335));
    $scope.isLoading = false;
  }

  function progress(msg) {
    $timeout(function () {
      if ($scope.testResults != null) {
        $scope.testResults.push(msg);
      }
    });
  }

  function progressTranslations(msg) {
    $timeout(function () {
      if ($scope.translationResults != null) {
        $scope.translationResults.push(msg);
      }
    });
  }

  $scope.saveLocation = function () {
    dntReset();
    if ($scope.location != noLocation) {
      region.setCustomUrl($scope.location);

      region.init();
      if (region.alternativeFiles.region == region.tlocation.region) {
        translations.reset();
        translations.init(progressTranslations, translationsStatus);
      }
      $scope.testResults = ['Location saved', 'Using location ' + $scope.location];
    }
  };

  $scope.testLocation = function () {
    if ($scope.location != noLocation) {
      $scope.testResults = ['Using location ' + $scope.location, 'Loading all data used by the app'];

      translations.init(progress, function () {
        dntInit(progress);
      });
    }
  };
}]);
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').controller('BuildSearchCtrl', ['$routeParams', '$location', '$timeout', 'onlineService', 'jobs', buildSearch]);

  function buildSearch($routeParams, $location, $timeout, onlineService, jobs) {
    'use strict';

    var vm = this;

    vm.maxDisplay = 15;
    vm.totalNumResults = 0;

    jobs.init(null, function () {
      if ($routeParams.jobId) {
        vm.job = jobs.getById($routeParams.jobId);
        getClassBuilds();
      }
    });

    this.setJob = function () {
      $timeout(function () {
        $location.search('jobId', vm.job.id);
      });
    };

    this.showMoreResults = function (extra) {
      vm.maxDisplay = vm.totalNumResults + extra;
      vm.totalNumResults = 0;
    };

    vm.allResults = null;
    vm.getFilteredBuilds = function () {

      // init
      if (vm.allResults == null) {
        vm.allResults = [];
        for (var uid in vm.jobBuilds) {
          for (var buildName in vm.jobBuilds[uid]) {
            vm.allResults.push({
              uid: uid,
              name: buildName,
              data: vm.jobBuilds[uid][buildName]
            });
          }
        }
      }

      var results = [];
      for (var i = 0; i < vm.allResults.length; ++i) {

        var result = vm.allResults[i];
        if (vm.filter && vm.filter.length > 0) {
          var f = vm.filter.toUpperCase();
          if (result.name.toUpperCase().indexOf(f) == -1) {
            if (!result.data.guild || result.data.guild.toUpperCase().indexOf(f) == -1) {

              continue;
            }
          }
        }

        results.push(result);

        if (results.length >= vm.maxDisplay) {
          break;
        }
      }

      vm.totalNumResults = results.length;
      return results;
    };

    function getClassBuilds() {
      if (vm.job) {
        onlineService.getClassBuilds(vm.job).then(function (builds) {
          if (builds) {
            // console.log('got builds', builds);
            vm.jobBuilds = builds;
          } else {
            // console.log('no builds');
            vm.jobBuilds = {};
          }
        });
      }
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').controller('ProfileCtrl', ['$location', '$routeParams', 'onlineService', profile]);

  function profile($location, $routeParams, onlineService, saveHelper) {
    'use strict';

    var vm = this;
    vm.uid = $routeParams.uid;

    getSavedBuilds();
    getProfile();

    function getSavedBuilds() {
      onlineService.getUserBuilds(vm.uid).then(function (builds) {
        if (builds) {
          vm.storedBuilds = builds;
        } else {
          vm.storedBuilds = {};
        }
      });
    }

    function getProfile() {
      onlineService.getProfile(vm.uid).then(function (profile) {
        if (profile) {
          vm.profile = profile;
        } else {
          vm.profile = {};
        }
      });
    }

    this.load = function (buildName, build) {

      var newGroupName = saveHelper.importGroup(buildName, build.items);

      saveHelper.saveBuild(newGroupName, newGroupName, build);

      vm.builds = saveHelper.getSavedItems();

      $location.path('/build');
      $location.search('buildName', newGroupName);
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').controller('PublishCtrl', ['$location', 'saveHelper', 'onlineService', '$routeParams', 'region', publish]);

  function publish($location, saveHelper, onlineService, $routeParams, region) {
    'use strict';

    var vm = this;

    vm.show = $routeParams.show;

    onlineService.login().then(function (user) {
      getSavedBuilds();
      getProfile();

      vm.builds = saveHelper.getSavedItems();
    });

    function getSavedBuilds() {
      var user = vm.getUser();
      if (user) {
        onlineService.getUserBuilds(user.uid).then(function (builds) {
          if (builds) {
            vm.storedBuilds = builds;
          } else {
            vm.storedBuilds = {};
          }
        });
      }
    }

    function getProfile() {
      var user = vm.getUser();
      if (user) {
        onlineService.getProfile(user.uid).then(function (profile) {
          if (profile) {
            vm.profile = profile;
          } else {
            vm.profile = {};
          }
        });
      }
    }

    this.saveProfile = function () {
      onlineService.saveProfile(vm.profile).then(getProfile).catch(handleError);
    };

    this.getUser = function () {
      return onlineService.getUser();
    };

    this.save = function (buildName, build) {
      build.lastUpdate = new Date().getTime();
      onlineService.saveBuild(buildName, build).then(getSavedBuilds).catch(handleError);
      vm.publishBuild = null;
    };

    this.startPublish = function (buildName) {
      if (buildName in vm.storedBuilds) {
        if (!vm.builds[buildName].region) {
          vm.builds[buildName].region = vm.storedBuilds[buildName].region;
        }

        if (!vm.builds[buildName].about) {
          vm.builds[buildName].about = vm.storedBuilds[buildName].about;
        }

        if (!vm.builds[buildName].guild) {
          vm.builds[buildName].guild = vm.storedBuilds[buildName].guild;
        }
      }

      if (!vm.builds[buildName].region) {
        vm.builds[buildName].region = region.dntLocation.region;
      }

      vm.publishBuild = buildName;
    };

    function handleError(err) {
      console.log(err);
    }

    this.deleteAccount = function () {
      onlineService.deleteAccount(vm.storedBuilds);
    };

    this.getBuildLimit = function () {
      if (vm.profile && vm.profile.maxBuilds) {
        return vm.profile.maxBuilds;
      } else {
        return 15;
      }
    };

    this.getNumStoredBuilds = function () {
      return _.size(vm.storedBuilds);
    };

    this.getNumBuilds = function () {
      return _.size(vm.builds);
    };

    this.load = function (buildName, build) {

      var newGroupName = saveHelper.importGroup(buildName, build.items);

      saveHelper.saveBuild(newGroupName, newGroupName, build);

      vm.builds = saveHelper.getSavedItems();
    };

    this.signOut = function () {
      onlineService.signOut();
    };

    vm.deleteLocal = function (buildName) {
      vm.localToDelete = buildName;
    };

    vm.getAllBuildNames = function () {
      var allKeys = _.keys(vm.builds).concat(_.keys(vm.storedBuilds));
      return _.uniq(allKeys.sort(), true);
    };

    vm.reallyDeleteLocal = function (buildName) {
      saveHelper.updatedSavedItems(buildName, []);
      vm.localToDelete = null;
      vm.builds = saveHelper.getSavedItems();
    };

    vm.deleteServer = function (buildName) {
      vm.serverToDelete = buildName;
    };

    vm.reallyDeleteServer = function (buildName) {
      onlineService.deleteBuild(buildName, vm.storedBuilds[buildName]).then(getSavedBuilds);
      vm.serverToDelete = null;
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').controller('PublishedCtrl', ['onlineService', '$location', '$routeParams', 'saveHelper', 'statHelper', published]);

  function published(onlineService, $location, $routeParams, saveHelper, statHelper) {
    'use strict';

    var vm = this;
    vm.uid = $routeParams.uid;
    vm.buildName = $routeParams.buildName;

    getBuild();
    getProfile();

    vm.copyLocally = function () {
      var newGroupName = saveHelper.importGroup(vm.buildName, vm.build.items);

      saveHelper.saveBuild(newGroupName, newGroupName, vm.build);

      $location.path('/build');
      $location.search('buildName', newGroupName);
    };

    function getProfile() {
      onlineService.getProfile(vm.uid).then(function (profile) {
        if (profile) {
          vm.profile = profile;
        } else {
          vm.profile = {};
        }
      });
    }

    function getBuild() {
      onlineService.getBuild(vm.uid, vm.buildName).then(function (build) {
        if (build) {
          vm.build = build;
          vm.stats = statHelper.getBuildStats(build);
        } else {
          vm.build = {};
        }
      });
    }
  }
})();
'use strict';

angular.module('dnsim').controller('RegionCtrl', ['$timeout', '$route', '$routeParams', '$location', 'translations', 'region', '$http', function ($timeout, $route, $routeParams, $location, translations, region, $http) {
  'use strict';

  var vm = this;

  vm.override = region.getOverride();
  region.init();
  translations.init(function (msg) {
    // console.log(msg);
  }, function () {
    $timeout();
  });

  vm.region = region;
  vm.tHoverLocation = region.tlocation;
  vm.hoverLocation = region.dntLocation;
  vm.edit = region.dntLocation == null;
  vm.dntVersion = '';
  setDntVersion();

  function setDntVersion() {
    // console.log('setting version for ', vm.region.dntLocation);
    if (vm.region.dntLocation && vm.region.dntLocation.url) {
      $http.get(vm.region.dntLocation.url + '/Version.cfg').then(function (res) {
        if (res && res.data) {
          var newLineDetails = res.data.split('\r\n');
          if (newLineDetails.length) {
            var spaceDetails = newLineDetails[0].split(' ');
            if (spaceDetails.length > 1) {
              vm.dntVersion = 'v' + spaceDetails[1];
            }
          }
        }
      });
    }
  }

  vm.getDntLocation = function () {
    return region.dntLocation;
  };
  vm.getTlocation = function () {
    return region.tlocation;
  };

  vm.getHostedFiles = function () {
    // console.log('getting hosted files');
    return region.hostedFiles;
  };

  vm.getWorldName = function () {
    if (translations.isLoaded()) {
      return translations.translate(10169);
    } else {
      return '';
    }
  };

  vm.setTLocation = function (location) {
    region.setTLocation(location);
    vm.edit = false;
  };

  vm.setLocation = function (location) {
    if (!vm.override) {
      vm.setTLocation(null);
    }

    if ($routeParams.region) {
      $routeParams.region = location.region;
      $route.updateParams($routeParams);
      $route.reload();
    } else {
      region.setLocation(location);
    }
    vm.edit = false;
    setDntVersion();
  };

  vm.setOverride = function (value) {
    region.setOverride(value);
    vm.override = value;
    vm.edit = value;
  };
}]).directive('dngearsimRegion', function () {
  return {
    templateUrl: 'ui/region/region.html',
    controllerAs: 'ctrl'
  };
});
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dngearsimCustomItems', function () {
    return {
      scope: {},
      bindToController: {},
      controller: ['$window', 'saveHelper', '$location', 'hCodeValues', 'itemCategory', '$timeout', customItemCtrl],
      controllerAs: 'customItems',
      templateUrl: 'ui/search/custom-items.html'
    };
  });

  function customItemCtrl($window, saveHelper, $location, hCodeValues, itemCategory, $timeout) {
    'use strict';

    var vm = this;

    this.customItems = hCodeValues.customItems;

    this.maxDisplay = 10;
    this.currentResults = 0;

    if (this.nameSearch == null) {
      this.nameSearch = '';
    }

    this.getResults = function () {
      return this.customItems;
    };

    this.getNewStatName = function () {
      if (this.nameSearch == '' || this.nameSearch == null) {
        return 'unnamed custom item';
      } else {
        return this.nameSearch;
      }
    };

    this.createCustomItem = function () {
      if (this.nameSearch == '' || this.nameSearch == null) {
        this.nameSearch = this.getNewStatName();
      }
      $location.path('/item/_custom:.' + this.nameSearch);
    };
  }
})();
"use strict";

(function () {
  'use strict';

  everythingSearchCtrl.$inject = ["$window", "$timeout", "$routeParams", "$location", "hCodeValues", "region", "translations", "dntData"];
  angular.module('dnsim').directive('dngearsimEverythingSearch', function () {
    return {
      scope: {},
      bindToController: {
        nameSearch: '=nameSearch'
      },
      controller: everythingSearchCtrl,
      controllerAs: 'items',
      templateUrl: 'ui/search/everything-search.html'
    };
  });

  function everythingSearchCtrl($window, $timeout, $routeParams, $location, hCodeValues, region, translations, dntData) {

    var vm = this;

    vm.everything = null;
    vm.maxDisplay = 32;
    vm.currentResults = 0;
    vm.results = null;
    vm.minLevel = 1;
    vm.maxLevel = 99;
    vm.version = 'all';
    vm.versions = [vm.version];

    var minLevel = Number(localStorage.getItem('minLevel'));
    if ($routeParams.minLevel) {
      minLevel = Number($routeParams.minLevel);
    }
    if (minLevel > 0 && minLevel < 100) {
      vm.minLevel = minLevel;
    }
    vm.origMinLevel = minLevel;

    var maxLevel = Number(localStorage.getItem('maxLevel'));
    if ($routeParams.maxLevel) {
      maxLevel = Number($routeParams.maxLevel);
    }
    if (maxLevel > 0 && maxLevel < 100) {
      vm.maxLevel = maxLevel;
    }
    vm.origMaxLevel = maxLevel;

    if (!vm.nameSearch) {
      vm.nameSearch = localStorage.getItem('nameSearch');
      if ($routeParams.name) {
        vm.nameSearch = $routeParams.name;
      }
      if (vm.nameSearch == null) {
        vm.nameSearch = '';
      }
    }

    $window.document.title = 'dngearsim | ALL ITEM SEARCH';

    vm.initeverything = function () {
      if (dntData.isLoaded(fileName) && translations.isLoaded() && !vm.everything) {
        vm.everything = [];

        var versionMap = {};
        var datas = dntData.getData(fileName);
        // console.log(datas.length + ' everything');
        for (var i = 0; i < datas.length; ++i) {
          var data = datas[i];
          if (data.NameID > 0) {
            var item = {
              id: data.id,
              name: translations.translate(data.NameID, data.NameIDParam),
              rank: hCodeValues.rankNames[data.Rank],
              icon: data.IconImageIndex,
              levelLimit: data.LevelLimit,
              fileName: data.fileName,
              version: data.version
            };
            vm.everything.push(item);

            if (data.version) {
              versionMap[data.version] = true;
            }
          }
        }

        for (var version in versionMap) {
          vm.versions.push(version);
        }

        vm.everything = _.sortBy(vm.everything, 'name');

        $timeout(function () {
          vm.showMoreResults();
        });
      }
    };

    vm.getResults = function () {
      if (vm.everything == null) {
        vm.initeverything();
      }

      if (vm.everything == null) {
        return [];
      }

      var newResults = [];
      var numeverything = vm.everything.length;
      var curDisplay = 0;
      for (var i = 0; i < numeverything && curDisplay < vm.maxDisplay; ++i) {
        var e = vm.everything[i];

        if (e.levelLimit < vm.minLevel || e.levelLimit > vm.maxLevel || !e.levelLimit) {
          continue;
        }

        if (vm.version != 'all' && vm.version != e.version) {
          continue;
        }

        if (vm.nameSearch != '') {
          var nameSearches = vm.nameSearch.split(' ');
          if (nameSearches.length == 0) {
            nameSearches = [vm.nameSearch];
          }
          var allMatch = true;
          for (var ns = 0; ns < nameSearches.length; ++ns) {
            if (e.name && e.name.toString().toUpperCase().indexOf(nameSearches[ns].toUpperCase()) == -1) {
              allMatch = false;
              break;
            }
          }

          if (!allMatch) {
            continue;
          }
        }

        newResults.push(e);
        curDisplay++;
      }

      vm.totalNumResults = newResults.length;
      return newResults;
    };

    vm.changeSearch = function () {
      if (vm.minLevel != vm.origMinLevel) {
        localStorage.setItem('minLevel', vm.minLevel);
        $location.search('minLevel', vm.minLevel);
        vm.origMinLevel = vm.minLevel;
      }

      if (vm.maxLevel != vm.origMaxLevel) {
        localStorage.setItem('maxLevel', vm.maxLevel);
        $location.search('maxLevel', vm.maxLevel);
        vm.origMaxLevel = vm.maxLevel;
      }

      localStorage.setItem('nameSearch', vm.nameSearch);
      $location.search('name', vm.nameSearch);

      vm.maxDisplay = 64;
      vm.results = vm.getResults();
    };

    vm.showMoreResults = function () {
      $timeout(function () {
        // console.log('show more', vm.maxDisplay);
        vm.maxDisplay += 18;
        vm.results = vm.getResults();
      });
    };

    var fileName = 'all-items.lzjson';
    dntData.init(fileName, null, function () {}, function () {
      vm.initeverything();
    }, false);

    translations.init(null, vm.initeverything);
  }
})();
'use strict';

(function () {
  'use strict';

  var controllerParams = ['$scope', '$window', '$routeParams', '$timeout', '$location', '$route', 'translations', 'itemCategory', 'jobs', 'hCodeValues', 'itemFactory', 'region', 'saveHelper', itemSearchCtrl];

  angular.module('dnsim').controller('ItemSearchCtrl', controllerParams);

  function itemSearchCtrl($scope, $window, $routeParams, $timeout, $location, $route, translations, itemCategory, jobs, hCodeValues, itemFactory, region, saveHelper) {
    'use strict';

    var vm = this;

    vm.itemCategory = itemCategory.byPath($routeParams.cat);
    if (!vm.itemCategory) {
      var catName = localStorage.getItem('selectedItemCategory');
      if (!catName) {
        catName = 'titles';
      }

      vm.itemCategory = itemCategory.byName(catName);
      if (!vm.itemCategory || vm.itemCategory.hideInSearch) {
        catName = 'titles';
        vm.itemCategory = itemCategory.byName('titles');
      }
      if (vm.itemCategory) {
        // console.log('moving');
        $location.search('cat', vm.itemCategory.path);
        $route.reload();
      }
      return;
    }

    $window.document.title = 'dngearsim | SEARCH ' + vm.itemCategory.name.toUpperCase();

    vm.job = { id: -1, name: '' };
    vm.jobs = [vm.job];
    vm.allJobs = [];
    vm.minLevel = 1;
    vm.maxLevel = 99;
    vm.maxDisplay = 10;
    vm.totalNumResults = 0;
    vm.grades = hCodeValues.rankNames;
    vm.stat = { id: -1, name: '' };
    vm.stats = [vm.stat];
    vm.results = null;

    angular.forEach(hCodeValues.stats, function (stat, statId) {
      if (stat.searchable) {
        vm.stats.push(stat);
      }
    });

    var minLevel = Number(localStorage.getItem('minLevel'));
    if ($routeParams.minLevel) {
      minLevel = Number($routeParams.minLevel);
    }
    if (minLevel > 0 && minLevel < 100) {
      vm.minLevel = minLevel;
    }
    vm.origMinLevel = minLevel;

    var maxLevel = Number(localStorage.getItem('maxLevel'));
    if ($routeParams.maxLevel) {
      maxLevel = Number($routeParams.maxLevel);
    }
    if (maxLevel > 0 && maxLevel < 100) {
      vm.maxLevel = maxLevel;
    }
    vm.origMaxLevel = maxLevel;

    vm.nameSearch = localStorage.getItem('nameSearch');
    if ($routeParams.name) {
      vm.nameSearch = $routeParams.name;
    }
    if (!vm.nameSearch) {
      vm.nameSearch = '';
    }

    vm.origSavedSearchStatId = localStorage.getItem('searchStat');
    if ($routeParams.stat) {
      vm.origSavedSearchStatId = $routeParams.stat;
    }
    if (vm.origSavedSearchStatId > -1 && vm.origSavedSearchStatId in hCodeValues.stats) {
      vm.stat = hCodeValues.stats[vm.origSavedSearchStatId];
    }

    vm.navigate = function () {
      var catName = localStorage.getItem('selectedItemCategory');
      if (catName) {
        vm.itemCategory = itemCategory.byName(catName);
        if (vm.itemCategory) {
          // console.log('navigating to ', vm.itemCategory.path);
          $location.search('cat', vm.itemCategory.path);
          vm.save();
          $route.reload();
        }
      }
    };

    vm.save = function () {
      if (!vm.itemCategory.hideLevel) {
        if (vm.minLevel != vm.origMinLevel) {
          localStorage.setItem('minLevel', vm.minLevel);
          $location.search('minLevel', vm.minLevel);
          vm.origMinLevel = vm.minLevel;
        }

        if (vm.maxLevel != vm.origMaxLevel) {
          localStorage.setItem('maxLevel', vm.maxLevel);
          $location.search('maxLevel', vm.maxLevel);
          vm.origMaxLevel = vm.maxLevel;
        }
      } else {
        $location.search('minLevel', null);
        $location.search('maxLevel', null);
      }

      if (!vm.itemCategory.hideJob) {
        if (vm.job != null) {
          if (vm.origJobNumber != vm.job.id) {
            localStorage.setItem('jobNumber', vm.job.id);
            if (vm.job.id > -1) {
              $location.search('job', vm.job.id);
            } else {
              $location.search('job', null);
            }
            vm.origJobNumber = vm.job.id;
          }
        }
      } else {
        $location.search('job', null);
      }

      if (vm.stat) {
        if (vm.origSavedSearchStatId != vm.stat.id) {
          localStorage.setItem('searchStat', vm.stat.id);
          if (vm.stat.id > -1) {
            $location.search('stat', vm.stat.id);
          } else {
            $location.search('stat', null);
          }

          vm.origSavedSearchStatId = vm.stat.id;
        }
      }

      localStorage.setItem('nameSearch', vm.nameSearch);
      $location.search('name', vm.nameSearch);
    };

    function init() {
      jobs.init(reportProgress, jobInit);
    }

    function reportProgress(msg) {
      // console.log('progress: ' + msg);
    }

    function jobInit() {
      // console.log('called the job init func');
      if (translations.isLoaded() && jobs.isLoaded()) {
        // console.log('trying to init jobs');
        // console.log('job dropdown should be set');
        var newJobs = jobs.getFinalJobs();

        newJobs.splice(0, 0, vm.jobs[0]);
        vm.jobs = newJobs;
        vm.allJobs = jobs.getAllJobs();

        var lastJobNumber = Number(localStorage.getItem('jobNumber'));
        if ($routeParams.job && $routeParams.job) {
          lastJobNumber = Number($routeParams.job);
        }
        if (lastJobNumber != null) {
          angular.forEach(newJobs, function (value, key) {
            if (value.id == lastJobNumber) {
              vm.job = value;
              return;
            }
          });
        }

        itemCategory.init(vm.itemCategory.name, loadResults);
      }
    }

    vm.rankChecked = hCodeValues.checkedRank;

    vm.changeSearch = function () {
      vm.save();
      loadResults();
    };

    function loadResults() {
      vm.maxDisplay = 24;
      vm.results = getResults();
    }

    function getResults() {
      var allItems = itemCategory.getItems(vm.itemCategory.name);
      if (allItems == null) {
        return null;
      }

      allItems = allItems.sort(function (item1, item2) {
        return item2.levelLimit - item1.levelLimit;
      });

      var pcStatId = -1;
      if ('pc' in vm.stat) {
        pcStatId = vm.stat.pc;
      }

      var altStatId = -1;
      if ('altStat' in vm.stat) {
        altStatId = vm.stat.altStat;
      }

      var statVals = [];
      var newResults = [];
      var numEquip = allItems.length;
      var curDisplay = 0;
      for (var i = 0; i < numEquip && (curDisplay < vm.maxDisplay || vm.stat.id >= 0); ++i) {
        var e = allItems[i];
        if (e) {

          if (!vm.itemCategory.hideLevel) {
            if (e.levelLimit < vm.minLevel || e.levelLimit > vm.maxLevel) {
              continue;
            }
          }

          if (!vm.itemCategory.hideRank) {
            if (e.rank && !vm.rankChecked[e.rank.id]) {
              continue;
            }
          }

          if (!vm.itemCategory.hideJob) {
            if (vm.job && vm.job.id > -1) {
              if (!vm.job.isClassJob(e.needJobClass)) {
                continue;
              }
            }
          }

          itemFactory.initItem(e);
          if (e.typeName != vm.itemCategory.name) {
            continue;
          }
          // console.log('name filter', vm.nameSearch); 

          if (vm.nameSearch != '') {
            // console.log('filtering on name');
            var nameSearches = vm.nameSearch.split(' ');
            if (!nameSearches.length) {
              nameSearches = [vm.nameSearch];
            }
            var allMatch = true;
            for (var ns = 0; ns < nameSearches.length; ++ns) {
              if (e.name.toUpperCase().indexOf(nameSearches[ns].toUpperCase()) == -1) {
                allMatch = false;
                break;
              }
            }

            if (!allMatch) {
              continue;
            }
          }

          if (vm.stat.id >= 0) {
            var statFound = false;

            var statVal = {};
            for (var s = 0; s < e.stats.length; ++s) {
              var stat = e.stats[s];
              if (stat.id == vm.stat.id) {
                statFound = true;
                statVal.i = curDisplay;
                statVal.s = Number(stat.max);
                break;
              } else if (stat.id == pcStatId) {
                statFound = true;
                statVal.i = curDisplay;
                statVal.s = Number(stat.max);
              } else if (stat.id == altStatId) {
                statFound = true;
                statVal.i = curDisplay;
                statVal.s = Number(stat.max);
              }
            }

            if (!statFound) {
              continue;
            } else {
              statVals.push(statVal);
            }
          }

          newResults.push(e);
          curDisplay++;
        }
      }

      if (vm.stat.id >= 0) {

        var currentResults = Math.min(curDisplay, vm.maxDisplay);

        statVals = statVals.sort(function (value1, value2) {
          return value2.s - value1.s;
        });

        var statResults = [];
        for (var i = 0; i < currentResults; ++i) {
          statResults.push(newResults[statVals[i].i]);
        }
        newResults = statResults;
      }

      vm.totalNumResults = newResults.length;

      return newResults;
    }

    vm.showMoreResults = function () {
      $timeout(function () {
        vm.maxDisplay += 18;
        vm.results = getResults();
      });
    };

    region.init();
    translations.init(reportProgress, init);
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dngearsimSkillSearch', function () {
    return {
      scope: {},
      bindToController: {
        job: '=job',
        jobs: '=jobs'
      },
      controller: ['$window', '$timeout', 'saveHelper', 'region', 'jobs', 'translations', 'dntData', 'hCodeValues', 'itemCategory', '$location', skillSearchCtrl],
      controllerAs: 'skillSearch',
      templateUrl: 'ui/search/skill-search.html'
    };
  });

  function skillSearchCtrl($window, $timeout, saveHelper, region, jobs, translations, dntData, hCodeValues, itemCategory, $location) {

    var vm = this;

    vm.allJobs = [];
    vm.dntName = '';
    vm.skills = [];
    vm.loadedJobId = -1;

    vm.itemCategory = itemCategory.byName('skills');

    vm.nameSearch = localStorage.getItem('nameSearch');
    if (!vm.nameSearch) {
      vm.nameSearch = '';
    }

    region.init();
    if (translations.isLoaded()) {
      init();
    } else {
      translations.init(reportProgress, function () {
        $timeout(init);
      });
    }

    vm.navigate = function () {
      $timeout(function () {
        if (vm.itemCategory) {
          $location.path(vm.itemCategory.path);
        }
      });
    };

    vm.isLoading = function () {

      if (!translations.isLoaded()) {
        // console.log('transations not loaded');
        if (!translations.startedLoading) {
          translations.init(reportProgress, function () {});
        }

        return true;
      }

      var baseName = jobs.getBaseJobName(vm.job);
      var dntName = getDntName(baseName);
      if (dntName) {
        if (!dntData.isLoaded(dntName)) {
          return true;
        }
      }

      return false;
    };

    function getDntName(baseClassName) {
      // console.log('got base class :' + baseClassName);
      if (baseClassName != null) {
        return 'skilltable_character' + baseClassName.toLowerCase() + '.lzjson';
      } else {
        return null;
      }
    }

    function getSkills() {
      // console.log('getting skills for ' + vm.job.name);
      if (vm.loadedJobId == vm.job.id) {
        return vm.skills;
      } else {

        var baseJobNames = [];
        if (vm.job.id >= 0) {
          var baseName = jobs.getBaseJobName(vm.job);
          baseJobNames.push(baseName);
        }

        angular.forEach(baseJobNames, function (baseName, index) {
          var dntName = getDntName(baseName);
          if (dntName) {
            if (!dntData.isLoaded(dntName)) {
              // console.log('loading skills for ' + baseName);
              dntData.init(dntName, null, reportProgress, function () {
                $timeout(function () {
                  setupSkills(baseJobNames, vm.job);
                });
              });
            } else {
              setupSkills(baseJobNames, vm.job);
            }
          }
        });
      }
    }

    function setupSkills(baseJobNames, job) {

      vm.skills = [];
      var allReady = true;
      angular.forEach(baseJobNames, function (baseName, index) {
        var dntName = getDntName(baseName);
        if (!dntData.isLoaded(dntName)) {
          allReady = false;
        }
      });

      if (allReady) {
        angular.forEach(baseJobNames, function (baseName, index) {
          var dntName = getDntName(baseName);

          var skills = dntData.getData(dntName);
          var numSkills = skills.length;
          for (var s = 0; s < numSkills; ++s) {
            if (skills[s].NameID == 0) {
              continue;
            }

            if (skills[s].EffectClass1 > 0 || skills[s].EffectClass2 > 0 || skills[s].EffectClass3 > 0 || skills[s].EffectClass4 > 0 || skills[s].EffectClass5 > 0 || skills[s].EffectClass6 > 0) {

              var newItem = { d: skills[s] };

              newItem.id = skills[s].id;
              newItem.typeName = 'skills';
              newItem.itemSource = 'skills';
              newItem.name = translations.translate(skills[s].NameID, skills[s].NameIDParam);
              newItem.needJobClass = skills[s].NeedJob;
              newItem.rank = hCodeValues.rankNames[0];
              newItem.baseJobName = baseName.toLowerCase();
              newItem.icon = skills[s].IconImageIndex;

              vm.skills.push(newItem);
            }
          }
        });

        vm.loadedJobId = job.id;
      }
    }

    vm.getResults = function () {

      var skills = getSkills();
      if (skills == null) {
        return [];
      }

      if (vm.job && vm.job.id >= 0) {
        localStorage.setItem('jobNumber', vm.job.id);
      }
      localStorage.setItem('nameSearch', vm.nameSearch);

      var newResults = [];
      var numSkills = skills.length;
      var curDisplay = 0;
      for (var i = 0; i < numSkills; ++i) {
        var e = skills[i];

        if (vm.nameSearch != '') {
          var nameSearches = vm.nameSearch.split(' ');
          if (!nameSearches.length) {
            nameSearches = [vm.nameSearch];
          }
          var allMatch = true;
          for (var ns = 0; ns < nameSearches.length; ++ns) {
            if (e.name && e.name.toString().toUpperCase().indexOf(nameSearches[ns].toUpperCase()) == -1) {
              allMatch = false;
              break;
            }
          }

          if (!allMatch) {
            continue;
          }
        }

        if (vm.job.id >= 0 && !vm.job.isClassJob(e.needJobClass)) {
          continue;
        }

        newResults.push(e);
      }
      return newResults;
    };

    function reportProgress(msg) {
      // console.log('progress: ' + msg);
    }

    function jobInit() {
      if (translations.isLoaded() && jobs.isLoaded()) {
        var newJobs = jobs.getFinalJobs();

        if (vm.jobs && vm.jobs.length) {
          newJobs.splice(0, 0, vm.jobs[0]);
        }
        vm.jobs = newJobs;
        vm.allJobs = jobs.getAllJobs();

        var lastJobNumber = Number(localStorage.getItem('jobNumber'));
        // console.log('using job', lastJobNumber);
        if (lastJobNumber != null) {
          angular.forEach(newJobs, function (value, key) {
            if (value.id == lastJobNumber) {
              vm.job = value;
              // console.log('using job', value);
              return;
            }
          });
        }

        vm.getResults();
      }
    }

    function init() {
      // console.log('skill init');
      if (jobs.isLoaded()) {
        $timeout(jobInit);
      } else {
        jobs.init(reportProgress, function () {
          $timeout(jobInit);
        });
      }
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimChooseClass', chooseClass);

  function chooseClass() {
    return {
      restrict: 'E',
      scope: {},
      bindToController: {
        job: '=job',
        onSetJob: '&onSetJob'
      },
      templateUrl: 'ui/widgets/choose-class.html',
      controllerAs: 'ctrl',
      controller: ['$window', '$location', '$routeParams', '$timeout', 'saveHelper', 'dntData', 'jobs', 'hCodeValues', 'itemColumnsToLoad', 'character', chooseClassController]
    };
  }

  function chooseClassController($window, $location, $routeParams, $timeout, saveHelper, dntData, jobs, hCodeValues, itemColumnsToLoad, character) {
    this.getFinalJobs = function () {
      var allJobs = jobs.getFinalJobs();
      var finalJobs = [];
      for (var j = 0; j < allJobs.length; ++j) {
        if (jobs.getBaseJobName(allJobs[j]) == this.bJob) {
          finalJobs.push(allJobs[j]);
        }
      }
      return finalJobs;
    };

    this.getBaseJobs = function () {
      return jobs.getBaseJobs();
    };

    this.getJobName = function (englishName) {
      var allJobs = jobs.getAllJobs();
      for (var j = 0; j < allJobs.length; ++j) {
        if (allJobs[j].d.EnglishName == englishName) {
          return allJobs[j].name;
        }
      }
    };

    this.setJob = function (job) {
      this.job = job;
      if (job) {
        this.onSetJob();
      }
    };

    jobs.init(reportProgress, $timeout);
    function reportProgress(msg) {
      // console.log('progress: ' + msg);
    }
  }
})();
"use strict";

(function () {
  'use strict';

  dnsimCategoryLinksController.$inject = ["itemCategory", "$window", "translations", "$translate"];
  angular.module('dnsim').directive('dnsimCategoryLinks', dnsimCategoryLinks);

  function dnsimCategoryLinks() {
    return {
      restrict: 'E',
      scope: {},
      bindToController: {
        collapse: '=collapse',
        cat: '=cat',
        buildScreen: '=buildScreen',
        onChange: '&onChange'
      },
      templateUrl: 'ui/widgets/dnsim-category-links.html',
      controller: dnsimCategoryLinksController,
      controllerAs: 'ctrl'
    };
  };

  function dnsimCategoryLinksController(itemCategory, $window, translations, $translate) {

    var vm = this;

    vm.categories = itemCategory.categories;
    vm.collapsed = true;

    vm.shouldShow = function (action) {
      if (vm.buildScreen) {
        return !action.hideInBuild;
      } else {
        return !action.hideInSearch;
      }
    };

    vm.isLoading = function () {
      return !translations.loaded;
    };

    vm.setCategory = function (action) {

      if (vm.collapse) {
        // console.log('collapsing cat', action);
        vm.collapsed = !vm.collapsed;
        $window.scrollTo(0, 0);
      }

      // console.log('setting cat', action);
      if (vm.cat != action) {
        vm.cat = action;
        localStorage.setItem('selectedItemCategory', action.name);

        if (vm.onChange) {
          vm.onChange();
        }
      }
    };

    vm.getName = function (action) {
      if (action.tId) {
        return translations.translate(action.tId).toLowerCase();
      } else {
        return $translate.instant(action.name);
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimItemIcon', ['exportLinkHelper', '$location', 'region', dnsimItemIcon]);

  function dnsimItemIcon(exportLinkHelper, $location, region) {
    return {
      restrict: 'E',
      scope: {
        item: '=item'
      },
      templateUrl: 'ui/widgets/dnsim-item-icon.html',
      link: function link($scope, element, attrs) {

        $scope.$watch('item', function (newValue, oldValue) {
          if (newValue) {
            $scope.iconImage = $scope.getIcon();
          }
        });

        $scope.getIcon = function () {
          if ($scope.item && $scope.item.icon > 0) {
            var fileIndex = Math.floor($scope.item.icon / 200 + 1);

            var prefix;
            if ($scope.item.typeName == 'skills') {
              prefix = 'skillicon';
            } else {
              prefix = 'itemicon';
            }

            if (fileIndex > 9) {
              return prefix + fileIndex + '.png';
            } else {
              return prefix + '0' + fileIndex + '.png';
            }
          }
          return null;
        };

        $scope.iconImage = $scope.getIcon();

        $scope.getIconXPostion = function () {
          if ($scope.item && $scope.item.icon > 0) {
            return $scope.item.icon % 10 * 40 + 5;
          }
          return 0;
        };

        $scope.getIconYPostion = function () {
          if ($scope.item && $scope.item.icon > 0) {
            return Math.floor($scope.item.icon % 200 / 10) * 40 + 4;
          }
          return 0;
        };
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimItemLink', ['exportLinkHelper', '$location', 'region', dnsimItemLink]);

  function dnsimItemLink(exportLinkHelper, $location, region) {
    return {
      restrict: 'E',
      scope: {
        item: '=item',
        noClick: '=noClick'
      },
      templateUrl: 'ui/widgets/dnsim-item-link.html',
      link: function link($scope, element, attrs) {
        $scope.itemLink = 'item/?region=' + region.dntLocation.region + '&i=' + exportLinkHelper.encodeItem($scope.item);
        // var basePath = angular.element(document.querySelector('base')).attr('href');

        $scope.$watch('item', function (newValue, oldValue) {
          if (newValue) {
            $scope.itemLink = 'item/?region=' + region.dntLocation.region + '&i=' + exportLinkHelper.encodeItem($scope.item);
          }
        });
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimJobIcon', [dnsimJobIcon]);

  function dnsimJobIcon() {
    return {
      restrict: 'E',
      scope: {},
      bindToController: {
        item: '=item',
        small: '=small'
      },
      templateUrl: 'ui/widgets/dnsim-job-icon.html',
      controller: dnsimJobIconController,
      controllerAs: 'ctrl'
    };
  }

  function dnsimJobIconController() {

    if (this.small) {
      this.sizeValue = '205px 205px';
      this.iconSize = 22;
      this.iconOffset = 0;
    } else {
      this.sizeValue = '410px 410px';
      this.iconSize = 44;
      this.iconOffset = 5;
    }

    this.getIconXPostion = function () {
      if (this.item && this.item.d && this.item.d.JobIcon > 0) {
        return this.item.d.JobIcon % 9 * this.iconSize + this.iconOffset;
      }
      return 0;
    };

    this.getIconYPostion = function () {
      if (this.item && this.item.d && this.item.d.JobIcon > 0) {
        return Math.floor(this.item.d.JobIcon / 9) * this.iconSize + this.iconOffset;
      }
      return 0;
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimLoading', ['dntData', 'translations', '$timeout', 'region', dnsimLoading]);

  function dnsimLoading(dntData, translations, $timeout, region) {
    'use strict';

    return {
      restrict: 'E',
      transclude: true,
      scope: {
        alsoShowFor: '=alsoShowFor'
      },
      templateUrl: 'ui/widgets/dnsim-loading.html',
      link: function link($scope, element, attrs) {
        $scope.$on('TRANSLATION_LOAD_EVENT', function () {
          $scope.setLoadCount();
        });

        $scope.$on('DNTDATA_LOAD_EVENT', function () {
          $scope.setLoadCount();
        });

        $scope.$on('DNTDATA_LOAD_ERROR', function () {
          $timeout(function () {
            $scope.loadError = true;
          });
        });

        $scope.$on('TRANSLATION_LOAD_ERROR', function () {
          $timeout(function () {
            $scope.loadError = true;
          });
        });

        $scope.numLoading = 0;
        $scope.setLoadCount = function () {
          $scope.noRegion = !region.dntLocation;

          var n = dntData.anyLoading();
          if (!translations.isLoaded()) {
            n++;
          }

          // $timeout(function() {
          if ($scope.numLoading < n || !$scope.totalToLoad) {
            $scope.totalToLoad = n;
          }
          $scope.numLoading = n;
          // });
          $timeout();
        };

        $scope.loadError = false;
        $scope.setLoadCount();
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimSelectAllOnClick', [dnsimSelectAllOnClick]);

  function dnsimSelectAllOnClick() {
    'use strict';

    return {
      restrict: 'A',
      link: function link(scope, element, attrs) {
        var hasSelectedAll = false;
        element.on('click', function ($event) {
          if (!hasSelectedAll) {
            try {
              //IOs, Safari, thows exception on Chrome etc
              this.selectionStart = 0;
              this.selectionEnd = this.value.length + 1;
              hasSelectedAll = true;
            } catch (err) {
              //Non IOs option if not supported, e.g. Chrome
              this.select();
              hasSelectedAll = true;
            }
          }
        });
        //On blur reset hasSelectedAll to allow full select
        element.on('blur', function ($event) {
          hasSelectedAll = false;
        });
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimStats', ['hCodeValues', '$translate', dnsimStats]);

  function dnsimStats(hCodeValues, $translate) {
    return {
      restrict: 'A',
      scope: {
        stats: '=stats',
        build: '=build',
        altStats: '=altStats',
        separator: '=separator',
        filter: '=filter',
        numInSet: '=numInSet'
      },
      link: function link($scope, element, attrs) {

        var sep;
        if (!$scope.separator) {
          sep = '';
        } else {
          sep = '&nbsp;' + $scope.separator + ' ';
        }

        var addedElements = [];
        var originalDisplay = element.css('display');

        function showStats() {
          element.css('display', 'none');
          var stats = $scope.stats;
          if (!stats) {
            stats = $scope.altStats;
          }

          angular.forEach(addedElements, function (value, key) {
            value.remove();
          });

          var first = true;
          var lastElement = element;

          function append(text) {
            var newElement = element.clone();
            newElement.css('display', originalDisplay);
            newElement.html(text);

            lastElement.after(newElement);
            lastElement = newElement;
            addedElements.push(newElement);
          }

          // get stats that are used to summarise
          var summaryForStats = {};
          angular.forEach(stats, function (stat, key) {
            var def = hCodeValues.stats[stat.id];
            if (def && def.summaryFor) {
              summaryForStats[def.summaryFor] = stat;
            }
          });

          angular.forEach(stats, function (stat, key) {
            var output = '';

            // console.log('processing stat', stat);

            if (stat.id in hCodeValues.stats) {

              var def = hCodeValues.stats[stat.id];
              if (!$scope.filter && 'hide' in def && def.hide) {
                return;
              }

              if ($scope.filter && !def[$scope.filter]) {
                return;
              }

              if (def.summaryFor) {
                return;
              }
              // console.log('no summaryFor');

              if (!first) {
                output += sep;
              }
              first = false;

              if ('needSetNum' in stat) {
                if (stat.needSetNum <= $scope.numInSet) {
                  output += '*';
                }
                output += stat.needSetNum + '&nbsp;';
              }

              output += '<strong>';

              if ($scope.build) {
                if (def.element == 'primary') {
                  var eleId = 0;
                  if ($scope.build.element) {
                    eleId = $scope.build.element.id;
                  }
                  output += $translate.instant(hCodeValues.elements[eleId].name) + '&nbsp;';
                } else if (def.element == 'secondary') {
                  var eleId = 0;
                  if ($scope.build.secondaryElement) {
                    eleId = $scope.build.secondaryElement.id;
                  }
                  output += $translate.instant(hCodeValues.elements[eleId].name) + '&nbsp;';
                }
              }

              output += $translate.instant(def.name) + ':</strong>&nbsp;' + def.display(stat);
              if (def.combineWith > 0) {
                angular.forEach(stats, function (stat2, key2) {
                  if (stat2.id == def.combineWith) {
                    if (stat2.max != stat.max) {
                      output += '-' + def.display(stat2);
                    }
                  }
                });
              }

              if (stat.id in summaryForStats) {
                var sStat = summaryForStats[stat.id];
                var sDef = hCodeValues.stats[sStat.id];
                output += '&nbsp;|&nbsp;<em>' + sDef.display(sStat);
                output += '</em>';
              }
            } else {
              if (!first) {
                output += sep;
              }
              first = false;

              if ('needSetNum' in stat) {
                output += stat.needSetNum + '-Increases&nbsp;';
              }

              output += stat.id + ':&nbsp;' + stat.max;
            }

            append(output);
          });
        }

        $scope.$watch('stats', function (newValue, oldValue) {
          if (newValue) {
            showStats();
          }
        });

        $scope.$watch('altStats', function (newValue, oldValue) {
          if (newValue) {
            showStats();
          }
        });

        $scope.$watch('numInSet', function (newValue, oldValue) {
          if (newValue >= 0) {
            showStats();
          }
        });
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimStringToNumber', dnsimStringToNumber);

  function dnsimStringToNumber() {
    return {
      require: 'ngModel',
      link: function link(scope, element, attrs, ngModel) {
        ngModel.$parsers.push(function (value) {
          return '' + value;
        });
        ngModel.$formatters.push(function (value) {
          return parseFloat(value, 10);
        });
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').directive('dnsimStringToPercent', dnsimStringToNumber);

  function dnsimStringToNumber() {
    return {
      require: 'ngModel',
      link: function link(scope, element, attrs, ngModel) {
        ngModel.$parsers.push(function (value) {
          return '' + value / 100.0;
        });
        ngModel.$formatters.push(function (value) {
          return parseFloat(value, 10) * 100;
        });
      }
    };
  }
})();
'use strict';

(function () {
        'use strict';

        angular.module('dnsim').directive('fileChange', ['$parse', fileChangeFunction]);

        function fileChangeFunction($parse) {

                return {
                        restrict: 'A',
                        link: function link($scope, element, attrs) {

                                // Get the function provided in the file-change attribute.
                                // Note the attribute has become an angular expression,
                                // which is what we are parsing. The provided handler is 
                                // wrapped up in an outer function (attrHandler) - we'll 
                                // call the provided event handler inside the handler()
                                // function below.
                                var attrHandler = $parse(attrs['fileChange']);

                                // This is a wrapper handler which will be attached to the
                                // HTML change event.
                                var handler = function handler(e) {

                                        $scope.$apply(function () {

                                                // Execute the provided handler in the directive's scope.
                                                // The files variable will be available for consumption
                                                // by the event handler.
                                                attrHandler($scope, { $event: e, files: e.target.files });
                                        });
                                };

                                // Attach the handler to the HTML change event 
                                element[0].addEventListener('change', handler, false);
                        }
                };
        }
})();
"use strict";

(function () {
  'use strict';

  character.$inject = ["dntData", "itemColumnsToLoad", "jobs", "hCodeValues"];
  angular.module('dnsim').factory('character', character);
  function character(dntData, itemColumnsToLoad, jobs, hCodeValues) {

    var jobConversions = 'rebootplayerweighttable.lzjson';
    var statCaps = 'playercommonleveltable.lzjson';
    var jobBaseStats = 'playerleveltable.optimised.json';

    var heroLevels = 'heroleveltable.lzjson';
    var heroLevelPotentials = 'potentialtable_herolevel.lzjson';

    function reportProgress(msg) {
      // console.log('progress: ' + msg);
    }

    return {
      init: function init(complete) {
        jobs.init(reportProgress, complete);
        dntData.init(jobConversions, itemColumnsToLoad.jobConversionColsToLoad, reportProgress, complete, false);
        dntData.init(statCaps, itemColumnsToLoad.statCapColsToLoad, reportProgress, complete, false);
        dntData.init(jobBaseStats, itemColumnsToLoad.jobBaseStatColsToLoad, reportProgress, complete, false);
        dntData.init(heroLevels, null, reportProgress, complete, false);
        dntData.init(heroLevelPotentials, null, reportProgress, complete, false);
      },

      getHeroStats: function getHeroStats(heroLevel) {
        var heroStats = [];
        if (heroLevel > 0) {
          var index = dntData.findFast(heroLevels, 'id', heroLevel);
          if (index.length == 1) {
            var h = dntData.getRow(heroLevels, index[0]);
            if (h) {
              var pIndex = dntData.findFast(heroLevelPotentials, 'PotentialID', h.HeroLevelAbilityID);
              if (pIndex.length == 1) {
                var p = dntData.getRow(heroLevelPotentials, pIndex[0]);
                if (p) {
                  heroStats = hCodeValues.getStats(p);
                }
              }
            }
          }
        }
        return heroStats;
      },

      getStatCaps: function getStatCaps(level) {
        if (level > 0) {
          var index = dntData.findFast(statCaps, 'id', level);
          if (index.length == 1) {
            return dntData.getRow(statCaps, index[0]);
          }
        }

        return {};
      },

      getConversions: function getConversions(jobId) {
        if (jobId > 0) {
          var index = dntData.findFast(jobConversions, 'id', jobId);
          if (index.length == 1) {
            return dntData.getRow(jobConversions, index[0]);
          }
        }

        return {};
      },

      getBaseStats: function getBaseStats(level, jobId) {
        if (level > 0 && jobId > 0) {
          var index = dntData.findFast(jobBaseStats, 'id', Number(jobId) * 100 + Number(level) - 100);
          if (index.length == 1) {
            return dntData.getRow(jobBaseStats, index[0]);
          }
        }

        return {};
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('itemColumnsToLoad', [itemColumnsToLoad]);
  function itemColumnsToLoad() {
    return {
      mainDnt: {
        NameID: true, DescriptionID: true, NameIDParam: true, DescriptionIDParam: true,
        Type: true, TypeParam1: true, TypeParam2: true, TypeParam3: true, LevelLimit: true, NeedJobClass: true, Rank: true,
        State1: true, StateValue1: true, State1_Max: true,
        State2: true, StateValue2: true, State2_Max: true,
        State3: true, StateValue3: true, State3_Max: true,
        State4: true, StateValue4: true, State4_Max: true,
        State5: true, StateValue5: true, State5_Max: true,
        State6: true, StateValue6: true, State6_Max: true,
        State7: true, StateValue7: true, State7_Max: true,
        State8: true, StateValue8: true, State8_Max: true,
        State9: true, StateValue9: true, State9_Max: true,
        State10: true, StateValue10: true, State10_Max: true,
        EnchantID: true,
        SkillID: true,
        dragonjeweltype: true, AbleWStorage: true, ExchangeType: true, IconImageIndex: true, IsCash: true, DisjointDrop1: true, Disjointamount: true,
        TierName: true
      },
      partsDnt: {
        SetItemID: true
      },
      enchantDnt: {
        EnchantID: true, EnchantLevel: true, EnchantRatio: true, BreakRatio: true, MinDown: true, MaxDown: true, NeedCoin: true,
        DisjointDrop: true,
        NeedItemID1: true, NeedItemCount1: true, NeedItemID2: true, NeedItemCount2: true, NeedItemID3: true, NeedItemCount3: true, NeedItemID4: true, NeedItemCount4: true, NeedItemID5: true, NeedItemCount5: true, ProtectItemCount: true,
        State1: true, State1Value: true, State2: true, State2Value: true, State3: true, State3Value: true, State4: true, State4Value: true, State5: true, State5Value: true, State6: true, State6Value: true, State7: true, State7Value: true, State8: true, State8Value: true, State9: true, State9Value: true, State10: true, State10Value: true
      },
      potentialDnt: {
        PotentialID: true, PotentialNo: true, PotentialRatio: true,
        State1: true, State1Value: true,
        State2: true, State2Value: true,
        State3: true, State3Value: true,
        State4: true, State4Value: true,
        State5: true, State5Value: true,
        State6: true, State6Value: true,
        State7: true, State7Value: true,
        State8: true, State8Value: true,
        State9: true, State9Value: true,
        State10: true, State10Value: true,
        State11: true, State11Value: true,
        State12: true, State12Value: true,
        State13: true, State13Value: true,
        State14: true, State14Value: true,
        State15: true, State15Value: true,
        State16: true, State16Value: true
      },
      gemDnt: {
        Type: true
      },
      setDnt: null,
      sparkDnt: null,
      jobsDnt: {
        JobName: true, JobNumber: true, BaseClass: true, ParentJob: true, EnglishName: true, JobIcon: true
      },
      jobBaseStatColsToLoad: {
        Strength: true, Agility: true, Intelligence: true, Stamina: true, AggroperPvE: true, BaseMP: true
      },
      statCapColsToLoad: {
        Cbase: true,
        Cdefense: true,
        Ccritical: true,
        Cfinaldamage: true,
        CcriticalDamage: true
      },
      jobConversionColsToLoad: {
        HP: true, StrengthAttack: true, AgilityAttack: true, IntelligenceAttack: true, PhysicalDefense: true, MagicDefense: true, Critical: true, CriticalResistance: true, Stiff: true, StiffResistance: true, Stun: true, StunResistance: true, MoveSpeed: true, MoveSpeedRevision: true, DownDelay: true, ElementAttack: true, ElementDefense: true, ElementDefenseMin: true, ElementDefenseMax: true, StrengthIntelligenceToCriticalDamage: true
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('dntData', ['$rootScope', '$timeout', dntData]);

  function dntData($rootScope, $timeout) {

    function createLoader(dntLocation, file, colsToLoad) {

      var loader = {
        reader: new DntReader(),

        loaded: false,
        startedLoading: false,

        file: file,

        dntLocation: dntLocation,
        // progressCallback: null,
        completeCallbacks: [],

        init: function init(progress, complete, ignoreErrors) {

          if (this.loaded) {
            if (complete) {
              complete();
            }
          } else {
            // this.progressCallback = progress;
            if (complete) {
              this.completeCallbacks.push(complete);
            }

            if (!this.startedLoading) {
              this.startedLoading = true;
              var t = this;

              this.reader.colsToLoad = colsToLoad;

              if (this.dntLocation && this.dntLocation.url && this.dntLocation.url.length) {

                $rootScope.$broadcast('DNTDATA_LOAD_EVENT');

                $timeout(function () {
                  t.reader.loadDntFromServerFile(t.dntLocation.url + '/' + file, function (msg) {
                    // if(t.progressCallback) {
                    // t.progressCallback(msg);
                    // }
                  }, function (result, fileName) {
                    // console.info('dnt loading complete : ' + file);
                    t.loaded = true;

                    angular.forEach(t.completeCallbacks, function (value, key) {
                      if (value) {
                        value();
                      }
                    });
                    t.completeCallbacks = [];
                    $rootScope.$broadcast('DNTDATA_LOAD_EVENT');
                  }, function (msg) {
                    t.failed = true;
                    if (ignoreErrors) {
                      t.loaded = true;
                      console.log('ignoring the error - this file may not exist yet for the region');
                      angular.forEach(t.completeCallbacks, function (value, key) {
                        if (value) {
                          value();
                        }
                      });
                      t.completeCallbacks = [];
                      $rootScope.$broadcast('DNTDATA_LOAD_EVENT');
                    } else {
                      t.startedLoading = false;
                      t.loaded = false;
                      $rootScope.$broadcast('DNTDATA_LOAD_ERROR');
                    }
                  });
                });
              } else {
                // console.log("dnt location not set!");
              }
            }
          }
        },

        reset: function reset() {
          this.reader = new DntReader();
          this.loaded = false;
          this.startedLoading = false;
        }
      };

      return loader;
    };

    return {
      loaders: {},
      findIndexes: {},
      dntLocation: null,

      setLocation: function setLocation(location) {
        this.dntLocation = location;
        var t = this;
        angular.forEach(this.loaders, function (value, key) {
          if (value.dntLocation != location) {
            value.dntLocation = location;
            t.reset(key);
          }
        });
      },

      init: function init(fileName, colsToLoad, progress, complete, ignoreErrors) {
        if (ignoreErrors !== false) {
          ignoreErrors = true;
        }

        if (!progress) {
          progress = function progress() {};
        }
        if (!(fileName in this.loaders)) {
          if (fileName.length > 0) {
            this.loaders[fileName] = createLoader(this.dntLocation, fileName, colsToLoad);
          }
        }
        this.loaders[fileName].init(progress, complete, ignoreErrors);
      },
      getData: function getData(fileName) {
        if (this.isLoaded(fileName)) {
          var reader = this.loaders[fileName].reader;
          var retVal = new Array(reader.numRows);
          for (var i = 0; i < reader.numRows; ++i) {
            retVal[i] = reader.getRow(i);
          }

          return retVal;
        } else {
          return [];
        }
      },
      find: function find(fileName, column, value) {
        var results = this.findFast(fileName, column, value);
        var retVal = [];
        var numResults = results.length;
        for (var i = 0; i < numResults; ++i) {
          retVal.push(this.getRow(fileName, results[i]));
        }

        return retVal;
      },
      findFast: function findFast(fileName, column, value) {

        if (this.isLoaded(fileName)) {
          if (!(fileName in this.findIndexes)) {
            this.findIndexes[fileName] = {};
          }

          var reader = this.loaders[fileName].reader;
          var colIndex = reader.columnIndexes[column];

          var findIndex = this.findIndexes[fileName];

          if (!(column in findIndex)) {
            var index = {};
            findIndex[column] = index;

            var data = reader.data;
            var len = data.length;
            for (var r = 0; r < len; ++r) {
              var val = data[r][colIndex];

              if (!(val in index)) {
                index[val] = [r];
              } else {
                index[val].push(r);
              }
            }
          }

          if (value in findIndex[column]) {
            if (Array.isArray(findIndex[column][value])) {
              return findIndex[column][value];
            } else {
              return [findIndex[column][value]];
            }
          } else {
            return [];
          }
        }

        return [];
      },
      isLoaded: function isLoaded(fileName) {
        return fileName in this.loaders && this.loaders[fileName].loaded;
      },
      hasFailed: function hasFailed(fileName) {
        return fileName in this.loaders && this.loaders[fileName].failed;
      },
      hasStartedLoading: function hasStartedLoading(fileName) {
        return this.isLoaded(fileName) || fileName in this.loaders && this.loaders[fileName].startedLoading;
      },
      reset: function reset(fileName) {
        if (fileName in this.loaders) {
          this.loaders[fileName].reset();
          delete this.loaders[fileName];
          delete this.findIndexes[fileName];
        }
      },
      resetAll: function resetAll() {
        var t = this;
        angular.forEach(this.loaders, function (value, key) {
          t.reset(key);
        });
      },
      anyLoading: function anyLoading() {
        var found = 0;
        angular.forEach(this.loaders, function (value, key) {
          if (!value.loaded && value.startedLoading) {
            found++;
          }
        });

        return found;
      },
      getNumRows: function getNumRows(fileName) {
        if (this.isLoaded(fileName)) {
          return this.loaders[fileName].reader.numRows;
        } else {
          return 0;
        }
      },
      getRow: function getRow(fileName, index) {
        if (this.isLoaded(fileName)) {
          return this.loaders[fileName].reader.getRow(index);
        } else {
          return {};
        }
      },
      lookupValue: function lookupValue(fileName, data, columnName) {
        if (this.isLoaded(fileName)) {
          return data[this.loaders[fileName].reader.columnNames[columnName]];
        } else {
          return null;
        }
      },
      convertData: function convertData(fileName, data) {
        if (this.isLoaded(fileName)) {
          return this.loaders[fileName].reader.convertData(data);
        } else {
          return null;
        }
      },
      getValue: function getValue(fileName, index, columnName) {
        if (this.isLoaded(fileName)) {
          return this.loaders[fileName].reader.getValue(index, columnName);
        } else {
          return null;
        }
      },
      saveMemory: function saveMemory() {
        for (var fileName in this.loaders) {
          this.loaders[fileName].saveReaderMemory();
        }
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('dntInit', ['items', 'jobs', 'dntData', 'itemFactory', dntInit]);
  function dntInit(items, jobs, dntData, itemFactory) {
    return function (progress) {

      progress('starting init');

      var allFactories = [jobs];

      var dntFiles = {};
      angular.forEach(items, function (item, key) {
        if (key != 'all') {
          angular.forEach(item, function (value, prop) {
            if (prop.indexOf('Dnt') == prop.length - 3) {
              var newFactory = {
                init: function init(progress, complete) {
                  dntData.init(value, null, progress, complete);
                },
                isLoaded: function isLoaded() {
                  return dntData.isLoaded(value);
                },
                fileName: value
              };

              allFactories.push(newFactory);
            }
          });
        }
      });

      function initFactory(index) {

        if (index < allFactories.length) {
          allFactories[index].init(progress, function () {
            if (allFactories[index].isLoaded()) {
              if ('fileName' in allFactories[index]) {
                progress('dnt loaded: ' + allFactories[index].fileName);
              }
              initFactory(index + 1);
            }
          });
        } else {
          progress('Full initialise complete');
        }
      }

      initFactory(0);
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('dntReset', ['items', 'jobs', 'dntData', dntReset]);
  function dntReset(items, jobs, dntData) {
    return function () {

      angular.forEach(items, function (source, name) {
        source.reset();
      });

      jobs.reset();
      dntData.resetAll();
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('dvStatcardHelper', dvStatcardHelper);
  function dvStatcardHelper() {
    'use strict';

    // Conversions between dngs stat IDs and dvstatcard keys

    var statMap = {
      0: 'statStr',
      1: 'statAgi',
      2: 'statInt',
      3: 'statVit',
      4: 'statPDmgMin',
      5: 'statPDmgMax',
      6: 'statMDmgMin',
      7: 'statMDmgMax',
      8: 'statPDef',
      9: 'statMDef',
      12: 'statCrit',
      16: 'statFire',
      17: 'statIce',
      18: 'statLight',
      19: 'statDark',
      25: 'statHp',
      26: 'statMana',
      29: 'statFD',
      103: 'statCritDmg'
    };

    //    Converts dngs stat IDs to dvstatcard stat keys
    function convertStat(stat) {
      var ret = statMap[stat.id];
      return ret || 'unknown';
    };

    function convertPercentToNum(val) {
      return val * 100;
    };

    //    Stats that need to have some conversion applied between dngs and dvstatcard
    var adjustments = {
      16: convertPercentToNum,
      17: convertPercentToNum,
      18: convertPercentToNum,
      19: convertPercentToNum
    };

    //    Convert between numerical standards between dngs and dvstatcard
    function adjustStat(stat) {
      var func = adjustments[stat.id];
      if (func) {
        return func(stat.max);
      }
      return stat.max;
    };

    return {
      convertStats: function convertStats(build, buildName, calcStats) {
        var ret = {
          characterName: buildName,
          remark: 'Imported from DNGearsim',
          classId: build.job.id,
          statHeroLevel: build.heroLevel
        };
        for (var k in calcStats) {
          var v = calcStats[k];
          ret[convertStat(v)] = adjustStat(v);
        }
        return ret;
      },
      cardImportUrl: 'https://redirect.divinitor.com/dngsimport'
    };
  }
})();
"use strict";

(function () {
  'use strict';

  exportLinkHelper.$inject = ["$http", "items", "dntData", "itemFactory", "hCodeValues", "itemColumnsToLoad", "statHelper", "translations", "itemCategory", "region"];
  angular.module('dnsim').factory('exportLinkHelper', exportLinkHelper);
  function exportLinkHelper($http, items, dntData, itemFactory, hCodeValues, itemColumnsToLoad, statHelper, translations, itemCategory, region) {

    return {

      encodeItem: function encodeItem(item, small) {
        if (item) {
          var itemString;

          if (item.typeName == 'custom') {
            itemString = '_custom';
            angular.forEach(item.stats, function (stat, index) {
              if (index > 0) {
                itemString += '|';
              } else {
                itemString += ':C';
              }
              itemString += stat.id.toString(36) + '=' + stat.max;
            });
          } else if (item.id) {
            itemString = 'I' + item.id.toString(36) + ':_';
            if ('itemSource' in item) {
              itemString += item.itemSource;
            } else if ('itemTypeName' in item) {
              // this is to support groups saved with the old property name
              itemString += item.itemTypeName;
            } else if (item.fileName) {
              itemString += ':F' + item.fileName;
            }

            if (item.enchantmentNum || item.enchantmentNum == 0) {
              itemString += ':E' + item.enchantmentNum.toString(36);
            }
            if (item.pid > 0) {
              itemString += ':P' + item.pid.toString(36);
            }
            // if(item.setId > 0) {
            // itemString += ':S' + item.setId.toString(36);
            // }
            if (item.sparkId > 0) {
              itemString += ':H' + item.sparkId.toString(36);
            }
            if (item.typeName == 'skills') {
              itemString += ':J' + item.baseJobName;
            }
            if (item.pve) {
              itemString += ':V' + item.pve;
            }
          }

          if (item.name && !small) {
            itemString += ':.' + item.name.replace(/ /g, '-').replace(/\//g, ' ');
          }

          return itemString;
        }

        return '';
      },

      decodeItem: function decodeItem(itemStr) {
        var item = {};

        if (itemStr) {
          angular.forEach(itemStr.split(':'), function (itemBit, bitIndex) {
            if (itemBit.charAt(0) == 'I') {
              item.id = parseInt(itemBit.substr(1), 36);
            } else if (itemBit.charAt(0) == 'E') {
              item.enchantmentNum = parseInt(itemBit.substr(1), 36);
            } else if (itemBit.charAt(0) == 'P') {
              item.pid = parseInt(itemBit.substr(1), 36);
            } else if (itemBit.charAt(0) == 'S') {
              item.setId = parseInt(itemBit.substr(1), 36);
            } else if (itemBit.charAt(0) == 'H') {
              item.sparkId = parseInt(itemBit.substr(1), 36);
            } else if (itemBit.charAt(0) == 'J') {
              item.baseJobName = itemBit.substr(1);
            } else if (itemBit.charAt(0) == 'V') {
              item.pve = itemBit.substr(1);
            } else if (itemBit.charAt(0) == '_') {
              item.itemSource = itemBit.substr(1);
            } else if (itemBit.charAt(0) == '.') {
              item.name = itemBit.substr(1).replace('-', ' ');
            } else if (itemBit.charAt(0) == 'C') {
              item.stats = [];
              var statString = itemBit.substr(1);
              angular.forEach(statString.split('|'), function (statBit, statBitIndex) {
                var splitStat = statBit.split('=');
                item.stats.push({
                  id: parseInt(splitStat[0], 36),
                  max: Number(splitStat[1])
                });
              });
            } else if (itemBit.charAt(0) == 'F') {

              item.fileName = itemBit.substr(1);
              angular.forEach(items, function (itemSource, key) {
                if (itemSource.mainDnt && itemSource.mainDnt.indexOf(item.fileName + '.') == 0) {
                  item.itemSource = key;
                }
              });
            }
          });
        }

        return item;
      },

      createGroupLink: function createGroupLink(groupName, group) {
        var itemStrings = [];
        var self = this;

        if (group == null) {
          return '';
        }

        angular.forEach(group.items, function (item, key) {
          var itemString = self.encodeItem(item, true);
          if (itemString && itemString.length) {
            itemStrings.push(itemString);
          }
        });

        var retVal = 'view-group?region=';
        if (region.dntLocation && region.dntLocation.region) {
          retVal += region.dntLocation.region;
        }

        if (group.enemyLevel) {
          retVal += '&e=' + group.enemyLevel;
        }
        if (group.playerLevel) {
          retVal += '&p=' + group.playerLevel;
        }
        if (group.heroLevel) {
          retVal += '&h=' + group.heroLevel;
        }
        if (group.job && group.job.id) {
          retVal += '&j=' + group.job.id;
        }
        if (group.damageType && group.damageType.id) {
          retVal += '&d=' + group.damageType.id;
        }
        if (group.element && group.element.id) {
          retVal += '&t=' + group.element.id;
        }
        if (group.secondaryElement && group.secondaryElement.id) {
          retVal += '&s=' + group.secondaryElement.id;
        }
        retVal += '&g=' + encodeURI(groupName) + '&i=' + itemStrings.join(',');
        return retVal;
      },

      reloadSkill: function reloadSkill(item) {

        if (!item.enchantmentNum) {
          item.enchantmentNum = 1;
        }

        var skillDnt = 'skilltable_character' + item.baseJobName + '.lzjson';
        var pv = 'pve';
        if (item.pve == 'pvp') {
          pv = 'pvp';
        }
        var skillLevelDnt = 'skillleveltable_character' + item.baseJobName + pv + '.lzjson';

        var skillData = dntData.find(skillDnt, 'id', item.id)[0];
        if (!skillData) {
          console.log('cannot get skill data from ', skillDnt);
        }
        var skillLevelDatas = dntData.getData(skillLevelDnt);

        var skillLevelVals = {};
        angular.forEach(skillLevelDatas, function (value, index) {
          if (value.SkillIndex == item.id && value.SkillLevel == item.enchantmentNum) {
            skillLevelVals = value;
          }
        });

        var newItem = {
          id: item.id,
          itemSource: item.itemSource,
          typeName: item.itemSource,
          needJobClass: skillData.NeedJob,
          baseJobName: item.baseJobName,
          rank: hCodeValues.rankNames[0],
          enchantmentNum: item.enchantmentNum,
          name: translations.translate(skillData.NameID, skillData.NameIDParam),
          description: translations.translate(skillLevelVals.SkillExplanationID, skillLevelVals.SkillExplanationIDParam),
          icon: skillData.IconImageIndex,
          pve: item.pve
        };

        newItem.stats = statHelper.getSkillStats(newItem, skillData, skillLevelDatas);
        return newItem;
      },

      reloadSourceItem: function reloadSourceItem(item) {
        var itemType = items[item.itemSource];
        var ds = dntData.findFast(itemType.mainDnt, 'id', item.id);
        if (!ds.length) {
          console.log('item ' + item.id + ' not found in ' + itemType.mainDnt);
          return;
        }

        var rowNum = ds[0];
        var typeParam1 = dntData.getValue(itemType.mainDnt, rowNum, 'TypeParam1');

        var p = null;

        var ps = dntData.find(itemType.potentialDnt, 'id', item.pid);
        if (!ps.length) {
          ps = dntData.find(itemType.potentialDnt, 'PotentialID', typeParam1);
        }

        if (!ps.length) {
          ps = dntData.find(itemType.potentialDntEx, 'id', item.pid);
          if (!ps.length) {
            ps = dntData.find(itemType.potentialDntEx, 'PotentialID', typeParam1);
          }
        }

        if (ps.length > 0) {
          p = ps[0];

          if (p.PotentialID != typeParam1) {
            // this happened one time
            // not sure how but it corrupted the stats
            p = null;
            console.log('bad potential');
          }
        }

        var newItem = itemFactory.createItem(itemType, rowNum, p);
        itemFactory.initItem(newItem);
        itemCategory.setItemCategory(newItem);
        newItem.gemSlot = item.gemSlot;

        var usePartDnt = null;
        if (newItem.typeName != 'weapons' && newItem.typeId != 0) {
          usePartDnt = 'partsDnt';
        } else {
          usePartDnt = 'weaponDnt';
        }

        if (usePartDnt) {
          if (dntData.isLoaded(itemType[usePartDnt]) && dntData.isLoaded(itemType.setDnt)) {
            newItem.setStats = [];
            var parts = dntData.find(itemType[usePartDnt], 'id', item.id);
            if (parts.length > 0) {
              newItem.setId = parts[0].SetItemID;
              var sets = dntData.find(itemType.setDnt, 'id', parts[0].SetItemID);
              if (sets.length > 0) {
                newItem.setStats = hCodeValues.getStats(sets[0]);
              }
            }
          }
        }

        newItem.fullStats = newItem.stats;
        if (item.enchantmentNum >= 0) {
          newItem.enchantmentNum = item.enchantmentNum;

          if (newItem.typeName == 'skills') {
            // would this even happen?
          } else if (newItem.typeName == 'talisman') {
            var extraStats = [];
            angular.forEach(newItem.stats, function (stat, index) {
              extraStats.push({ id: stat.id, max: stat.max * (newItem.enchantmentNum / 100) });
            });

            newItem.enchantmentStats = extraStats;
          } else if (itemType.enchantDnt) {
            var enchantments = dntData.find(itemType.enchantDnt, 'EnchantID', newItem.enchantmentId);
            if (!enchantments.length && itemType.enchantDnt2) {
              enchantments = dntData.find(itemType.enchantDnt2, 'EnchantID', newItem.enchantmentId);
            }

            angular.forEach(enchantments, function (enchantment, index) {
              if (enchantment.EnchantLevel == newItem.enchantmentNum) {
                newItem.enchantmentStats = hCodeValues.getStats(enchantment);
              }
            });
          } else if (itemType.petLevelDnt) {
            var petLevels = dntData.find(itemType.petLevelDnt, 'PetLevelTypeID', newItem.enchantmentId);
            angular.forEach(petLevels, function (enchantment, index) {
              if (enchantment.PetLevel == newItem.enchantmentNum) {
                newItem.enchantmentStats = hCodeValues.getStats(enchantment);
              }
            });
          }
        }

        if (newItem.enchantmentStats) {
          newItem.fullStats = hCodeValues.mergeStats(newItem.enchantmentStats, newItem.stats);
        }

        if (item.sparkId > 0) {
          newItem.sparkId = item.sparkId;
          var sparks = dntData.find(itemType.sparkDnt, 'id', item.sparkId);
          if (sparks.length > 0) {
            newItem.sparkStats = hCodeValues.getStats(sparks[0]);
            newItem.fullStats = hCodeValues.mergeStats(newItem.fullStats, newItem.sparkStats);
          }
        } else if (newItem.dragonjeweltype) {
          newItem.offensiveGemSlots = 0;
          newItem.increasingGemSlots = 0;
          var itemData = dntData.find('dragonjewelslottable.lzjson', 'DragonJewelID', newItem.dragonjeweltype);
          if (itemData && itemData.length > 0) {
            if (itemData[0].DragonJewelSlot1 == 1) newItem.offensiveGemSlots++;
            if (itemData[0].DragonJewelSlot2 == 1) newItem.offensiveGemSlots++;
            if (itemData[0].DragonJewelSlot3 == 1) newItem.offensiveGemSlots++;
            if (itemData[0].DragonJewelSlot4 == 1) newItem.offensiveGemSlots++;

            if (itemData[0].DragonJewelSlot1 == 2) newItem.increasingGemSlots++;
            if (itemData[0].DragonJewelSlot2 == 2) newItem.increasingGemSlots++;
            if (itemData[0].DragonJewelSlot3 == 2) newItem.increasingGemSlots++;
            if (itemData[0].DragonJewelSlot4 == 2) newItem.increasingGemSlots++;
          }
        }

        return newItem;
      },

      reloadItem: function reloadItem(item) {

        if (item == null) {
          // console.log('cannot reload null item');
          return;
        }

        // support for old property name
        if ('itemTypeName' in item && !item.itemSource) {
          item.itemSource = item.itemTypeName;
        }

        // console.log('checking ' + item.itemSource)
        if (item.itemSource == 'rbTech') {
          item.itemSource = 'tech';
          // console.log('changed to ' + item.itemSource)
        }

        if (item.itemSource == 'custom' || item.typeName == 'custom') {
          item.typeName = 'custom';
          return item;
        } else if (item.itemSource == 'skills' || item.typeName == 'skills') {
          return this.reloadSkill(item);
        } else if (item.itemSource in items) {
          var itemType = items[item.itemSource];
          var ds = dntData.findFast(itemType.mainDnt, 'id', item.id);
          if (ds.length) {
            return this.reloadSourceItem(item);
          }
        }

        if (item.fileName) {
          var datas = dntData.findFast(item.fileName + '.lzjson', 'id', item.id);
          if (datas.length > 0) {
            var row = datas[0];
            var d = dntData.getRow(item.fileName + '.lzjson', row);
            var newItem = itemFactory.createBasicItem(d);
            newItem.row = row;
            newItem.needJobClass = d.NeedJobClass;
            newItem.exchangeType = d.ExchangeType;
            newItem.fileName = item.fileName;
            newItem.gemSlot = item.gemSlot;
            newItem.description = translations.translate(d.DescriptionID, d.DescriptionIDParam);
            itemFactory.initItem(newItem);
            return newItem;
          } else {
            return { name: 'unknown item' };
          }
        } else {
          return { name: 'unknown item source: ' + item.itemSource };
        }
      },

      getDntFiles: function getDntFiles(item) {
        if (item == null) {
          return {};
        }

        var dntFiles = {};
        if (!item.itemSource && item.itemTypeName in items) {
          item.itemSource = item.itemTypeName;
        }

        if (item.itemSource == 'rbTech') {
          item.itemSource = 'tech';
        }

        if (item.itemSource in items) {
          var itemType = items[item.itemSource];

          dntFiles['exchange.lzjson'] = null;
          dntFiles[itemType.mainDnt] = itemColumnsToLoad.mainDnt;

          for (var fileType in itemType) {
            if (fileType.indexOf('Dnt') > 0) {
              if (fileType != 'enchantDnt' || fileType != 'enchantDnt2' || item.enchantmentNum) {
                dntFiles[itemType[fileType]] = itemColumnsToLoad[fileType];
              }
            }
          }
        }

        if (item.itemSource == 'skills' || item.typeName == 'skills') {
          var skillDnt = 'skilltable_character' + item.baseJobName + '.lzjson';
          dntFiles[skillDnt] = null;
          var skillLevelDnt = 'skillleveltable_character' + item.baseJobName + 'pve' + '.lzjson';
          dntFiles[skillLevelDnt] = null;
          skillLevelDnt = 'skillleveltable_character' + item.baseJobName + 'pvp' + '.lzjson';
          dntFiles[skillLevelDnt] = null;
        }

        if (item.fileName) {
          dntFiles[item.fileName + '.lzjson'] = null;
        }

        return dntFiles;
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('groupHelper', ['exportLinkHelper', groupHelper]);
  function groupHelper(exportLinkHelper) {
    'use strict';

    return {
      reloadGroup: function reloadGroup(groupName, group) {
        var newItems = [];
        angular.forEach(group.items, function (item, key) {
          var newItem = exportLinkHelper.reloadItem(item);
          if (newItem) {
            newItems.push(newItem);
          }
        });

        return newItems;
      },

      getDntFiles: function getDntFiles(group) {

        var allDntFiles = {};
        angular.forEach(group.items, function (item, key1) {

          var dntFiles = exportLinkHelper.getDntFiles(item);

          angular.forEach(dntFiles, function (value, key) {
            allDntFiles[key] = value;
          });
        });

        return allDntFiles;
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('itemCategory', ['itemFactory', 'items', 'dntData', itemCategory]);
  function itemCategory(itemFactory, items, dntData) {

    return {
      categories: [{ path: 'everything', name: 'everything', searchType: 'everything', hideInBuild: true }, { path: 'titles', name: 'titles', sourceType: 'titles', hideRank: true, hideJob: true, hideLevel: true, numItemText: '1', maxCat: 1 }, { path: 'weapons', name: 'weapons', sourceType: 'equipment', numItemText: '2', maxExchange: 1, maxCat: 2, limitExchange: [1, 2] }, { path: 'armour', name: 'armour', sourceType: 'equipment', numItemText: '5', maxExchange: 1, maxCat: 5, limitExchange: [3, 4, 5, 6, 7] }, { path: 'accessories', name: 'accessories', sourceType: 'equipment', hideJob: true, maxCat: 4, maxExchange: 2, limitExchange: [8, 9, 10], tId: 7604 }, { path: 'techs', name: 'techs', sourceType: 'techs', maxCat: 4, maxExchange: 2, limitExchange: [8, 9, 10], hideJob: true }, { path: 'offensive-gems', name: 'offensive gems', sourceType: 'gems', hideJob: true, maxCat: 4, maxExchange: 4, limitExchange: [54], limitGemType: 1 }, { path: 'increasing-gems', name: 'increasing gems', sourceType: 'gems', hideJob: true, maxCat: 14, maxExchange: 14, limitExchange: [54], limitGemType: 2 }, { path: 'enhancement-plates', name: 'enhancement plates', sourceType: 'plates', hideJob: true, numItemText: '8+3', maxCat: 11, maxExchange: 15, limitExchange: [33], limitRank: [0, 1, 2, 3] }, { path: 'expedition-plates', name: 'expedition plates', sourceType: 'plates', hideRank: true, hideJob: true, numItemText: '4', maxCat: 4, maxExchange: 15, limitExchange: [33], limitRank: [4, 5] }, { path: 'talisman', name: 'talisman', sourceType: 'talisman', hideJob: true, numItemText: '8+4', maxCat: 12, maxExchange: 12, limitExchange: [52, 53], tId: 1000054149 }, { path: 'costume', name: 'costume', sourceType: 'cash', numItemText: '7', maxCat: 7, maxExchange: 1, hideLevel: true, limitExchange: [16, 17, 18, 19, 20, 21, 22], tId: 7607 }, { path: 'imprint', name: 'imprint', sourceType: 'imprint', numItemText: '7', maxCat: 7, hideLevel: true, hideJob: true, tId: 1000108314 }, { path: 'cash', name: 'cash', sourceType: 'cash', numItemText: '8', maxCat: 8, maxExchange: 2, hideJob: true, hideLevel: true, limitExchange: [23, 24, 25, 26, 27, 28, 29], tId: 7608 }, { path: 'extras', name: 'extras', sourceType: 'xtras', limitExchange: [47], hideJob: true, hideLevel: true, tId: 4504 }, { path: 'skills', name: 'skills', searchType: 'skills' }, { path: 'custom', name: 'custom', searchType: 'custom', hideInSearch: true }],

      byName: function byName(name) {
        var retVal = null;
        angular.forEach(this.categories, function (category, index) {
          if (category.name == name) {
            retVal = category;
          }
        });

        return retVal;
      },

      byPath: function byPath(name) {
        var retVal = null;
        angular.forEach(this.categories, function (category, index) {
          if (category.path == name) {
            retVal = category;
          }
        });

        return retVal;
      },

      getItems: function getItems(name) {
        var cat = this.byName(name);
        if (cat && 'sourceType' in cat) {
          var retVal = [];
          angular.forEach(items, function (source, sourceName) {
            if (source.type == cat.sourceType && retVal) {
              if (!source.items && !source.loading) {
                itemFactory.loadItems(source);
              }

              if (source.items) {
                retVal = retVal.concat(source.items);
              } else {
                retVal = null; // if any are null just return null
              }
            }
          });

          var catItems = [];
          if (retVal) {
            var vm = this;
            angular.forEach(retVal, function (item, index) {
              if (item.typeName == name) {
                catItems.push(item);
              } else if (vm.isItemForCat(cat, item, item.data)) {
                item.typeName = name;
                catItems.push(item);
              }
            });
          }

          return catItems;
        } else {
          return null;
        }
      },

      isItemForCat: function isItemForCat(cat, item) {

        if (!(item.itemSource in items)) {
          return false;
        }

        if (items[item.itemSource].type != cat.sourceType) {
          return false;
        }

        if (item.itemType == cat.name) {
          return true;
        }

        var anyMatch;
        if (cat.limitExchange) {
          anyMatch = false;
          for (var i = 0; i < cat.limitExchange.length; ++i) {
            if (cat.limitExchange[i] == item.exchangeType || item.rawData && cat.limitExchange[i] == item.rawData.ExchangeType) {
              anyMatch = true;
            }
          }

          if (!anyMatch) {
            return false;
          }
        }

        if (cat.limitRank) {
          anyMatch = false;
          for (var i = 0; i < cat.limitRank.length; ++i) {
            if (item.rank && cat.limitRank[i] == item.rank.id || item.rawData && cat.limitRank[i] == item.rawData.Rank) {
              anyMatch = true;
            }
          }

          if (!anyMatch) {
            return false;
          }
        }

        if (cat.limitGemType) {
          var gemTypes = dntData.find(items.gem.gemDnt, 'id', item.id);
          if (gemTypes.length > 0) {

            if (gemTypes[0].Type != cat.limitGemType) {
              return false;
            }
          }
        }

        return true;
      },

      init: function init(name, complete) {
        var cat = this.byName(name);
        if (cat && 'sourceType' in cat) {
          var sources = _.filter(items, function (source) {
            return source.type == cat.sourceType;
          });

          var numComplete = 0;
          _.each(sources, function (source) {
            source.init(function () {}, function () {
              numComplete++;
              if (numComplete == sources.length) {
                complete();
              }
            });
          });
        }
      },

      setItemCategory: function setItemCategory(item, rawData) {
        var vm = this;

        angular.forEach(this.categories, function (cat, index) {
          if (vm.isItemForCat(cat, item, rawData)) {
            item.typeName = cat.name;
          }
        });
      },

      getItemsByCategory: function getItemsByCategory(items) {
        var itemMap = {};
        if (items) {
          var types = {};
          angular.forEach(items, function (item, index) {
            if (item) {
              if (!(item.typeName in types)) {
                types[item.typeName] = [];
              }
              types[item.typeName].push(item);
            }
          });

          angular.forEach(this.categories, function (category, index) {

            if (category.name in types) {

              var sorted = types[category.name].sort(function (item1, item2) {
                if (category.name == 'talisman') {

                  var enh1 = item1.enchantmentNum;
                  if (!enh1) enh1 = 0;
                  var enh2 = item2.enchantmentNum;
                  if (!enh2) enh2 = 0;

                  if (enh1 != enh2) {
                    return enh2 - enh1;
                  }
                } else if (item1.itemSource == 'gem' || item1.itemSource == 'plate') {
                  if (item1.gemSlot || item2.gemSlot) {
                    if (!item1.gemSlot) {
                      return 1;
                    } else if (!item2.gemSlot) {
                      return -1;
                    }
                    return item1.gemSlot - item2.gemSlot;
                  } else if (item2.levelLimit != item1.levelLimit) {
                    return item2.levelLimit - item1.levelLimit;
                  }
                } else if ('exchangeType' in item1 && 'exchangeType' in item2) {
                  return item1.exchangeType - item2.exchangeType;
                }

                return item1.name.localeCompare(item2.name);
              });
              itemMap[category.name] = sorted;
            } else {
              itemMap[category.name] = [];
            }
          });

          /*
          angular.forEach(items, function(item, index) {
            if(item && !(item.typeName in itemMap)) {
              // console.log('we dont know ' + item.typeName + ' anymore')
              itemMap.typeError = true;
            }
          });
          */
        }
        return itemMap;
      }
    };
  }
})();
'use strict';

(function () {
    'use strict';

    angular.module('dnsim').factory('excludeService', excludeService);

    function excludeService() {
        return {
            ids: [{
                name: 'unbound plates',
                min: 0,
                max: 0
            }]
        };
    }
})();
"use strict";

(function () {
  'use strict';

  itemFactory.$inject = ["translations", "dntData", "hCodeValues", "items"];
  angular.module('dnsim').factory('itemFactory', itemFactory);

  function itemFactory(translations, dntData, hCodeValues, items) {

    return {
      loadItems: loadItems,
      initItem: initItem,
      createItem: createItem,
      getItemData: getItemData,
      createBasicItem: createBasicItem
    };

    function createItem(itemType, row, p) {

      // data and potential are used to initialise name and stats
      // this is only done when needed
      // they are then removed from the object
      return {
        row: row,
        potential: p,
        id: dntData.getValue(itemType.mainDnt, row, 'id'),
        itemSource: itemType.name,
        levelLimit: dntData.getValue(itemType.mainDnt, row, 'LevelLimit'),
        needJobClass: dntData.getValue(itemType.mainDnt, row, 'NeedJobClass'),
        typeId: dntData.getValue(itemType.mainDnt, row, 'Type'),
        exchangeType: dntData.getValue(itemType.mainDnt, row, 'ExchangeType'),
        rank: hCodeValues.rankNames[dntData.getValue(itemType.mainDnt, row, 'Rank')],
        pid: null,
        name: null,
        stats: null,
        potentialRatio: null,
        typeName: null,
        sparkId: null
      };
    }

    function isDataLoaded(itemType) {

      if (!dntData.isLoaded(itemType.mainDnt)) {
        return false;
      }

      if (!translations.isLoaded()) {
        return false;
      }

      if ('potentialDnt' in itemType && !dntData.isLoaded(itemType.potentialDnt)) {
        return false;
      }

      if ('potentialDntEx' in itemType && !dntData.isLoaded(itemType.potentialDntEx)) {
        return false;
      }

      return true;
    }

    function loadItems(itemType) {

      if (!isDataLoaded(itemType)) {
        return null;
      }

      var start = new Date().getTime();

      itemType.items = [];
      var numRows = dntData.getNumRows(itemType.mainDnt);
      for (var r = 0; r < numRows; ++r) {
        var dType = dntData.getValue(itemType.mainDnt, r, 'Type');

        var state1Max = dntData.getValue(itemType.mainDnt, r, 'State1_Max');
        var dStateValue1 = dntData.getValue(itemType.mainDnt, r, 'StateValue1');
        var dTypeParam1 = dntData.getValue(itemType.mainDnt, r, 'TypeParam1');

        // skip items with no data
        if (state1Max > 0 || dStateValue1 > 0 || dTypeParam1 > 0 || dType == 35) {
          var potentials = [];
          if (dTypeParam1 > 0 && 'potentialDnt' in itemType) {
            potentials = dntData.find(itemType.potentialDnt, 'PotentialID', dTypeParam1);

            if (!potentials.length && 'potentialDntEx' in itemType) {
              potentials = dntData.find(itemType.potentialDntEx, 'PotentialID', dTypeParam1);
            }
          }

          var numPotentials = potentials.length;
          if (!numPotentials) {
            potentials = [null];
            numPotentials = 1;
          }

          for (var p = 0; p < numPotentials; ++p) {
            var found = false;
            if (!found) {
              itemType.items.push(createItem(itemType, r, potentials[p], 0));
            }
          }
        }
      }

      var end = new Date().getTime();
      var time = end - start;
      console.log('item init time: ' + time / 1000 + 's for ' + itemType.name);
    }

    function initItem(item) {

      if (item.row >= 0) {
        var d;
        if (item.itemSource && item.itemSource in items) {
          d = dntData.getRow(items[item.itemSource].mainDnt, item.row);
        } else if (item.fileName) {
          d = dntData.getRow(item.fileName + '.lzjson', item.row);
        }
        delete item.row;

        var p = item.potential;

        if (item.name == null) {
          item.name = translations.translate(d.NameID, d.NameIDParam);
          if (d.TierName) {
            item.name += ' (' + translations.translate(d.TierName) + ')';
          }
        }

        if (!item.sparkTypeId && d.TypeParam2 > 0) {
          item.sparkTypeId = d.TypeParam2;
        }

        if (item.stats == null) {
          var stats = hCodeValues.getStats(d);
          if (p) {
            var potentialStats = hCodeValues.getStats(p);
            stats = hCodeValues.mergeStats(stats, potentialStats);
          }

          item.stats = stats;
        }

        if (d.SkillID && !item.skillId) {
          item.skillId = d.SkillID;
        }

        if (item.iconIndex == null) {
          item.icon = d.IconImageIndex;
          if (!item.icon && item.itemSource == 'title') {
            item.icon = 12417;
          }
        }

        if (d.dragonjeweltype >= 0) {
          item.dragonjeweltype = d.dragonjeweltype;
        }

        if (d.EnchantID && !item.enchantmentId) {
          item.enchantmentId = d.EnchantID;
        }

        if (d.EnchantID && !item.enchantmentId) {
          item.enchantmentId = d.EnchantID;
        } else if (d.Type == 35) {
          item.itemSource = 'xtras';
          var itemType = items[item.itemSource];
          if (itemType) {
            // item.fileName = itemType.mainDnt;
            var petData = dntData.find(itemType.petDnt, 'id', d.id);
            if (petData && petData.length) {
              item.enchantmentId = petData[0].PetLevelTypeID;
            }
          }
        }

        if (p) {
          item.pid = p.id;
        }

        delete item.potential;
      }
    }

    function getItemData(item) {
      var itemType = items[item.itemSource];

      if (item.fileName && dntData.isLoaded(item.fileName + '.lzjson')) {
        var result = getItemDataFromFile(item.fileName + '.lzjson', item);
        if (result) {
          return result;
        }
      }

      if (item.fileName && dntData.isLoaded(item.fileName + '.optimised.json')) {
        var result = getItemDataFromFile(item.fileName + '.optimised.json', item);
        if (result) {
          return result;
        }
      }

      if (itemType && dntData.isLoaded(itemType.mainDnt)) {
        var result = getItemDataFromFile(itemType.mainDnt, item);
        if (result) {
          return result;
        }
      }

      return [];
    }

    function getItemDataFromFile(fileName, item) {
      if (fileName) {
        var itemData = dntData.find(fileName, 'id', item.id);
        if (itemData && itemData.length > 0) {
          return itemData[0];
        }
      }

      return null;
    }

    function createBasicItem(d) {
      if (!d) {
        return [];
      }
      return {
        id: d.id,
        name: translations.translate(d.NameID, d.NameIDParam),
        rank: hCodeValues.rankNames[d.Rank],
        icon: d.IconImageIndex,
        levelLimit: d.LevelLimit,
        fileName: d.fileName,
        typeId: d.Type
      };
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('items', ['translations', 'dntData', 'itemColumnsToLoad', items]);
  function items(translations, dntData, itemColumnsToLoad) {

    var itemSources = {

      title: {
        mainDnt: 'appellationtable.optimised.json',
        type: 'titles',
        minLevel: 0,
        minRank: 0 },
      // wspr: { mainDnt: 'itemtable_source.dnt', type: 'wellspring', minLevel: 24 },

      tech: {
        mainDnt: 'itemtable_skilllevelup.optimised.json',
        potentialDnt: 'potentialtable.optimised.json',
        potentialDntEx: 'potentialtable_reboot.optimised.json',
        sparkDnt: 'potentialtable_potentialjewel.optimised.json',
        gemSlotDnt: 'dragonjewelslottable.lzjson',
        type: 'techs',
        minLevel: 60,
        minRank: 0 },

      tman: {
        mainDnt: 'itemtable_talisman.optimised.json',
        type: 'talisman',
        potentialDnt: 'potentialtable_talismanitem.optimised.json',
        minLevel: 24,
        minRank: 0 },

      gem: {
        mainDnt: 'itemtable_dragonjewel.optimised.json',
        potentialDnt: 'potentialtable_dragonjewel.optimised.json',
        potentialDntEx: 'potentialtable_reboot.optimised.json',
        enchantDnt: 'enchanttable_dragonjewel.optimised.json',
        gemDnt: 'dragonjeweltable.optimised.json',
        type: 'gems',
        minLevel: 24,
        minRank: 3 },

      plate: {
        mainDnt: 'itemtable_glyph.optimised.json',
        potentialDnt: 'potentialtable_glyph.optimised.json',
        type: 'plates',
        minLevel: 16,
        minRank: 2 },
      plate95: {
        mainDnt: 'itemtable_glyph95.lzjson',
        potentialDnt: 'potentialtable_glyph95.lzjson',
        type: 'plates',
        minLevel: 1,
        minRank: 1,
        ignoreErrors: true },

      items: {
        mainDnt: 'itemtable.optimised.json',
        partsDnt: 'partstable.optimised.json',
        weaponDnt: 'weapontable.optimised.json',
        enchantDnt: 'enchanttable.optimised.json',
        potentialDnt: 'potentialtable.optimised.json',
        setDnt: 'setitemtable.optimised.json',
        gemSlotDnt: 'dragonjewelslottable.lzjson',
        type: 'equipment',
        minLevel: 80,
        minRank: 3 },
      eq: {
        mainDnt: 'itemtable_equipment.optimised.json',
        partsDnt: 'partstable_equipment.optimised.json',
        weaponDnt: 'weapontable_equipment.optimised.json',
        enchantDnt: 'enchanttable.optimised.json',
        potentialDnt: 'potentialtable.optimised.json',
        sparkDnt: 'potentialtable_potentialjewel.optimised.json',
        setDnt: 'setitemtable.optimised.json',
        gemSlotDnt: 'dragonjewelslottable.lzjson',
        type: 'equipment',
        minLevel: 21,
        minRank: 3 },
      rbeq: {
        mainDnt: 'itemtable_reboot.optimised.json',
        partsDnt: 'partstable_reboot.optimised.json',
        weaponDnt: 'weapontable_reboot.optimised.json',
        enchantDnt: 'enchanttable_reboot.optimised.json',
        enchantDnt2: 'enchanttable_95.lzjson',
        potentialDnt: 'potentialtable_reboot.optimised.json',
        setDnt: 'setitemtable.optimised.json',
        gemSlotDnt: 'dragonjewelslottable.lzjson',
        type: 'equipment',
        minLevel: 24,
        minRank: 3 },
      pvpeq: {
        mainDnt: 'itemtable_pvp.optimised.json',
        partsDnt: 'partstable_pvp.optimised.json',
        weaponDnt: 'weapontable_pvp.optimised.json',
        enchantDnt: 'enchanttable.optimised.json',
        setDnt: 'setitemtable.optimised.json',
        type: 'equipment',
        gemSlotDnt: 'dragonjewelslottable.lzjson',
        minLevel: 24,
        minRank: 3 },

      cCommon: {
        mainDnt: 'itemtable_commoncash.lzjson',
        partsDnt: 'partstable_commoncash.lzjson',
        weaponDnt: 'weapontable_commoncash.lzjson',
        setDnt: 'setitemtable_cash.lzjson',
        type: 'cash',
        minLevel: 0,
        ignoreErrors: true,
        minRank: 4 },
      cClone: {
        mainDnt: 'itemtable_cashclone.optimised.json',
        partsDnt: 'partstable_cashclone.optimised.json',
        type: 'cash',
        minLevel: 0,
        ignoreErrors: true,
        minRank: 4 },
      c2016: {
        mainDnt: 'itemtable_common2016.optimised.json',
        partsDnt: 'partstable_common2016.optimised.json',
        weaponDnt: 'weapontable_common2016.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      c2017: {
        mainDnt: 'itemtable_common2017.optimised.json',
        partsDnt: 'partstable_common2017.optimised.json',
        weaponDnt: 'weapontable_common2017.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        type: 'cash',
        minLevel: 0,
        ignoreErrors: true,
        minRank: 0 },
      c2015: {
        mainDnt: 'itemtable_common2015.optimised.json',
        partsDnt: 'partstable_common2015.optimised.json',
        weaponDnt: 'weapontable_common2015.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      c2014: {
        mainDnt: 'itemtable_common2014.optimised.json',
        partsDnt: 'partstable_common2014.optimised.json',
        weaponDnt: 'weapontable_common2014.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      cash: {
        mainDnt: 'itemtable_cash.optimised.json',
        partsDnt: 'partstable_cash.optimised.json',
        weaponDnt: 'weapontable_cash.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      event: {
        mainDnt: 'itemtable_event.optimised.json',
        partsDnt: 'partstable_event.optimised.json',
        weaponDnt: 'weapontable_event.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        type: 'cash',
        minLevel: 0,
        minRank: 0 },
      xtras: {
        mainDnt: 'itemtable_vehicle.optimised.json',
        partsDnt: 'vehiclepartstable.optimised.json',
        setDnt: 'setitemtable_cash.optimised.json',
        petDnt: 'vehicletable.lzjson',
        petLevelDnt: 'petleveltable.lzjson',
        type: 'xtras',
        minLevel: 0,
        minRank: 0 },
      imprint: {
        mainDnt: 'itemtable_imprinting.optimised.json',
        type: 'imprint',
        minLevel: 0,
        minRank: 0 }
    };

    // now that the sources are set up add some methods on them for initialisation
    // each source will store the items from that source for reuse by searches
    angular.forEach(itemSources, function (itemSource, key) {
      itemSource.name = key;
      itemSource.loading = false;
      itemSource.items = null;
      itemSource.init = init; // decalared below
      itemSource.reset = function () {
        itemSource.items = null;
        itemSource.loading = false;
      };
    });

    return itemSources;

    function init(progress, complete) {
      var itemSource = this;
      itemSource.loading = true;

      if (itemSource.items) {
        complete();
      } else {

        translations.init(progress, function () {
          doComplete(itemSource, complete);
        });
        dntData.init(itemSource.mainDnt, itemColumnsToLoad.mainDnt, progress, function () {
          doComplete(itemSource, complete);
        }, itemSource.ignoreErrors);
        if ('potentialDnt' in itemSource) {
          dntData.init(itemSource.potentialDnt, itemColumnsToLoad.potentialDnt, progress, function () {
            doComplete(itemSource, complete);
          }, itemSource.ignoreErrors);
        }
        if ('potentialDntEx' in itemSource) {
          dntData.init(itemSource.potentialDntEx, itemColumnsToLoad.potentialDnt, progress, function () {
            doComplete(itemSource, complete);
          }, itemSource.ignoreErrors);
        }
        if ('gemDnt' in itemSource) {
          dntData.init(itemSource.gemDnt, itemColumnsToLoad.gemDnt, progress, function () {
            doComplete(itemSource, complete);
          }, itemSource.ignoreErrors);
        }

        doComplete(itemSource, complete);
      }
    }

    function doComplete(itemSource, complete) {
      if (translations.isLoaded() && dntData.isLoaded(itemSource.mainDnt) && (!('potentialDnt' in itemSource) || dntData.isLoaded(itemSource.potentialDnt) || dntData.hasFailed(itemSource.potentialDnt)) && (!('potentialDntEx' in itemSource) || dntData.isLoaded(itemSource.potentialDntEx) || dntData.hasFailed(itemSource.potentialDntEx)) && (!('gemDnt' in itemSource) || dntData.isLoaded(itemSource.gemDnt) || dntData.hasFailed(itemSource.gemDnt))) {
        complete();
        itemSource.loading = false;
      }
    }
  };
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('jobs', ['dntData', 'translations', 'itemColumnsToLoad', jobs]);
  function jobs(dntData, translations, itemColumnsToLoad) {

    var fileName = 'jobtable.lzjson';
    var colsToLoad = itemColumnsToLoad.jobsDnt;

    return {
      fileName: fileName,
      allJobs: null,

      isLoaded: function isLoaded() {
        return dntData.isLoaded(fileName);
      },

      hasStartedLoading: function hasStartedLoading() {
        return dntData.hasStartedLoading(fileName);
      },

      init: function init(progress, complete) {
        dntData.init(fileName, colsToLoad, progress, function () {
          complete();
        }, false);
      },

      reset: function reset() {
        this.allJobs = null;
        dntData.reset(fileName);
      },

      getFinalJobs: function getFinalJobs() {
        var jobs = [];
        var alljobs = this.getAllJobs();
        if (alljobs) {
          var numRows = alljobs.length;
          for (var r = 0; r < numRows; ++r) {
            if (alljobs[r].d.JobNumber == 2 && alljobs[r].d.JobIcon > 0) {
              jobs.push(alljobs[r]);
            }
          }
        }

        return jobs;
      },

      getBaseJobs: function getBaseJobs() {
        var retVal = [];
        var baseJobs = {};

        var self = this;
        angular.forEach(this.getFinalJobs(), function (job, key) {
          baseJobs[self.getBaseJobName(job)] = job;
        });

        angular.forEach(baseJobs, function (job, jobName) {
          retVal.push(jobName);
        });

        return retVal;
      },

      getAllJobs: function getAllJobs() {
        if (this.allJobs == null && this.isLoaded() && translations.isLoaded()) {
          var jobs = [];
          var data = dntData.getData(fileName);
          var numRows = data.length;
          for (var r = 0; r < numRows; ++r) {
            jobs[jobs.length] = this.createJob(data[r]);
          }

          this.allJobs = jobs;
        }
        return this.allJobs;
      },

      getById: function getById(id) {
        var data = this.getAllJobs();
        if (data) {
          var numRows = data.length;
          for (var r = 0; r < numRows; ++r) {
            if (data[r].id == id) {
              return data[r];
            }
          }
        }
      },

      createJob: function createJob(d) {
        var t = this;
        return {
          d: d,
          id: d.id,
          name: translations.translate(d.JobName),
          isClassJob: function isClassJob(c) {
            return t.isClassJob(d, c);
          }
        };
      },

      isClassJob: function isClassJob(d, c) {
        if (c == 0) return true;
        if (d.id == c) {
          return true;
        }

        var parentJob = d.ParentJob;

        if (!parentJob) return false;
        if (parentJob == c) return true;

        var parentJobData = this.getById(parentJob);
        if (parentJobData) {
          return this.isClassJob(parentJobData.d, c);
        }

        return false;
      },

      getBaseJobName: function getBaseJobName(job) {
        if (this.isLoaded()) {
          var alljobs = this.getAllJobs();
          if (alljobs) {
            var numRows = alljobs.length;
            for (var r = 0; r < numRows; ++r) {
              if (alljobs[r].id == job.d.BaseClass + 1 && alljobs[r].d.EnglishName) {
                return alljobs[r].d.EnglishName;
              }
            }
          }
        }

        return null;
      }
    };
  }
})();
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
  'use strict';

  angular.module('dnsim').factory('onlineService', ['$window', '$q', 'hCodeValues', onlineService]);

  function onlineService($window, $q, hCodeValues) {
    // console.log('setup online service');

    var service = {
      login: login,
      getUser: function getUser() {
        return firebase.auth().currentUser;
      },
      signOut: signOut,
      deleteAccount: deleteAccount,

      getUserBuilds: getUserBuilds,
      deleteBuild: deleteBuild,
      saveBuild: saveBuild,
      getBuild: getBuild,
      getClassBuilds: getClassBuilds,

      getProfile: getProfile,
      saveProfile: saveProfile,

      stripBuildName: stripBuildName
    };

    init();

    return service;

    function init() {
      // console.log('init');
      firebase.initializeApp({
        apiKey: 'AIzaSyC-Mckgho1xAI2SQzsKnpsr2ObDKOhdSrE',
        authDomain: 'dngearsim.firebaseapp.com',
        databaseURL: 'https://dngearsim.firebaseio.com',
        storageBucket: 'dngearsim.appspot.com'
      });
    }

    function login() {
      return $q(function (resolve, reject) {
        var auth = firebase.auth();

        auth.onAuthStateChanged(function (user) {
          if (user == null) {
            // console.log('redirecting');
            $window.location.href = 'login.html';
          } else {
            // console.log('logged in');
            resolve(user);
          }
        });
      });
    }

    function getProfile(uid) {
      // console.log('get profile');
      return $q(function (resolve, reject) {
        firebase.database().ref('profile/' + uid).once('value', function (storedProfile) {
          if (storedProfile) {
            resolve(storedProfile.val());
          } else {
            resolve({});
          }
        });
      });
    }

    function getBuild(uid, buildName) {
      // console.log('get build');
      return $q(function (resolve, reject) {
        firebase.database().ref('builds/' + uid + '/' + stripBuildName(buildName)).once('value', function (storedProfile) {
          if (storedProfile) {
            resolve(decompressBuild(storedProfile.val()));
          } else {
            resolve({});
          }
        });
      });
    }

    function saveProfile(profile) {
      return $q(function (resolve, reject) {
        var user = service.getUser();
        if (user) {
          profile = angular.copy(profile);
          deleteNullProperties(profile, true);
          firebase.database().ref('profile/' + user.uid).set(profile).then(resolve);
        }
      });
    }

    function getUserBuilds(uid) {
      // console.log('get builds');
      return $q(function (resolve, reject) {
        // console.log('getting builds');
        firebase.database().ref('builds/' + uid).once('value', function (storedBuilds) {
          if (storedBuilds) {
            var retVal = {};
            var val = storedBuilds.val();
            for (var buildName in val) {
              retVal[buildName] = decompressBuild(val[buildName]);
            }
            resolve(retVal);
          } else {
            resolve({});
          }
        });
      });
    }

    function getClassBuilds(job) {
      // console.log('get class builds');
      return $q(function (resolve, reject) {
        // console.log('getting builds', job.id);
        firebase.database().ref('job-builds/' + job.id).once('value', function (jobBuilds) {
          // console.log('ok');
          if (jobBuilds) {
            resolve(jobBuilds.val());
          } else {
            resolve({});
          }
        });
      });
    }

    function compressBuild(build) {

      if (build.items) {
        _.each(build.items, function (item) {
          delete item.fullStats;
        });
      }

      var stringifiedData = JSON.stringify(build);
      return LZString.compressToUTF16(stringifiedData);
    }

    function decompressBuild(compressedBuild) {
      var stringifiedData = LZString.decompressFromUTF16(compressedBuild);
      var build = JSON.parse(stringifiedData);

      if (build.items) {
        _.each(build.items, function (item) {
          item.fullStats = item.stats;

          if (item.enchantmentStats && item.enchantmentStats.length) {
            item.fullStats = hCodeValues.mergeStats(item.enchantmentStats, item.fullStats);
          }

          if (item.sparkStats && item.sparkStats.length) {
            item.fullStats = hCodeValues.mergeStats(item.sparkStats, item.fullStats);
          }
        });
      }

      return build;
    }

    function saveBuild(buildName, build) {
      var user = service.getUser();
      var actions = [];
      if (user) {
        build = angular.copy(build);
        deleteNullProperties(build, true);
        // console.log('saving', build);
        actions.push(firebase.database().ref('builds/' + user.uid + '/' + stripBuildName(buildName)).set(compressBuild(build)));

        if (build.job && build.job.id) {
          // console.log('saving build');

          var data = {};
          if (build.playerLevel) {
            data.lev = build.playerLevel;
          }
          if (build.region) {
            data.region = build.region;
          }
          if (build.guild) {
            data.guild = build.guild;
          }
          if (build.about) {
            data.about = build.about;
          }

          deleteNullProperties(data, true);

          actions.push(firebase.database().ref('job-builds/' + build.job.id + '/' + user.uid + '/' + stripBuildName(buildName)).set(data));
        }
      }
      return $q.all(actions);
    }

    function deleteNullProperties(test, recurse) {
      for (var i in test) {
        if (test[i] === undefined) {
          delete test[i];
        } else if (recurse && _typeof(test[i]) === 'object') {
          deleteNullProperties(test[i], recurse);
        }
      }
    }

    function signOut() {
      var auth = firebase.auth();
      return $q(function (resolve, reject) {
        auth.signOut().then(function () {
          resolve();
        }, function (error) {
          reject();
        });
      });
    }

    function deleteAccount(builds) {
      var auth = firebase.auth();
      var user = service.getUser();

      return $q(function (resolve, reject) {

        var pList = [firebase.database().ref('builds/' + user.uid).remove(), firebase.database().ref('profile/' + user.uid).remove(), firebase.database().ref('private/' + user.uid).remove()];

        var jobIds = [];
        for (var buildName in builds) {
          if (builds[buildName].job) {
            jobIds.push(builds[buildName].job.id);
          }
        }

        jobIds = _.uniq(jobIds);
        _.each(jobIds, function (id) {
          pList.push(firebase.database().ref('job-builds/' + id + '/' + user.uid).remove());
        });

        $q.all(pList).then(function () {
          // console.log('deleted data');
          user.delete().then(function () {
            // console.log('deleted user');
            auth.signOut().then(function () {
              // console.log('signed out');
              resolve();
            }, function (error) {
              reject();
            });
          });
        });
      });
    }

    function deleteBuild(buildName, build) {

      var pList = [];
      var user = service.getUser();
      if (user) {
        pList.push(firebase.database().ref('builds/' + user.uid + '/' + stripBuildName(buildName)).remove());

        if (build.job) {
          pList.push(firebase.database().ref('job-builds/' + build.job.id + '/' + user.uid + '/' + stripBuildName(buildName)).remove());
        }
      }

      return $q.all(pList);
    }

    function stripBuildName(buildName) {
      return buildName.replace(/[.$\[\]#\/]/g, '');
    }
  }
})();
"use strict";

(function () {
  'use strict';

  quickAddHelper.$inject = ["dntData", "translations", "itemColumnsToLoad", "itemCategory", "itemFactory", "jobs", "hCodeValues"];
  angular.module('dnsim').factory('quickAddHelper', quickAddHelper);
  function quickAddHelper(dntData, translations, itemColumnsToLoad, itemCategory, itemFactory, jobs, hCodeValues) {

    return {
      getItem: getItem,
      findData: findData
    };

    function getItem(datas) {
      var item = null;
      for (var d = 0; d < datas.length; ++d) {
        if (datas[d].def.isItemStep) {
          item = datas[d].value;
        }
      }

      for (var d = 0; d < datas.length; ++d) {
        if (datas[d].def.alterItem) {
          datas[d].def.alterItem(datas[d].value.id, item);
        }
      }

      return item;
    }

    function findData(category, build, datas, maxItems) {
      if (!maxItems) {
        maxItems = 9999;
      }

      var allItems = itemCategory.getItems(category.name);
      var retVal = [];
      var numItems = allItems.length;

      var sortFunc = null;
      var sortId = null;

      for (var i = 0; i < numItems; ++i) {

        var item = allItems[i];

        if (!category.hideJob && build.job.id > 0 && item.needJobClass > 0 && !jobs.isClassJob(build.job.d, item.needJobClass)) {
          continue;
        }
        itemFactory.initItem(item);

        var addItem = true;
        for (var d = 0; d < datas.length; ++d) {
          if (!datas[d].def.matchesItem || datas[d].def.matchesItem(datas[d].value.id, item)) {
            if ('sortFunc' in datas[d].def) {
              sortFunc = datas[d].def.sortFunc;
              sortId = datas[d].value.id;
            }
          } else {
            addItem = false;
            break;
          }
        }

        if (addItem) {
          retVal.push(item);
        }

        if (retVal.length >= maxItems) {
          break;
        }
      }

      retVal = filterDuplicates(retVal);

      retVal = retVal.sort(function (item1, item2) {
        if (sortFunc) {
          return sortFunc(sortId, item1, item2);
        } else {
          return item1.name.localeCompare(item2.name);
        }
      });

      return retVal;
    }

    function filterDuplicates(items) {
      var retVal = [];
      for (var i = 0; i < items.length; ++i) {
        var found = false;
        for (var j = 0; j < i; ++j) {
          if (areSameItem(items[i], items[j])) {
            found = true;
            break;
          }
        }

        if (!found) {
          retVal.push(items[i]);
        }
      }

      return retVal;
    }

    function areSameItem(item1, item2) {
      if (item1.name != item2.name || item1.stats.length != item2.stats.length || item1.rank != item2.rank || item1.levelLimit != item1.levelLimit) {
        return false;
      }

      return _.isEqual(item1.stats, item2.stats);
    }
  }
})();
"use strict";

(function () {
  'use strict';

  quickAdd.$inject = ["dntData", "translations", "itemColumnsToLoad", "itemCategory", "itemFactory", "jobs", "hCodeValues", "quickAddSteps", "quickAddHelper"];
  angular.module('dnsim').factory('quickAdd', quickAdd);
  function quickAdd(dntData, translations, itemColumnsToLoad, itemCategory, itemFactory, jobs, hCodeValues, quickAddSteps, quickAddHelper) {

    return {
      categorySteps: {
        titles: ['titleStep'],
        weapons: ['exchangeStep', 'levelStep', 'rankStep', 'itemNameStep', 'hasStatStep', 'itemStep', 'enhanceEqStep'],
        armour: ['exchangeStep', 'levelStep', 'rankStep', 'itemNameStep', 'hasStatStep', 'itemStep', 'enhanceEqStep'],
        accessories: ['accExchangeStep', 'levelStep', 'rankStep', 'itemNameStep', 'hasStatStep', 'itemStep'],
        techs: ['exchangeStep', 'levelStep', 'rankStep', 'techSkillStep', 'itemNameStep', 'hasStatStep', 'itemStep'],
        'offensive gems': ['levelStep', 'gemRankStep', 'itemNameStep', 'numStatsStep', 'hasStatStep', 'itemStep', 'enhanceGemStep'],
        'increasing gems': ['levelStep', 'gemRankStep', 'itemNameStep', 'numStatsStep', 'hasStatStep', 'itemStep', 'enhanceGemStep'],
        'enhancement plates': ['levelStep', 'rankStep', 'distinctItemNameStep', 'numStatsStep', 'hasStatStep', 'itemStep'],
        'expedition plates': ['levelStep', 'distinctItemNameStep', 'numStatsStep', 'highStatStep', 'hasStatStep', 'itemStep'],
        talisman: ['levelStep', 'talismanRankStep', 'distinctItemNameStep', 'numStatsStep', 'hasStatStep', 'itemStep', 'enhanceTalismanStep'],
        costume: ['exchangeStep', 'rankStep', 'itemNameStep', 'itemStep'],
        imprint: ['rankStep', 'itemNameStep', 'highStatStep', 'itemStep'],
        cash: ['accExchangeStep', 'rankStep', 'itemNameStep', 'itemStep'],
        custom: ['customStep']
      },
      getOptions: function getOptions(category, build, datas) {
        var t = this;
        if (category.name in this.categorySteps) {
          var stepName = this.getStepName(category, datas.length);
          var stepDef = quickAddSteps[stepName];
          var allOptions = stepDef.getOptions(category, build, datas);
          if (stepDef.isItemStep) {
            return allOptions;
          } else {
            if (stepDef.minOptions) {
              var unfilteredItems = quickAddHelper.findData(category, build, datas, 50);
            }

            var newOptions = _.filter(allOptions, function (option) {
              var tempDatas = datas.concat([t.createData(option, category, datas.length)]);

              var items;
              if (stepDef.minOptions) {
                if (allOptions[0] == option) {
                  return true;
                }

                items = quickAddHelper.findData(category, build, tempDatas, 50);
                if (items.length > 0 && items.length < 50) {
                  return items.length < unfilteredItems.length;
                }
              } else {
                items = quickAddHelper.findData(category, build, tempDatas, 1);
              }
              return items.length;
            });

            if (stepDef.minOptions && newOptions.length < stepDef.minOptions) {
              return [allOptions[0]];
            }

            return newOptions;
          }
        } else {
          return [];
        }
      },
      hasOptions: function hasOptions(category, build, datas) {
        if (category.name in this.categorySteps) {
          var stepName = this.getStepName(category, datas.length);
          if (quickAddSteps[stepName].hasOptions) {
            return quickAddSteps[stepName].hasOptions(category, build, datas);
          } else {
            return quickAddSteps[stepName].getOptions(category, build, datas).length > 0;
          }
        } else {
          return false;
        }
      },
      isValidStepNumber: function isValidStepNumber(category, stepNumber) {
        return this.categorySteps[category.name].length > stepNumber;
      },
      createData: function createData(value, category, stepNumber) {
        var stepName = this.getStepName(category, stepNumber);
        var def = quickAddSteps[stepName];

        return {
          step: stepName,
          value: value,
          def: def
        };
      },
      getItem: quickAddHelper.getItem,
      getStepName: function getStepName(category, stepNumber) {
        return this.categorySteps[category.name][stepNumber];
      }
    };
  }
})();
"use strict";

(function () {
  'use strict';

  quickAddSteps.$inject = ["dntData", "translations", "itemColumnsToLoad", "itemCategory", "itemFactory", "jobs", "hCodeValues", "quickAddHelper"];
  angular.module('dnsim').factory('quickAddSteps', quickAddSteps);
  function quickAddSteps(dntData, translations, itemColumnsToLoad, itemCategory, itemFactory, jobs, hCodeValues, quickAddHelper) {

    return {
      exchangeStep: {
        name: 'type',
        getOptions: function getOptions(category, build, datas) {

          var exchanges = [];

          for (var e = 0; e < category.limitExchange.length; ++e) {
            var exId = category.limitExchange[e];

            var numExchange = 0;
            if (build.items) {
              for (var i = 0; i < build.items.length; ++i) {
                if (build.items[i].exchangeType == exId) {
                  numExchange++;
                }
              }
            }

            if (numExchange >= category.maxExchange) {
              continue;
            }

            var exchange = dntData.find('exchange.lzjson', 'ExchangeType', exId);
            var exName = '';
            if (exchange && exchange.length > 0 && exchange[0].NameID > 0) {
              exName = translations.translate(exchange[0].NameID).toLowerCase();
            }
            exchanges.push({ id: exId, name: exName.toLowerCase() });
          }

          return exchanges;
        },
        matchesItem: function matchesItem(id, item) {
          return item.exchangeType == id;
        }
      },
      accExchangeStep: {
        name: 'type',
        getOptions: function getOptions(category, build, datas) {

          var exchanges = [];

          for (var e = 0; e < category.limitExchange.length; ++e) {
            var exId = category.limitExchange[e];

            var numExchange = 0;
            for (var i = 0; i < build.items.length; ++i) {
              if (build.items[i] && build.items[i].exchangeType == exId) {
                numExchange++;
              }
            }

            if (exId == 10 || exId == 25) {
              if (numExchange >= 2) {
                continue;
              }
            } else {
              if (numExchange >= 1) {
                continue;
              }
            }

            var exchange = dntData.find('exchange.lzjson', 'ExchangeType', exId);
            if (exchange && exchange.length > 0 && exchange[0].NameID > 0) {
              var exName = translations.translate(exchange[0].NameID).toLowerCase();

              exchanges.push({ id: exId, name: exName.toLowerCase() });
            }
          }

          return exchanges;
        },
        matchesItem: function matchesItem(id, item) {
          return item.exchangeType == id;
        }
      },
      levelStep: {
        name: 'level',
        getOptions: function getOptions(category, build, datas) {

          return [{ id: 95, name: 'level 95' }, { id: 93, name: 'level 93' }, { id: 90, name: 'level 90' }, { id: 80, name: 'level 80' }, { id: 70, name: 'level 70' }, { id: 60, name: 'level 60' }, { id: 50, name: 'level 50' }, { id: 40, name: 'level 40' }, { id: 32, name: 'level 32' }, { id: 24, name: 'level 24' }];
        },
        matchesItem: function matchesItem(id, item) {
          return item.levelLimit == id;
        }
      },
      talismanRankStep: {
        name: 'rank',
        getOptions: function getOptions(category, build, datas) {

          return [{ id: 3, name: 'epic' }, { id: 2, name: 'rare' }, { id: 999, name: 'quality high grade' }, { id: 1, name: 'magic' }, { id: 0, name: 'normal' }];
        },
        matchesItem: function matchesItem(id, item) {
          itemFactory.initItem(item);
          if (item.name) {
            // todo: change this to use the name id
            var index = Math.max(item.name.indexOf('Quality'), item.name.indexOf('High Grade'));

            if (id == 999) {
              return index === 0;
            } else {
              return item.rank && item.rank.id == id && index != 0;
            }
          }
          return false;
        }
      },
      gemRankStep: {
        name: 'rank',
        getOptions: function getOptions(category, build, datas) {

          return [{ id: 5, name: 'legendary' }, { id: 4, name: 'unique' }, { id: 999, name: 'quality high grade epic' }, { id: 3, name: 'epic' }];
        },
        matchesItem: function matchesItem(id, item) {
          itemFactory.initItem(item);
          if (item.name) {
            var index = Math.max(item.name.indexOf('Quality'), item.name.indexOf('High Grade'));
            if (id == 999) {
              return item.rank && item.rank.id == 3 && index >= 0;
            } else {
              return item.rank && item.rank.id == id && index < 0;
            }
          }
          return false;
        }
      },
      rankStep: {
        name: 'rank',
        getOptions: function getOptions(category, build, datas) {

          var values = [];
          for (var id in hCodeValues.rankNames) {
            values.push(hCodeValues.rankNames[id]);
          }
          return values;
        },
        matchesItem: function matchesItem(id, item) {
          return item.rank && item.rank.id == id;
        }
      },
      enhanceTalismanStep: {
        name: 'slot',
        getOptions: function getOptions(category, build, datas) {

          return [{ id: 100, name: '+100% slot' }, { id: 75, name: '+75% slot' }, { id: 25, name: '+25% slot' }, { id: 0, name: '+0% slot' }];
        },
        alterItem: function alterItem(id, item) {
          item.enchantmentNum = id;
        }
      },
      titleStep: {
        name: 'select',
        getOptions: function getOptions(category, build, datas) {
          var allTitles = quickAddHelper.findData(category, build, datas, 9999);
          var usefulTitles = [];
          for (var i = 0; i < allTitles.length; ++i) {
            switch (allTitles[i].id) {
              case 1975: // Manticore Expert
              case 1973: // Returned
              case 1008: // Dark Knight
              case 230: // Miraculous
              case 279: // Provoking
              case 2032: // Sharing Goddess's Grief
              case 2033: // Grief-stricken
              case 1313: // Jakard's Demise
              case 2188:
                // Teary eyed
                // case 1280: // Dragon Tamer
                // case 339: // Cow Wrangler
                usefulTitles.push(allTitles[i]);
                break;
            }
          }

          return usefulTitles;
        },
        hasOptions: function hasOptions(category, build, datas) {
          return true;
        },
        isItemStep: true
      },
      enhanceEqStep: {
        name: 'enhance',
        getOptions: function getOptions(category, build, datas) {

          var item = quickAddHelper.getItem(datas);
          if (item && item.enchantmentId) {
            return [{ id: 20, name: 'enhance to +20' }, { id: 19, name: 'enhance to +19' }, { id: 18, name: 'enhance to +18' }, { id: 17, name: 'enhance to +17' }, { id: 16, name: 'enhance to +16' }, { id: 15, name: 'enhance to +15' }, { id: 14, name: 'enhance to +14' }, { id: 13, name: 'enhance to +13' }, { id: 12, name: 'enhance to +12' }, { id: 11, name: 'enhance to +11' }, { id: 10, name: 'enhance to +10' }, { id: 9, name: 'enhance to +9' }, { id: 8, name: 'enhance to +8' }, { id: 7, name: 'enhance to +7' }, { id: 6, name: 'enhance to +6' }, { id: 5, name: 'enhance to +5' }, { id: 4, name: 'enhance to +4' }, { id: 3, name: 'enhance to +3' }, { id: 2, name: 'enhance to +2' }, { id: 1, name: 'enhance to +1' }, { id: 0, name: 'not enhanced' }];
          } else {
            return [{ id: 0, name: 'not enhanced' }];
          }
        },
        alterItem: function alterItem(id, item) {
          item.enchantmentNum = id;
        }
      },
      enhanceGemStep: {
        name: 'enhance',
        getOptions: function getOptions(category, build, datas) {

          var item = quickAddHelper.getItem(datas);
          if (item && item.enchantmentId) {
            return [{ id: 15, name: 'enhance to +15' }, { id: 14, name: 'enhance to +14' }, { id: 13, name: 'enhance to +13' }, { id: 12, name: 'enhance to +12' }, { id: 11, name: 'enhance to +11' }, { id: 10, name: 'enhance to +10' }, { id: 9, name: 'enhance to +9' }, { id: 8, name: 'enhance to +8' }, { id: 7, name: 'enhance to +7' }, { id: 6, name: 'enhance to +6' }, { id: 5, name: 'enhance to +5' }, { id: 4, name: 'enhance to +4' }, { id: 3, name: 'enhance to +3' }, { id: 2, name: 'enhance to +2' }, { id: 1, name: 'enhance to +1' }, { id: 0, name: 'not enhanced' }];
          } else {
            return [{ id: 0, name: 'not enhanced' }];
          }
        },
        alterItem: function alterItem(id, item) {
          item.enchantmentNum = id;
        }
      },
      itemStep: {
        name: 'select',
        getOptions: function getOptions(category, build, datas) {
          return quickAddHelper.findData(category, build, datas);
        },
        isItemStep: true,
        hideName: true
      },
      namedItemStep: {
        name: 'select',
        getOptions: function getOptions(category, build, datas) {
          return quickAddHelper.findData(category, build, datas);
        },
        isItemStep: true
      },
      techSkillStep: {
        name: 'skill',
        getOptions: function getOptions(category, build, datas) {
          var items = quickAddHelper.findData(category, build, datas, 1);

          // eventually show all the skills
          // but for now
          if (items.length > 0) {
            return [{ id: items[0].skillId, name: items[0].skillId }];
          } else {
            return [];
          }
        },
        matchesItem: function matchesItem(id, item) {
          return item.skillId == id;
        }
      },
      itemNameStep: {
        name: 'item',
        getOptions: function getOptions(category, build, datas) {
          var items = quickAddHelper.findData(category, build, datas);
          var itemNames = {};
          var itemNamesList = [];
          for (var i = 0; i < items.length; ++i) {
            var name = items[i].name;
            if (!(name in itemNames)) {
              itemNames[name] = true;
              itemNamesList.push({
                id: name,
                name: name
              });
            }
          }

          return itemNamesList;
        },
        matchesItem: function matchesItem(id, item) {
          return item.name == id;
        },
        isItemStep: true
      },
      distinctItemNameStep: {
        name: 'item',
        getOptions: function getOptions(category, build, datas) {
          var items = quickAddHelper.findData(category, build, datas);
          var itemNames = {};
          var itemNamesList = [];

          for (var i = 0; i < build.items.length; ++i) {
            var item = build.items[i];
            itemNames[item.name] = true;
          }

          for (var i = 0; i < items.length; ++i) {
            var name = items[i].name;
            if (!(name in itemNames)) {
              itemNames[name] = true;
              itemNamesList.push({
                id: name,
                name: name
              });
            }
          }

          return itemNamesList;
        },
        matchesItem: function matchesItem(id, item) {
          return item.name == id;
        },
        isItemStep: true
      },
      numStatsStep: {
        name: 'Num Stats',
        getOptions: function getOptions(category, build, datas) {
          var items = quickAddHelper.findData(category, build, datas);
          var numStats = {};

          for (var i = 0; i < items.length; ++i) {
            var len = 0;
            for (var j = 0; j < items[i].stats.length; ++j) {
              var stat = hCodeValues.stats[items[i].stats[j].id];
              if (stat && !stat.hide) {
                len++;
              }
            }
            numStats[len + 'x stats'] = len;
          }

          var retVal = [];
          for (var val in numStats) {
            retVal.push({
              id: numStats[val],
              name: val
            });
          }

          retVal = retVal.sort(function (a, b) {
            return a.id - b.id;
          });

          return retVal;
        },
        matchesItem: function matchesItem(id, item) {
          var len = 0;
          for (var j = 0; j < item.stats.length; ++j) {
            var stat = hCodeValues.stats[item.stats[j].id];
            if (stat && !stat.hide) {
              len++;
            }
          }

          return len == id;
        },
        isItemStep: true
      },
      highStatStep: {
        name: 'High Stat',
        getOptions: function getOptions(category, build, datas) {
          var items = quickAddHelper.findData(category, build, datas);

          var allItem = { id: -1, name: 'all' };
          var retVal = [allItem];
          if (items.length > 1) {
            var allStats = {};

            for (var i = 0; i < items.length; ++i) {
              for (var j = 0; j < items[i].stats.length; ++j) {
                var stat = hCodeValues.stats[items[i].stats[j].id];
                if (stat && stat.quickHigh && !('high ' + stat.name in allStats)) {
                  allStats['high ' + stat.name] = stat.id;
                }
              }
            }

            for (var val in allStats) {
              retVal.push({
                id: allStats[val],
                name: val
              });
            }

            if (retVal.length <= 2) {
              retVal = [allItem];
            } else {
              retVal = retVal.sort(function (a, b) {
                return a.id - b.id;
              });
            }
          }

          return retVal;
        },
        matchesItem: function matchesItem(id, item) {
          if (id == -1) {
            return true;
          }

          var largestVal = 0;
          var selectedVal = 0;

          for (var j = 0; j < item.stats.length; ++j) {
            var val = item.stats[j];
            var stat = hCodeValues.stats[val.id];
            if (stat.quickHigh) {
              if (val.id == id) {
                selectedVal += val.max;
              } else if (val.max > largestVal) {
                largestVal = val.max;
              }
            }
          }

          return selectedVal > largestVal;
        },
        sortFunc: function sortFunc(id, item1, item2) {
          var val1 = 0;
          var val2 = 0;

          for (var i = 0; i < item1.stats.length; ++i) {
            if (item1.stats[i].id == id) {
              val1 = item1.stats[i].max;
              break;
            }
          }
          for (var j = 0; j < item2.stats.length; ++j) {
            if (item2.stats[j].id == id) {
              val2 = item2.stats[j].max;
              break;
            }
          }
          return val2 - val1;
        },
        isItemStep: false,
        minOptions: 3
      },
      hasStatStep: {
        name: 'Has Stat',
        getOptions: function getOptions(category, build, datas) {
          var items = quickAddHelper.findData(category, build, datas);

          var allItem = { id: -1, name: 'all' };
          var retVal = [allItem];
          if (items.length > 1) {
            var allStats = {};

            for (var i = 0; i < items.length; ++i) {
              for (var j = 0; j < items[i].stats.length; ++j) {
                var stat = hCodeValues.stats[items[i].stats[j].id];
                if (stat && stat.searchable && !('high ' + stat.name in allStats)) {
                  allStats['has ' + stat.name] = stat.id;
                }
              }
            }

            for (var val in allStats) {
              retVal.push({
                id: allStats[val],
                name: val
              });
            }

            if (retVal.length <= 2) {
              retVal = [allItem];
            } else {
              retVal = retVal.sort(function (a, b) {
                return a.id - b.id;
              });
            }
          }

          return retVal;
        },
        matchesItem: function matchesItem(id, item) {
          if (id == -1) {
            return true;
          }

          for (var j = 0; j < item.stats.length; ++j) {
            var val = item.stats[j];
            var stat = hCodeValues.stats[val.id];
            if (stat.searchable) {
              if (val.id == id) {
                return true;
              }
            }
          }

          return false;
        },
        sortFunc: function sortFunc(id, item1, item2) {
          var val1 = 0;
          var val2 = 0;

          for (var i = 0; i < item1.stats.length; ++i) {
            if (item1.stats[i].id == id) {
              val1 = item1.stats[i].max;
              break;
            }
          }
          for (var j = 0; j < item2.stats.length; ++j) {
            if (item2.stats[j].id == id) {
              val2 = item2.stats[j].max;
              break;
            }
          }
          return val2 - val1;
        },
        isItemStep: false,
        minOptions: 3
      },
      customStep: {
        name: 'misc',
        getOptions: function getOptions(category, build, datas) {
          return hCodeValues.customItems;
        },
        isItemStep: true
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('region', ['translations', 'dntReset', 'dntData', '$route', region]);
  function region(translations, dntReset, dntData, $route) {

    var alternativeFiles = { region: 'ALT', name: 'Alternative user specified files', url: '' };
    var hostedFiles = [{ region: 'sea', name: 'south east asia', url: 'https://seadnfiles.firebaseapp.com' }, { region: 'na', name: 'north america', url: 'https://dnna.firebaseapp.com' }, { region: 'eu', name: 'europe', url: 'https://eufiles.firebaseapp.com' }, { region: 'ina', name: 'indonesia ', url: 'https://inafiles-da491.firebaseapp.com' }, { region: 'th', name: 'thailand', url: 'https://thdnfiles.firebaseapp.com' }, { region: 'vn', name: 'vietnam ', url: 'https://vndnfiles.firebaseapp.com' }, { region: 'tw', name: 'taiwan 臺灣', url: 'https://twdnfiles.firebaseapp.com' },
    // {region: 'jdn', name: 'japan 日本', url : 'https://jdnfiles-59d57.firebaseapp.com'},
    { region: 'cdn', name: 'china 中國', url: 'https://cdnfiles.firebaseapp.com' }, { region: 'kdn', name: 'korea 대한민국', url: 'https://kdnfiles.firebaseapp.com' }];

    var dntLocationRegion = localStorage.getItem('lastDNTRegion');
    var dntLocation = null;
    if (dntLocationRegion) {
      angular.forEach(hostedFiles, function (hostedFile, index) {
        if (hostedFile.region == dntLocationRegion) {
          dntLocation = hostedFile;
        }
      });
    }

    var lastTFile = localStorage.getItem('UIStrings_file');
    var tlocation = null;
    if (lastTFile) {
      angular.forEach(hostedFiles, function (hostedFile, index) {
        if (hostedFile.region != alternativeFiles.region && lastTFile.indexOf(hostedFile.url) > -1) {
          tlocation = hostedFile;
        }
      });
    }

    if (tlocation == null) {
      tlocation = dntLocation;
    }

    return {
      hostedFiles: hostedFiles,
      alternativeFiles: alternativeFiles,
      dntLocation: dntLocation,
      tlocation: tlocation,

      setCustomUrl: function setCustomUrl(url) {
        // console.log('setting custom location');
        this.alternativeFiles.url = url;

        var newFiles = [];
        angular.forEach(hostedFiles, function (hostedFile, index) {
          if (hostedFile.region != alternativeFiles.region) {
            newFiles.push(hostedFile);
          }
        });

        newFiles.push(alternativeFiles);
        hostedFiles = newFiles;
        this.hostedFiles = newFiles;
      },

      setLocationByName: function setLocationByName(locationName) {
        var newLocation = null;

        angular.forEach(hostedFiles, function (hostedFile, index) {
          if (hostedFile.region == locationName) {
            newLocation = hostedFile;
          }
        });

        this.setLocation(newLocation);
      },

      setLocation: function setLocation(location) {
        if (location && location != this.dntLocation) {
          this.dntLocation = location;
          dntReset();
          localStorage.setItem('lastDNTRegion', location.region);
          dntReset();
          $route.reload();
        }

        var override = this.getOverride();
        if (this.tlocation == null || !override) {
          this.setTLocation(location);
        }

        this.init();

        // $route.reload();
      },

      setTLocation: function setTLocation(location) {

        if (location != this.tlocation) {

          this.tlocation = location;
          sessionStorage.removeItem('UIStrings');
          localStorage.removeItem('UIStrings_file');
          dntReset();
          translations.reset();
          if (location) {
            var override = this.getOverride();
            translations.small = !override;
            translations.location = this.tlocation.url;
            translations.region = this.tlocation.region;
            translations.init(function () {}, function () {
              $route.reload();
            });
          }
        }
      },

      getOverride: function getOverride() {
        if (localStorage.getItem('tOverride')) {
          return true;
        } else {
          return false;
        }
      },

      setOverride: function setOverride(value) {
        if (!value) {
          localStorage.removeItem('tOverride');
        } else {
          localStorage.setItem('tOverride', '1');
        }
        this.setTLocation(this.dntLocation);
      },

      init: function init() {
        if (this.getOverride()) {
          translations.small = false;
        } else {
          this.tLocation = this.dntLocation;
          translations.small = true;
        }

        if (this.tlocation) {
          translations.location = this.tlocation.url;
          translations.region = this.tlocation.region;
        }
        dntData.setLocation(this.dntLocation);
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('saveHelper', ['itemCategory', saveHelper]);
  function saveHelper(itemCategory) {
    return {
      saveItem: function saveItem(groupName, item) {
        var groups = this.getSavedItems();
        if (groupName in groups && Array.isArray(groups[groupName].items)) {

          groups[groupName].items.push(item);
          groups[groupName].lastUpdate = new Date().getTime();
          this.updatedSavedItems(groupName, groups[groupName].items);
        } else {
          this.updatedSavedItems(groupName, [item]);
        }
      },

      saveBuildSelection: function saveBuildSelection(buildName, builds) {
        this.setCurrentBuild(buildName);
        if (builds && buildName in builds && builds[buildName].job && builds[buildName].job.id) {
          localStorage.setItem('jobNumber', builds[buildName].job.id);
        }
      },

      importGroup: function importGroup(groupName, updatedItems) {
        var items = this.getSavedItems();
        groupName = this.getUniqueGroupName(groupName, items);
        this.updatedSavedItems(groupName, updatedItems);
        return groupName;
      },

      getUniqueGroupName: function getUniqueGroupName(groupName, existingGroups) {
        var groupNameIndex = 0;
        if (groupName.lastIndexOf(')') == groupName.length - 1) {
          var startIndex = groupName.lastIndexOf('(');
          if (startIndex > 0) {
            var foundIndex = Number(groupName.substr(startIndex + 1, groupName.length - startIndex - 2));
            if (foundIndex > 0) {
              groupNameIndex = foundIndex + 1;
              groupName = groupName.substr(0, startIndex - 1);
            }
          }
        }

        var originalName = groupName;
        for (;;) {
          var groupName = originalName;
          if (groupNameIndex > 0) {
            groupName = originalName + ' (' + groupNameIndex + ')';
          }

          if (groupName in existingGroups) {
            groupNameIndex++;
          } else {
            break;
          }
        }

        return groupName;
      },

      deleteBuild: function deleteBuild(buildName) {
        var builds = this.getSavedItems();
        if (buildName in builds) {
          delete builds[buildName];
          this.setCurrentBuild(null);
          this.saveBuilds(builds);
        }
      },

      updatedSavedItems: function updatedSavedItems(groupName, updatedItems) {
        var items = this.getSavedItems();
        if (groupName in items) {
          items[groupName].items = updatedItems;
          items[groupName].lastUpdate = new Date().getTime();
        } else {
          items[groupName] = { items: updatedItems, lastUpdate: new Date().getTime() };
          // console.log('created group');
        }

        this.saveBuilds(items);
      },

      saveBuilds: function saveBuilds(builds) {
        var stringifiedData = JSON.stringify(builds);
        localStorage.setItem('savedItems', LZString.compressToUTF16(stringifiedData));
      },

      saveBuild: function saveBuild(oldGroupName, newGroupName, build) {
        this.updateBuild(oldGroupName, newGroupName, build.enemyLevel, build.playerLevel, build.heroLevel, build.job, build.damageType, build.element, build.secondaryElement, build.critResist, build.eleResist, build.enemyStatCaps, build.playerStatCaps, build.conversions, build.baseStats, build.heroStats);
      },

      updateBuild: function updateBuild(oldGroupName, newGroupName, enemyLevel, playerLevel, heroLevel, job, damageType, element, secondaryElement, critResist, eleResist, enemyStatCaps, playerStatCaps, conversions, baseStats, heroStats) {

        var savedItems = this.getSavedItems();

        if (newGroupName in savedItems || oldGroupName == newGroupName) {
          // console.log('not changing name');
          newGroupName = oldGroupName;
        } else if (oldGroupName in savedItems) {
          var group = savedItems[oldGroupName];
          savedItems[newGroupName] = group;
          delete savedItems[oldGroupName];
        }

        savedItems[newGroupName].enemyLevel = enemyLevel;
        savedItems[newGroupName].playerLevel = playerLevel;
        savedItems[newGroupName].heroLevel = heroLevel;
        savedItems[newGroupName].job = job;
        savedItems[newGroupName].damageType = damageType;
        savedItems[newGroupName].element = element;
        savedItems[newGroupName].secondaryElement = secondaryElement;
        savedItems[newGroupName].critResist = critResist;
        savedItems[newGroupName].eleResist = eleResist;
        savedItems[newGroupName].enemyStatCaps = enemyStatCaps;
        savedItems[newGroupName].playerStatCaps = playerStatCaps;
        savedItems[newGroupName].conversions = conversions;
        savedItems[newGroupName].baseStats = baseStats;
        savedItems[newGroupName].heroStats = heroStats;

        this.saveBuilds(savedItems);
      },

      getSavedItems: function getSavedItems() {
        try {
          var stringifiedData = LZString.decompressFromUTF16(localStorage.getItem('savedItems'));
          var savedItems = JSON.parse(stringifiedData);
          return savedItems;
        } catch (ex) {}

        return {};
      },

      currentBuild: null,
      getCurrentBuild: function getCurrentBuild() {
        if (!this.currentBuild) {
          this.currentBuild = localStorage.getItem('currentGroup');
          if (this.currentBuild) {
            var savedItems = this.getSavedItems();
            if (!(this.currentBuild in savedItems)) {
              localStorage.removeItem('currentGroup');
              this.currentBuild = null;
            }
          }
        }

        return this.currentBuild;
      },

      setCurrentBuild: function setCurrentBuild(buildName) {
        this.currentBuild = buildName;
        if (!buildName) {
          localStorage.removeItem('currentGroup', buildName);
        } else {
          localStorage.setItem('currentGroup', buildName);
        }
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('statHelper', ['hCodeValues', statHelper]);
  function statHelper(hCodeValues) {

    return {

      getSetStats: function getSetStats(groupItems) {
        var stats = [];
        var sets = {};

        angular.forEach(groupItems, function (value, key) {
          if (value !== null && value.setStats != null) {
            if (value.setId in sets) {
              sets[value.setId].numItems++;
            } else {
              sets[value.setId] = { numItems: 1, stats: value.setStats };
            }
          }
        });

        angular.forEach(sets, function (value, key) {
          angular.forEach(value.stats, function (stat, index) {
            if (stat.needSetNum <= value.numItems) {
              stats.push(stat);
            }
          });
        });

        return hCodeValues.mergeStats(stats);
      },

      getNumItemsForSet: function getNumItemsForSet(items, setId) {
        var numItems = 0;
        angular.forEach(items, function (value, key) {
          if (value && value.setId && value.setId == setId) {
            numItems++;
          }
        });

        return numItems;
      },

      getCombinedStats: function getCombinedStats(groupItems) {
        var stats = [];

        angular.forEach(groupItems, function (value, key) {
          if (value) {

            if (value.fullStats) {
              stats = stats.concat(value.fullStats);
            } else if (value.stats) {
              stats = stats.concat(value.stats);
            }
          }
        });

        return hCodeValues.mergeStats(stats);
      },

      getCalculatedStatsFromItems: function getCalculatedStatsFromItems(group, items) {
        var nakedStats = this.getNakedStats(group);
        var combinedStats = this.getCombinedStats(items);
        var setStats = this.getSetStats(items);
        var allStats = nakedStats.concat(combinedStats).concat(setStats);
        if (group.heroStats != null && group.heroStats.length > 0) {
          allStats = allStats.concat(group.heroStats);
        }
        allStats = hCodeValues.mergeStats(allStats);

        return this.getCalculatedStats(group, allStats);
      },

      getCalculatedStats: function getCalculatedStats(group, combinedStats) {

        var retVal = [];
        var statLookup = {};
        if (!group.conversions || !group.enemyStatCaps || !group.playerStatCaps) {
          return [];
        }

        angular.forEach(combinedStats, function (stat, index) {
          statLookup[stat.id] = stat;
        });

        function getPc(stat) {
          var statDef = hCodeValues.stats[stat.id];
          if (statLookup[statDef.pc]) {
            return Number(statLookup[statDef.pc].max);
          } else {
            return 0;
          }
        }

        function getSkillPc(stat) {
          var statDef = hCodeValues.stats[stat.id];
          if (statLookup[statDef.skPc]) {
            return Number(statLookup[statDef.skPc].max);
          } else {
            return 0;
          }
        }

        function applyPc(stat) {
          stat.max = Math.floor(stat.max * (1 + getPc(stat)) * (1 + getSkillPc(stat)));
        }

        function dupeStat(id) {
          var stat = statLookup[id];
          if (stat) {
            return { id: id, max: Number(stat.max), pc: stat.pc };
          } else {
            return { id: id, max: 0, pc: 0 };
          }
        }

        function addStat(stat) {
          if (stat.max > 0) {
            retVal.push(stat);
          }
        }

        var critResist;
        if (!('critResist' in group)) {
          critResist = 0.20;
        } else {
          critResist = group.critResist / 100.0;
        }

        var eleResist;
        if (!('eleResist' in group)) {
          eleResist = 0;
        } else {
          eleResist = group.eleResist / 100.0;
        }

        // base stats
        var str = dupeStat(0);
        applyPc(str);
        addStat(str);

        var agi = dupeStat(1);
        applyPc(agi);
        addStat(agi);

        var int = dupeStat(2);
        applyPc(int);
        addStat(int);

        var vit = dupeStat(3);
        applyPc(vit);
        addStat(vit);

        // add vit to hp
        var hp = dupeStat(25);
        hp.max += vit.max * Number(group.conversions.HP);
        applyPc(hp);
        addStat(hp);

        // defs
        var def = dupeStat(8);
        def.max += vit.max * Number(group.conversions.PhysicalDefense);
        applyPc(def);
        addStat(def);

        var defpc = dupeStat(1008);
        // defpc.max = Math.max(0.85, Number(def.max)/Number(group.enemyStatCaps.Cdefense));
        defpc.max = Math.min(0.85, def.max / Number(group.enemyStatCaps.Cdefense));
        addStat(defpc);

        var mdef = dupeStat(9);
        mdef.max += int.max * Number(group.conversions.MagicDefense);
        applyPc(mdef);
        addStat(mdef);

        var mdefpc = dupeStat(1009);
        // mdefpc.max = Math.max(0.85, Number(mdef.max)/Number(group.enemyStatCaps.Cdefense));
        mdefpc.max = Math.min(0.85, mdef.max / Number(group.enemyStatCaps.Cdefense));
        addStat(mdefpc);

        // attack power - like fd but for bufs
        // this shows as blue damage
        // i think there are magic and phis variants of this but doesnt matter
        var aPwr = dupeStat(3000);

        var minPdmg = dupeStat(4);
        var maxPdmg = dupeStat(5);

        // physical damage
        if (!group.damageType || group.damageType.id != 2) {
          var extraPdmg = dupeStat(32);
          var extraPdmgMod = dupeStat(101);
          var paPwr = dupeStat(3001);

          // special stats for zeal
          var intToPdmg = dupeStat(10164);

          minPdmg.max += extraPdmg.max;
          minPdmg.max += Math.floor(str.max * Number(group.conversions.StrengthAttack));
          minPdmg.max += Math.floor(agi.max * Number(group.conversions.AgilityAttack));

          minPdmg.max = Math.floor(minPdmg.max * (1 + (getPc(minPdmg) + extraPdmgMod.max)));
          minPdmg.max = Math.floor(minPdmg.max * (1 + aPwr.max + paPwr.max));
          minPdmg.max += Math.floor(intToPdmg.max * int.max);
          addStat(minPdmg);

          maxPdmg.max += extraPdmg.max;
          maxPdmg.max += Math.floor(str.max * Number(group.conversions.StrengthAttack));
          maxPdmg.max += Math.floor(agi.max * Number(group.conversions.AgilityAttack));

          maxPdmg.max = Math.floor(maxPdmg.max * (1 + (getPc(maxPdmg) + extraPdmgMod.max)));
          maxPdmg.max = Math.floor(maxPdmg.max * (1 + aPwr.max + paPwr.max));
          maxPdmg.max += Math.floor(intToPdmg.max * int.max);
          addStat(maxPdmg);
        }

        var minMdmg = dupeStat(6);
        var maxMdmg = dupeStat(7);

        // magic damage
        if (!group.damageType || group.damageType.id != 1) {
          var extraMdmg = dupeStat(33);
          var extraMdmgMod = dupeStat(102);
          var maPwr = dupeStat(3002);

          // special stats for zeal
          var strToMdmg = dupeStat(10165);
          var intToMdmg = dupeStat(10372);

          minMdmg.max += extraMdmg.max;
          minMdmg.max += Math.floor(int.max * Number(group.conversions.IntelligenceAttack));

          minMdmg.max = Math.floor(minMdmg.max * (1 + (getPc(minMdmg) + extraMdmgMod.max)));
          minMdmg.max = minMdmg.max * (1 + aPwr.max + maPwr.max);
          minMdmg.max += Math.floor(strToMdmg.max * str.max);
          minMdmg.max += Math.floor(intToMdmg.max * int.max);
          addStat(minMdmg);

          maxMdmg.max += extraMdmg.max;
          maxMdmg.max += int.max * Number(group.conversions.IntelligenceAttack);

          maxMdmg.max = Math.floor(maxMdmg.max * (1 + (getPc(maxMdmg) + extraMdmgMod.max)));
          maxMdmg.max = maxMdmg.max * (1 + aPwr.max + maPwr.max);
          maxMdmg.max += Math.floor(strToMdmg.max * str.max);
          maxMdmg.max += Math.floor(intToMdmg.max * int.max);
          addStat(maxMdmg);
        }

        // crit chance %
        var crit = dupeStat(12);
        crit.max += agi.max * Number(group.conversions.Critical);
        applyPc(crit);

        var skCrit = dupeStat(4012);
        crit.max += skCrit.max;
        addStat(crit);
        var itemCrit = dupeStat(1012);

        var critChance = Math.min(0.89, crit.max / Number(group.enemyStatCaps.Ccritical) + itemCrit.max);
        retVal.push({ id: 1012, max: critChance });

        // crit damage %
        var cDmg = dupeStat(103);
        cDmg.max += (str.max + int.max) * Number(group.conversions.StrengthIntelligenceToCriticalDamage);
        applyPc(cDmg);
        addStat(cDmg);

        var itemCtriDmg = dupeStat(1103);
        var critDamagePc = Math.min(1, cDmg.max / group.playerStatCaps.CcriticalDamage + itemCtriDmg.max);
        addStat({ id: 1103, max: critDamagePc + 2 });

        // fd
        var fd = dupeStat(29);
        addStat(fd);
        var maxFd = Number(group.enemyStatCaps.Cfinaldamage);

        var fdPc = dupeStat(1029);
        fdPc.max += Math.min(Math.max(0.35 * Number(fd.max) / maxFd, Math.pow(Number(fd.max) / maxFd, 2.2)), 1);
        addStat(fdPc);

        // elements
        var firePc = dupeStat(16);
        addStat(firePc);

        var icePc = dupeStat(17);
        addStat(icePc);

        var lightPc = dupeStat(18);
        addStat(lightPc);

        var darkPc = dupeStat(19);
        addStat(darkPc);

        // average damage
        function addAvgDamageStat(id, min, max) {

          var nonEleDamage = (min + max) / 2;
          // add crit
          nonEleDamage += critChance * (critDamagePc + 1) * nonEleDamage * (1 - critResist);
          // apply fd
          nonEleDamage = nonEleDamage * (1 + fdPc.max);

          // apply element(s)
          var avgDmg = nonEleDamage;
          if (group.element && group.element.id > 0) {
            var elementStat = statLookup[hCodeValues.elements[group.element.id].dmgStat];
            if (elementStat) {
              avgDmg = avgDmg * (1 + Number(elementStat.max)) * (1 - Number(eleResist));
            }
          }
          addStat({ id: id, max: avgDmg });
          var secElementId = 0;
          var priElementId = 0;
          if (group.element) {
            priElementId = group.element.id;
          } else {
            priElementId = 0;
          }
          if (group.secondaryElement) {
            secElementId = group.secondaryElement.id;
          } else {
            secElementId = 0;
          }

          if (secElementId != priElementId) {
            if (secElementId > 0) {
              var secondaryElementStat = statLookup[hCodeValues.elements[group.secondaryElement.id].dmgStat];
              if (secondaryElementStat) {
                var secAvgDmg = nonEleDamage * (1 + Number(secondaryElementStat.max)) * (1 - Number(eleResist));
                addStat({ id: id + 1000, max: secAvgDmg });
              }
            } else {
              addStat({ id: id + 1000, max: nonEleDamage });
            }
          }
        }

        // average damages
        if (!group.damageType || group.damageType.id == 1 || group.damageType.id == 0) {
          addAvgDamageStat(1004, minPdmg.max, maxPdmg.max);
        }

        if (!group.damageType || group.damageType.id == 2 || group.damageType.id == 0) {
          addAvgDamageStat(1006, minMdmg.max, maxMdmg.max);
        }

        if (!group.damageType || group.damageType.id == 3) {
          addAvgDamageStat(1001, minMdmg.max + minPdmg.max, maxMdmg.max + maxPdmg.max);
        }

        // Equivalent HP
        var pdefEqHp = dupeStat(2008);
        pdefEqHp.max = hp.max / (1 - defpc.max);

        var mdefEqHp = dupeStat(2009);
        mdefEqHp.max = hp.max / (1 - mdefpc.max);

        var eqHp = dupeStat(3008);
        eqHp.max = (pdefEqHp.max + mdefEqHp.max) / 2;
        addStat(eqHp);

        return retVal;
      },

      getNakedStats: function getNakedStats(group) {

        if (group.baseStats && group.baseStats.Strength > 0) {

          return [{ id: 0, max: group.baseStats.Strength }, { id: 1, max: group.baseStats.Agility }, { id: 2, max: group.baseStats.Intelligence }, { id: 3, max: group.baseStats.Stamina }];
        } else {
          return [];
        }
      },

      getSkillStats: function getSkillStats(item, data, skillData) {

        var skillLevelVals = null;
        angular.forEach(skillData, function (value, index) {
          if (value.SkillIndex == item.id && value.SkillLevel == item.enchantmentNum) {
            skillLevelVals = value;
            return;
          }
        });

        if (!skillLevelVals) {
          return null;
        }

        var index = 1;
        var effects = [];
        var stillCols = true;

        while (stillCols) {
          var colName = 'EffectClass' + index;
          var valColName = 'EffectClassValue' + index;
          if (data && colName in data && valColName in skillLevelVals) {
            if (data[colName] > 0) {

              var val = skillLevelVals[valColName];

              // for now add 10k
              var effectId = data[colName];
              var map = hCodeValues.skillEffectMapping[effectId];
              if (map && map.getVals) {
                var vals = map.getVals(val);
                for (var i = 0; i < vals.length; ++i) {
                  effects.push(vals[i]);
                }
              } else {
                var statId;
                if (map && map.mapTo) {
                  statId = map.mapTo;
                } else {
                  statId = 10000 + effectId;
                }

                if (val > 0) {
                  effects.push({ id: statId, effect: effectId, max: val });
                } else {
                  if (val.toString().indexOf(';') > 0) {
                    var vals = val.split(';');
                    if (vals.length > 0 && vals[0] > 0) {
                      effects.push({ id: statId, effect: effectId, max: vals[0] });
                    }
                  }
                }
              }
            }
          } else {
            stillCols = false;
          }

          index++;
        }

        return effects;
      },

      getBuildStats: function getBuildStats(build) {
        var stats = {};
        stats.nakedStats = this.getNakedStats(build);
        stats.combinedStats = this.getCombinedStats(build.items);
        stats.setStats = this.getSetStats(build.items);
        stats.allStats = stats.nakedStats.concat(stats.combinedStats).concat(stats.setStats);
        if (build.heroStats && build.heroStats.length) {
          stats.heroStats = build.heroStats;
          stats.allStats = stats.allStats.concat(build.heroStats);
        }
        stats.allStats = hCodeValues.mergeStats(stats.allStats);

        stats.calculatedStats = this.getCalculatedStats(build, stats.allStats);
        return stats;
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('translations', ['$routeParams', '$rootScope', 'uiTranslations', '$translate', translations]);
  function translations($routeParams, $rootScope, uiTranslations, $translate) {

    var dnTranslations = new DnTranslations();
    var smallFile = 'uistring.optimised.lzjson';
    var bigFile = 'uistring.lzjson';

    var completeCallback = [];
    var progressCallback = [];

    return {

      getRawData: function getRawData() {
        return dnTranslations.data;
      },

      reset: function reset() {
        dnTranslations = new DnTranslations();
        dnTranslations.sizeLimit = 100;
        this.loaded = false;
        this.startedLoading = false;
        completeCallback = [];
        progressCallback = [];
      },

      getFileName: function getFileName() {
        if (this.small) {
          // console.log('loading optimised translations');
          return smallFile;
        } else {
          // console.log('loading full translations');
          return bigFile;
        }
      },

      loaded: false,
      startedLoading: false,
      small: false,

      location: null,
      region: null,

      init: function init(progress, complete) {

        if (this.isLoaded()) {
          complete();
        } else {
          progressCallback = [];
          if (progress) {
            progressCallback.push(progress);
          }
          if (complete) {
            completeCallback.push(complete);
          }

          if (!this.startedLoading) {
            this.startedLoading = true;
            var t = this;

            var fileName = null;
            if (this.location && this.location != '') {
              fileName = this.location + '/' + this.getFileName();

              if (fileName != localStorage.getItem("UIStrings_file")) {
                sessionStorage.removeItem('UIStrings');
                localStorage.removeItem('UIStrings_file');
              }
            }

            $rootScope.$broadcast('TRANSLATION_LOAD_EVENT');
            dnTranslations.loadDefaultFile(fileName, function (msg) {
              angular.forEach(progressCallback, function (value, key) {
                value(msg);
              });
            }, function () {
              uiTranslations.addTranslations(t.region, t.getRawData());
              // console.log('using ', t.region);
              $translate.use(t.region);
              t.loaded = true;
              angular.forEach(completeCallback, function (value, key) {
                value();
              });
              completeCallback = [];
              $rootScope.$broadcast('TRANSLATION_LOAD_EVENT');
            }, function (msg) {
              angular.forEach(progressCallback, function (value, key) {
                value(msg);
              });
              $rootScope.$broadcast('TRANSLATION_LOAD_ERROR');
              t.startedLoading = false;
              t.loaded = false;
            });
          }
        }
      },

      isLoaded: function isLoaded() {
        if (!this.loaded) {
          var fileName = this.location + '/' + this.getFileName();

          if (fileName != localStorage.getItem("UIStrings_file")) {
            sessionStorage.removeItem('UIStrings');
            localStorage.removeItem('UIStrings_file');
          }

          this.loaded = dnTranslations.loadFromSession();
          if (this.loaded) {
            uiTranslations.addTranslations(this.region, this.getRawData());
            $translate.use(this.region);
            this.startedLoading = true;
          }
        }
        return this.loaded;
      },

      translate: function translate(id, idParam) {
        if (this.loaded) {
          try {
            var name;
            if (!id) {
              return '';
            } else {
              name = dnTranslations.translate(id);

              if (typeof name != 'string') {
                return 'm' + name;
              }
            }

            if (idParam && name) {

              if (typeof idParam === 'string') {
                var params = idParam.split(',');
                for (var p = 0; p < params.length; ++p) {
                  var pid = params[p];
                  if (pid.indexOf('{') == 0) {
                    pid = params[p].replace(/\{|\}/g, '');
                    pid = dnTranslations.translate(pid);
                  }

                  name = name.replace('{' + p + '}', pid);
                }
              } else {
                name = name.replace('{0}', idParam);
              }
            }

            return name;
          } catch (ex) {
            console.log('unable to translate', id, idParam, ex);
          }
        }

        return 'm' + id;
      }
    };
  }
})();
"use strict";

(function () {
    'use strict';

    uiTranslations.$inject = ["$routeParams", "$rootScope"];
    angular.module('dnsim').factory('uiTranslations', uiTranslations);

    // translations for each region go in here
    // the key is the english text
    var uiTranslationLookup = {
        cdn: {
            'dragon nest gear simulator': '龙之谷配装模拟器',
            'enemy lvl': '敌人等级',
            'damage type': '伤害类型',
            'player lvl': '玩家等级',
            'hero level stats': '英雄等级状态',
            'naked stats': '裸装状态',
            'stat affects': '状态影响',
            'str': '力量',
            'agi': '敏捷',
            'int': '智力',
            'builds': '方案',
            'search': '搜索',
            'select region': '选择地区',
            'create a new build': '创建一个新方案',
            'import': '输入',
            'publish': '发布',
            'find a build': '寻找一个新方案',
            'about': '关于',
            'import a build from a json build file': '从一个json文件导入方案',
            'log in and publish your builds online': '登录并发布您的方案',
            'vit': '体质',
            'fd': '最终伤害',
            'pdmg': '物理攻击力',
            'mdmg': '魔法攻击力',
            'crit': '致命一击',
            'cdmg': '致命一击伤害',
            'fire%': '火攻击',
            'ice%': '水攻击',
            'light%': '光攻击',
            'dark%': '暗攻击',
            'pdef': '物理防御力',
            'mdef': '魔法防御力',
            'weapons': '武器',
            'armour': '防具',
            'techs': '技巧饰品',
            'titles': '称号',
            'expedition plates': '远征队纹章',
            'enhancement plates': '强化纹章',
            'increasing gems': '强化龙玉',
            'offensive gems': '属性龙玉',
            'back': '返回',
            'cancel': '取消',
            'epic': 'A级',
            'unique': 'S级',
            'legendary': 'L级',
            'quick add': '快速添加',
            'hero lvl': '英雄等级'
        },
        sea: {
            'offensive gems': 'offensive jades',
            'increasing gems': 'increasing jades',
            'expedition plates': 'unique heraldry',
            'enhancement plates': 'normal heraldry',
            'techs': 'skill accessory'
        }
    };

    // this function gets called on language change to add the translations to the main list
    function uiTranslations($routeParams, $rootScope) {
        return {
            addTranslations: function addTranslations(region, data) {
                if (region && data && region in uiTranslationLookup) {
                    var regionData = uiTranslationLookup[region];
                    for (var key in regionData) {
                        data[key] = regionData[key];
                    }
                }
            }
        };
    }
})();
'use strict';

(function () {
  'use strict';

  angular.module('dnsim').factory('hCodeValues', [hCodeValues]);
  function hCodeValues() {

    function toOneDec(stat) {
      return Math.round(stat.max * 10) / 10;
    }
    function toNoDec(stat) {
      return Math.floor(stat.max);
    }
    function inThousands(stat) {
      var val = Number(stat.max);
      if (val < 100) {
        return val;
      } else if (val < 100000) {
        return Math.round(val / 100) / 10 + 'k';
      } else if (val < 1000000) {
        return Math.round(val / 1000) + 'k';
      } else if (val < 10000000) {
        return Math.round(val / 10000) / 100 + 'm';
      } else {
        return Math.round(val / 1000000) + 'm';
      }
    }
    function toPercent(stat) {
      return Math.round(stat.max * 10000) / 100 + '%';
    }

    return {
      stats: {
        0: { id: 0, name: 'str', display: inThousands, dps: true, pc: 50, skPc: 4050, searchable: true, quickHigh: true },
        1: { id: 1, name: 'agi', display: inThousands, dps: true, pc: 51, skPc: 4051, searchable: true, quickHigh: true },
        2: { id: 2, name: 'int', display: inThousands, dps: true, pc: 52, skPc: 4052, searchable: true, quickHigh: true },
        3: { id: 3, name: 'vit', display: inThousands, def: true, pc: 53, skPc: 4053, searchable: true, quickHigh: true },
        4: { id: 4, name: 'pdmg', display: inThousands, combineWith: 5, dps: true, pc: 54, searchable: true, altStat: 32, quickHigh: true },
        5: { id: 5, name: 'maxPdmg', display: inThousands, hide: true, pc: 55 },
        6: { id: 6, name: 'mdmg', display: inThousands, combineWith: 7, dps: true, pc: 56, searchable: true, altStat: 33, quickHigh: true },
        7: { id: 7, name: 'maxMdmg', display: inThousands, hide: true, pc: 57 },
        8: { id: 8, name: 'pdef', display: inThousands, def: true, pc: 58, searchable: true },
        9: { id: 9, name: 'mdef', display: inThousands, def: true, pc: 59, searchable: true },
        10: { id: 10, name: 'para', display: inThousands, pc: 60, noCustom: true },
        11: { id: 11, name: 'para resist', display: inThousands, pc: 61, noCustom: true },
        12: { id: 12, name: 'crit', display: inThousands, dps: true, pc: 62, searchable: true },
        13: { id: 13, name: 'crit resist', display: inThousands, pc: 63, noCustom: true },
        14: { id: 14, name: 'stun', display: inThousands, pc: 64, noCustom: true },
        15: { id: 15, name: 'stun resist', display: inThousands, pc: 65, noCustom: true },
        16: { id: 16, name: 'fire%', display: toPercent, dps: true, searchable: true },
        17: { id: 17, name: 'ice%', display: toPercent, dps: true, searchable: true },
        18: { id: 18, name: 'light%', display: toPercent, dps: true, searchable: true },
        19: { id: 19, name: 'dark%', display: toPercent, dps: true, searchable: true },
        20: { id: 20, name: 'fire def', display: toPercent, def: true, searchable: true },
        21: { id: 21, name: 'ice def', display: toPercent, def: true, searchable: true },
        22: { id: 22, name: 'light def', display: toPercent, def: true, searchable: true },
        23: { id: 23, name: 'dark def', display: toPercent, def: true, searchable: true },
        25: { id: 25, name: 'hp', display: inThousands, def: true, pc: 75, skPc: 4075, searchable: true },
        26: { id: 26, name: 'mp', display: inThousands, def: true, pc: 76, skPc: 4076 },
        29: { id: 29, name: 'fd', display: toNoDec, dps: true, searchable: true },

        // these are both min and max
        // shows with the same name but these are used really just for set bonus I think
        32: { id: 32, name: 'pdmg', display: toNoDec, dps: true, pc: 54, quickHigh: true },
        33: { id: 33, name: 'mdmg', display: toNoDec, dps: true, pc: 56, quickHigh: true },

        50: { id: 50, name: 'str%', display: toPercent, dps: true },
        51: { id: 51, name: 'agi%', display: toPercent, dps: true },
        52: { id: 52, name: 'int%', display: toPercent, dps: true },
        53: { id: 53, name: 'vit%', display: toPercent, def: true },
        54: { id: 54, name: 'pdmg%', display: toPercent, combineWith: 55, dps: true },
        55: { id: 55, name: 'maxPdmg%', display: toPercent, hide: true },
        56: { id: 56, name: 'mdmg%', display: toPercent, combineWith: 57, dps: true },
        57: { id: 57, name: 'maxMdmg%', display: toPercent, hide: true },
        58: { id: 58, name: 'pdef%', display: toPercent, def: true },
        59: { id: 59, name: 'mdef%', display: toPercent, def: true },
        60: { id: 60, name: 'para%', display: toPercent, noCustom: true, def: true },
        61: { id: 61, name: 'para resist%', display: toPercent, noCustom: true, def: true },
        62: { id: 62, name: 'crit%', display: toPercent, dps: true },
        63: { id: 63, name: 'crit resist%', display: toPercent, def: true },
        64: { id: 64, name: 'stun%', display: toPercent, noCustom: true, def: true },
        65: { id: 65, name: 'stun resist%', display: toPercent, noCustom: true, def: true },
        74: { id: 74, name: 'move%', display: toPercent, noCustom: true, def: true },
        75: { id: 75, name: 'hp%', display: toPercent, def: true },
        76: { id: 76, name: 'mp%', display: toPercent, def: true },
        77: { id: 77, name: 'mp recover%', display: toPercent, def: true },
        81: { id: 81, name: 'safe move%', display: toPercent, noCustom: true, def: true },

        // these are both min and max
        // shows with the same name but these are used really just for set bonus I think
        101: { id: 101, name: 'pdmg%', display: toPercent, noCustom: true, dps: true, quickHigh: true },
        102: { id: 102, name: 'mdmg%', display: toPercent, noCustom: true, dps: true, quickHigh: true },

        103: { id: 103, name: 'cdmg', display: inThousands, dps: true, pc: 104, searchable: true },
        104: { id: 104, name: 'crit dmg%', display: toPercent, noCustom: true, dps: true },
        105: { id: 104, name: 'pvp dmg', display: inThousands, noCustom: true, dps: true },
        106: { id: 106, name: 'pvp def', display: inThousands, noCustom: true, def: true },
        107: { id: 107, name: 'mp?', display: toNoDec, noCustom: true, hide: true, def: true },

        // stats below here are ones I made up
        1001: { id: 1001, name: 'dmg', display: inThousands, summaryDisplay: true, element: 'primary', noCustom: true, hide: true },
        1004: { id: 1004, name: 'pdmg', display: inThousands, summaryDisplay: true, element: 'primary', noCustom: true, hide: true },
        1006: { id: 1006, name: 'mdmg', display: inThousands, summaryDisplay: true, element: 'primary', noCustom: true, hide: true },

        1008: { id: 1008, name: 'pdef', display: toPercent, noCustom: true, summaryFor: 8 },
        1009: { id: 1009, name: 'mdef', display: toPercent, noCustom: true, summaryFor: 9 },

        1012: { id: 1012, name: 'crit chance', display: toPercent, noCustom: true, dps: true, summaryFor: 12 },
        1029: { id: 1029, name: 'fd', display: toPercent, noCustom: true, dps: true, summaryFor: 29 },
        1103: { id: 1103, name: 'crit dmg', display: toPercent, noCustom: true, dps: true, summaryFor: 103 },

        2001: { id: 2001, name: 'dmg', display: inThousands, summaryDisplay: true, element: 'secondary', noCustom: true, hide: true },
        2004: { id: 2004, name: 'pdmg', display: inThousands, summaryDisplay: true, element: 'secondary', noCustom: true, hide: true },
        2006: { id: 2006, name: 'mdmg', display: inThousands, summaryDisplay: true, element: 'secondary', noCustom: true, hide: true },

        2008: { id: 2008, name: 'pdef eqhp', display: inThousands, noCustom: true },
        2009: { id: 2009, name: 'mdef eqhp', display: inThousands, noCustom: true },

        3000: { id: 3000, name: 'skDmg%', display: toPercent, dps: true },
        3001: { id: 3001, name: 'skPDmg%', display: toPercent, dps: true },
        3002: { id: 3002, name: 'skMDmg%', display: toPercent, dps: true },

        3008: { id: 3008, name: 'eqhp', display: inThousands, summaryDisplay: true, noCustom: true, hide: true },

        4012: { id: 4012, name: 'skCrit', display: inThousands, dps: true },
        4050: { id: 4050, name: 'skStr%', display: toPercent, dps: true },
        4051: { id: 4051, name: 'skAgi%', display: toPercent, dps: true },
        4052: { id: 4052, name: 'skInt%', display: toPercent, dps: true },
        4053: { id: 4053, name: 'skVit%', display: toPercent, def: true },
        4075: { id: 4075, name: 'skHp%', display: toPercent, def: true },
        4076: { id: 4076, name: 'skMp%', display: toPercent, def: true },

        // special cases for skills
        10164: { id: 10164, name: 'intToPdmg', display: toPercent, noCustom: true, dps: true },
        10165: { id: 10165, name: 'strToMdmg', display: toPercent, noCustom: true, dps: true },
        10372: { id: 10372, name: 'intToMdmg', display: toPercent, noCustom: true, dps: true }
      },

      rankNames: {
        0: { id: 0, name: 'normal' },
        1: { id: 1, name: 'magic' },
        2: { id: 2, name: 'rare' },
        3: { id: 3, name: 'epic' },
        4: { id: 4, name: 'unique' },
        5: { id: 5, name: 'legendary' }
      },

      shopNames: {
        28001: 'lament', 28002: 'lament', 28003: 'lament', 28004: 'lament', 28005: 'lament', 28006: 'lament', 28007: 'lament', 28008: 'lament', 28009: 'lament', 28101: 'lament',
        29001: 'aura', 29002: 'aura', 29003: 'aura', 29004: 'aura', 29005: 'aura', 29006: 'aura', 29007: 'aura', 29008: 'aura', 29009: 'aura',
        5001: 'medal', 5002: 'medal', 5003: 'medal', 5004: 'medal', 5005: 'medal', 5006: 'medal', 5007: 'medal', 5008: 'medal', 5009: 'medal',
        5101: 'ladder', 5102: 'ladder', 5103: 'ladder', 5104: 'ladder', 5105: 'ladder', 5106: 'ladder', 5107: 'ladder', 5108: 'ladder', 5109: 'ladder',
        59001: 'garden bunny',
        52001: 'nightmare', 52002: 'nightmare', 52003: 'nightmare', 52004: 'nightmare', 52005: 'nightmare', 52006: 'nightmare', 52007: 'nightmare', 52008: 'nightmare', 52009: 'nightmare',
        21: 'blacksmith', 22: 'blacksmith', 23: 'blacksmith', 24: 'blacksmith', 25: 'blacksmith', 26: 'blacksmith', 27: 'blacksmith', 28: 'blacksmith', 29: 'blacksmith',
        89001: 'guild master',
        88001: 'battlefield', 88002: 'battlefield', 88003: 'battlefield', 88004: 'battlefield', 88005: 'battlefield', 88006: 'battlefield', 88007: 'battlefield', 88008: 'battlefield', 88009: 'battlefield',
        66001: 'erosion',
        35006: 'plate',
        14051: 'abyss', 14052: 'abyss', 14053: 'abyss', 14054: 'abyss', 14055: 'abyss', 14056: 'abyss', 14057: 'abyss', 14058: 'abyss', 14059: 'abyss',
        40011: 'daredevil faire', 40012: 'daredevil faire', 40013: 'daredevil faire', 40014: 'daredevil faire', 40015: 'daredevil faire', 40016: 'daredevil faire', 40017: 'daredevil faire', 40018: 'daredevil faire',
        40001: 'daredevil faire', 40002: 'daredevil faire', 40111: 'daredevil faire',
        91001: 'wrath',
        45001: 'farm',
        100004: 'event',
        89000: 'nightmare'
      },

      checkedRank: {
        0: true,
        1: true,
        2: true,
        3: true,
        4: true,
        5: true
      },

      typeNames: {
        0: 'weapons',
        1: 'equipment',
        5: 'plates',
        8: 'pouch',
        38: 'plates',
        90: 'welspring',
        132: 'talisman',
        139: 'gems'
      },

      elements: {
        0: { id: 0, name: 'non-ele' },
        1: { id: 1, name: 'fire', dmgStat: 16 },
        2: { id: 2, name: 'ice', dmgStat: 17 },
        3: { id: 3, name: 'light', dmgStat: 18 },
        4: { id: 4, name: 'dark', dmgStat: 19 }
      },

      damageTypes: {
        0: { id: 0, name: 'both separate' },
        1: { id: 1, name: 'physical' },
        2: { id: 2, name: 'magical' },
        3: { id: 3, name: 'both combined' }
      },

      // note: skills shown on-screen have 1k added to their id
      skillEffectMapping: {
        2: { id: 2, name: 'phyisical attack power', mapTo: 3001 },
        13: { id: 13, name: 'mp', mapTo: 26 },
        25: { id: 25, name: 'action speed' },
        29: { id: 29, name: 'magic attack power', mapTo: 3002 },
        32: { id: 32, name: 'fire %', mapTo: 16 },
        33: { id: 33, name: 'ice %', mapTo: 17 },
        34: { id: 34, name: 'light %', mapTo: 18 },
        35: { id: 35, name: 'dark %', mapTo: 19 },
        36: { id: 36, name: 'fire def', mapTo: 20 },
        37: { id: 37, name: 'ice def', mapTo: 21 },
        38: { id: 38, name: 'light def', mapTo: 22 },
        39: { id: 39, name: 'dark def', mapTo: 23 },
        58: { id: 58, name: 'hp%', mapTo: 4075 },
        59: { id: 59, name: 'mp%', mapTo: 4076 },
        65: { id: 65, name: 'range' },
        76: { id: 76, name: 'movement speed', mapTo: 74 },
        87: { id: 87, name: 'str%', mapTo: 4050 },
        88: { id: 88, name: 'agi%', mapTo: 4051 },
        89: { id: 89, name: 'int%', mapTo: 4052 },
        90: { id: 90, name: 'vit%', mapTo: 4053 },
        // 134 : { id: 134, name: 'p dmg reduction%' },
        // 135 : { id: 135, name: 'm dmg reduction%' },
        185: { id: 185, name: 'wots attack power', mapTo: 3000 },
        251: { id: 251, name: 'critical chance%', mapTo: 1012 },
        164: { id: 164, name: 'intToPdmg', mapTo: 10164 },
        165: { id: 165, name: 'strToMdmg', mapTo: 10165 },
        222: {
          id: 222,
          name: 'hellfire',
          getVals: function getVals(val) {
            if (val.indexOf(';') > 0) {
              var vals = val.split(';');
              return [{ id: 62, effect: 222, max: Number(vals[0]) / 100.0 }, { id: 4012, effect: 222, max: Number(vals[1]) }];
            } else {
              return [{ id: 62, effect: 222, max: Number(val) / 100.0 }];
            }
          }
        },
        372: {
          id: 372,
          name: 'statConversion',
          getVals: function getVals(val) {
            if (val.indexOf(';') > 0) {
              var vals = val.split(';');
              if (vals.length == 3 && vals[0] == 2 && vals[2] == 6) {
                return [{ id: 10372, name: 'intToMdmg', max: Number(vals[1]) }];
              }
            }
            return [];
          }
        },

        389: { id: 389, name: 'fd buf', mapTo: 1029 },
        404: { id: 404, name: 'critical damage%', mapTo: 1103 }
      },

      gemExchanges: [{ id: 2, exchange: 1, name: 'Weapon' }, { id: 3, exchange: 2, name: 'Off-Hand Weapon' }, { id: 4, exchange: 3, name: 'Headgear' }, { id: 5, exchange: 4, name: 'Body Armor' }, { id: 6, exchange: 5, name: 'Leg Armor' }, { id: 7, exchange: 6, name: 'Gloves' }, { id: 8, exchange: 7, name: 'Shoes' }, { id: 101, exchange: 8, name: 'Necklace' }, { id: 102, exchange: 9, name: 'Earrings' }, { id: 103, exchange: 10, name: 'Ring' }],

      customItems: [{ id: 0, typeName: 'custom', name: 'hp unified', stats: [{ id: 4075, max: 0.05 }] }],

      getStats: function getStats(data) {

        var useMax = false;
        var useStateXVal = false;
        var mightHaveSets = true;
        var prop = 'State1_Max';
        if (prop in data) {
          useMax = true;
        } else {
          prop = 'State1Value';
          if (prop in data) {
            useStateXVal = true;
          }
        }

        var currentState = 0;
        var statVals = [];
        for (;;) {
          currentState++;

          var stateProp = 'State' + currentState;
          if (!(stateProp in data)) {
            break;
          }

          var stateId = data[stateProp];
          if (stateId == -1) {
            break;
          }

          if (stateId == 107) {
            // is this mp?
          } else {

            var currentData = { id: stateId };

            var prop;

            if (useMax) {
              prop = 'State' + currentState + '_Max';
              currentData.max = data[prop];
            } else if (useStateXVal) {
              prop = 'State' + currentState + 'Value';
              currentData.max = data[prop];
            } else {
              prop = 'StateValue' + currentState;
              currentData.max = Number(data[prop]);
            }

            if (currentData.max > 0 || currentData.max < 0) {
              if (mightHaveSets) {
                prop = 'NeedSetNum' + currentState;
                if (prop in data) {
                  if (data[prop] == 0) {
                    break;
                  }
                  currentData.needSetNum = data[prop];
                } else {
                  mightHaveSets = false;
                }
              }

              statVals.push(currentData);
            }
          }
        }

        return statVals;
      },

      setupStat: function setupStat(stat, id) {
        stat.id = Number(id);
      },

      mergeStats: function mergeStats(stats1, stats2) {
        var statMap = {};

        var self = this;
        function add(value) {

          var amount = Number(value.max);
          if (self.stats[value.id] && 'pc' in self.stats[value.id]) {
            amount = Math.floor(amount);
          }

          if (value.id in statMap) {
            statMap[value.id] += amount;
          } else {
            statMap[value.id] = amount;
          }
        }

        angular.forEach(stats1, function (value, key) {
          if (value) {
            add(value);
          }
        });

        if (stats2) {
          angular.forEach(stats2, function (value, key) {
            if (value) {
              add(value);
            }
          });
        }

        var newStats = [];

        for (var key in statMap) {
          var stat = { max: statMap[key], id: Number(key) };
          newStats.push(stat);
        }

        return newStats;
      }
    };
  }
})();
//# sourceMappingURL=app.min.js.map
