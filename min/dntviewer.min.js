function SimplerReader(pFile, startPos, littleEndian) {
// module to track position while reading binary data
'use strict';
  
  this.pos = startPos;
  this.file = new DataView(pFile);
  this.littleEndian = littleEndian;
  
  this.readUint16 = function() {
    this.pos += 2;
    return this.file.getUint16(this.pos-2, this.littleEndian);
  }
  
  this.readUint32 = function() {
    this.pos += 4;
    return this.file.getUint32(this.pos-4, this.littleEndian);
  }
  
  this.readInt32 = function() {
    this.pos += 4;
    return this.file.getInt32(this.pos-4, this.littleEndian);
  }
  
  this.readFloat32 = function() {
    this.pos += 4;
    var floatVal = this.file.getFloat32(this.pos-4, this.littleEndian);
    return Math.round(floatVal*100000)/100000;
  }
  
  this.readByte = function() {
    this.pos += 1;
    return this.file.getUint8(this.pos-1, this.littleEndian);
  }
  
  this.readString = function() {
    var len = this.readUint16();
    if(len === 0) {
      return '';
    }
    else if(len === 1) {
      return String.fromCharCode(this.readByte());
    }
    else {
      
      // var retVal = '';
      var strings = new Array(len);
      for(var c=0;c<len;++c) {
        
        strings[c] = String.fromCharCode(this.readByte());
        // retVal += String.fromCharCode(this.readByte());
      }
      
      var val = strings.join('');
      if(val && val.length > 6 && val.indexOf('.') > 0 && !isNaN(val)) {
        return Math.round(Number(val)*100000)/100000;
      }

      return val;
    }
  }
  
  this.skipUint16 = function() {
    this.pos += 2;
  }
  
  this.skipUint32 = function() {
    this.pos += 4;
  }
  
  this.skipInt32 = function() {
    this.pos += 4;
  }
  
  this.skipFloat32 = function() {
    this.pos += 4;
  }
  
  this.skipByte = function() {
    this.pos += 1;
  }
  
  this.skipString = function() {
    var len = this.readUint16();
    this.pos += len;
  }
}
function DntReader() {
// module for to allow reading of dnt data from dnt files
// right now this simply loads the whole file into the data property
// data is an array of objects eg [{id: "123",NameParam: "456"}]
'use strict';
  
  this.data = [];
  this.columnNames = [];
  this.columnTypes = [];
  this.columnIndexes = [];
  this.numRows = 0;
  this.numColumns = 0;
  this.fileName = "";
  this.colsToLoad = null;
  
  // function to populate the object with the data in the dnt file
  this.processFile = function(arrayBuffer, fileName) {
    
    var start = new Date().getTime();
    
    this.fileName = fileName;
    
    // not sure if littleEndian should always be true or when it would be false
    var reader = new SimplerReader(arrayBuffer, 4, true);
    
    var readFuncs = [];
    readFuncs[1] = function(reader) { return reader.readString() };
    readFuncs[2] = function(reader) { return reader.readInt32() };
    readFuncs[3] = function(reader) { return reader.readInt32() };
    readFuncs[4] = function(reader) { return reader.readFloat32() };
    readFuncs[5] = function(reader) { return reader.readFloat32() };
    
    var skipFuncs = [];
    skipFuncs[1] = function(reader) { reader.skipString() };
    skipFuncs[2] = function(reader) { reader.skipInt32() };
    skipFuncs[3] = function(reader) { reader.skipInt32() };
    skipFuncs[4] = function(reader) { reader.skipFloat32() };
    skipFuncs[5] = function(reader) { reader.skipFloat32() };
    
    this.numColumns = reader.readUint16() + 1;
    this.numRows = reader.readUint32();
    
    this.data = new Array(this.numRows);
    this.columnNames = new Array(this.numColumns);
    this.columnTypes = new Array(this.numColumns);
    
    this.columnNames[0] = 'id';
    this.columnTypes[0] = 3;
    var colReaders = [];
    var colIsRead = [];
    var colIndex = 1;
    var realNumCols = 0;
    
    for(var c=1;c<this.numColumns;++c) {
      var colName = reader.readString().substr(1);
      var colType = reader.readByte();
      
      if(this.colsToLoad === null || this.colsToLoad[colName]) {
        colIsRead[c] = true;
        colReaders[c] = readFuncs[colType];

        this.columnNames[colIndex] = colName;
        this.columnTypes[colIndex] = colType;
        colIndex++;
      }
      else {
        colIsRead[c] = false;
        colReaders[c] = skipFuncs[colType];
      }
    }
    realNumCols = colIndex;
    
    for(var r=0;r<this.numRows;++r) {
      
      this.data[r] = new Array(realNumCols);
      this.data[r][0] = reader.readUint32();
      
      colIndex = 1;
      for(var c=1;c<this.numColumns;++c) {
        if(colIsRead[c]) {
          this.data[r][colIndex] = colReaders[c](reader);
          colIndex++;
        }
        else {
          colReaders[c](reader);
        }
      }
    }
    
    this.numColumns = realNumCols;

    this.columnIndexes = {'id': 0};
    for(var c=1;c<this.numColumns;++c) {
      this.columnIndexes[this.columnNames[c]] = c;
    }

    var end = new Date().getTime();
    var time = end - start;
    console.log('dnt process time: ' + time/1000 + 's for ' + fileName);
  }
  
  this.getRow = function(index) {
    return this.convertData(this.data[index]);
  }
  
  this.convertData = function(d) {
    var item = {id: d[0]};

    for(var c=1;c<this.numColumns;++c) {
      if(d[c] != null) {
        item[this.columnNames[c]] = d[c];
      }
    }
    
    return item;
  }
  
  this.getValue = function(index, colName) {
    if(colName in this.columnIndexes) {
      return this.data[index][this.columnIndexes[colName]];
    }
    else {
      return null;
    }
  }
  
  // function to load in dnt data from a hosted file
  // if the file is not found it will try a zip with the same name
  this.loadDntFromServerFile = function(fileName, statusFunc, processFileFunc, failFunc) {
    var useFileName = fileName;
    if(this.colsToLoad === null && fileName.toUpperCase().lastIndexOf(".LZJSON") != fileName.length-7 && fileName.toUpperCase().lastIndexOf(".JSON") != fileName.length-5) {
      useFileName = fileName.substr(0,fileName.length-4) + '.lzjson';
    }
    this.loadDntFromServerFileImpl(useFileName, statusFunc, processFileFunc, failFunc);
  }
  
  this.loadDntFromServerFileImpl = function(fileName, statusFunc, processFileFunc, failFunc) {
    
    // console.log("about to load");
    var isLzJson = (fileName.toUpperCase().lastIndexOf(".LZJSON") == fileName.length-7);
    var isJson = (fileName.toUpperCase().lastIndexOf(".JSON") == fileName.length-5);
    
    var xhr = new XMLHttpRequest();
    xhr.open('GET', fileName, true);
    
    if(isLzJson || isJson) {
      xhr.responseType = 'text';
    }
    else {
      xhr.responseType = 'blob';
    }
    
    statusFunc('downloading dnt file ' + fileName);
    var start = new Date().getTime();
    
    var t = this;
    
    xhr.onerror = function(e) {
      console.log('what! error ', e);
      if(failFunc) {
        failFunc('Cannot load file' + e);
      }
    }
    
    xhr.ontimeout = function(e) {
      console.log('what! timeout ', e);
      if(failFunc) {
        failFunc('Timeout loading file' + e);
      }
    }
    
    xhr.onload = function(e) {
      // console.log("got status");
      
      if (this.status === 200) {
        // console.log("got 200 status");
        
        var blobv = this.response;
        if(fileName.toUpperCase().lastIndexOf(".DNT") === fileName.length-4) {
          // console.log("dnt file");
          
          var fileReader = new FileReader();
          fileReader.onload = function(e) {
            t.processFile(e.target.result, fileName);
            
            var end = new Date().getTime();
            var time = end - start;
            console.log('dnt time: ' + time/1000 + 's for ' + fileName);
            processFileFunc();
          };
          fileReader.readAsArrayBuffer(blobv);
        }
        else if(isJson) {
          t.processJsonFile(blobv, fileName);
          
          var end = new Date().getTime();
          var time = end - start;
          console.log('json time: ' + time/1000 + 's for ' + fileName);
          processFileFunc();
        }
        else if(isLzJson) {
          t.processLzFile(blobv, fileName);
          
          var end = new Date().getTime();
          var time = end - start;
          console.log('lzjson time: ' + time/1000 + 's for ' + fileName);
          processFileFunc();
        }
        else {
          // console.log("zip maybe");
          statusFunc('unziping compressed dnt file');
          
          // console.log(blobv);
          
          unzipBlob(blobv, function(unZippedData) {
            
            // statusFunc('loading dnt');
            //console.log("unzipped: " + unZippedData.length + " bytes");
            
            var fileReader = new FileReader();
            fileReader.onload = function(e) {
              t.processFile(e.target.result, fileName);
            
              var end = new Date().getTime();
              var time = end - start;
              console.log('zip time: ' + time/1000 + 's for ' + fileName);
              processFileFunc();
            };
            fileReader.readAsArrayBuffer(unZippedData);
          });
        }
      }
      else {
        // if we get an error we can try to see if there is a zip version there
        if(fileName.toUpperCase().lastIndexOf('.LZJSON') === fileName.length-7) {
          console.log('trying dnt');
          var dntFileName = fileName.substr(0,fileName.length-7) + '.dnt';
          t.loadDntFromServerFileImpl(dntFileName, statusFunc, processFileFunc, failFunc);
        }
        else if(fileName.toUpperCase().lastIndexOf('.DNT') === fileName.length-4) {
          console.log('trying json');
          var zipFileName = fileName.substr(0,fileName.length-4) + '.json';
          t.loadDntFromServerFileImpl(zipFileName, statusFunc, processFileFunc, failFunc);
        }
        else {
          console.log('what! status ' + this.status + '??');
          if(failFunc) {
            failFunc(this.status + ': Cannot load file, couldnt load zip either: ' + fileName);
          }
        }
      }
    };
    
    xhr.send();
  }
  
  this.processJsonFile = function(json, fileName) {
    var dlData = JSON.parse(json);
    
    this.data = dlData.data;
    this.fileName = fileName;
    this.columnNames = dlData.columnNames;
    this.columnTypes = dlData.columnTypes;
    
    this.numRows = this.data.length;
    this.numColumns = dlData.columnNames.length;
    
    this.columnIndexes = {'id': 0};
    for(var c=1;c<this.numColumns;++c) {
      this.columnIndexes[this.columnNames[c]] = c;
    }
  }
  
  this.processLzFile = function(blobv, fileName) {
    var start = new Date().getTime();
    var stringifiedData = LZString.decompressFromUTF16(blobv);
    var end = new Date().getTime();
    var time = end - start;
    console.log('decompress time: ' + time/1000 + 's for ' + fileName);

    this.processJsonFile(stringifiedData, fileName);
  }
  
  function unzipBlob(blob, callback) {
    // use a zip.BlobReader object to read zipped data stored into blob variable
    zip.createReader(new zip.BlobReader(blob), function(zipReader) {
      // get entries from the zip file
      zipReader.getEntries(function(entries) {
        // get data from the first file
        entries[0].getData(new zip.BlobWriter(), function(data) {
          // close the reader and calls callback function with uncompressed data as parameter
          zipReader.close();
          callback(data);
        });
      });
    }, onerror);
  }
  
  function onerror(message) {
    console.error(message);
  }
}
function DnTranslations() {
  // module used to load uistring.xml files

  // the data
  this.data = null;
  this.sizeLimit = null;
  
  // function to lookup some string value by its id
  // this will also work with values that have a number
  // of mids enclosed in curly brackets
  this.translate = function(value) {
    if(this.data === null) {
      return value;
    }
    var result = "";
    
    if(value === 0 || value === "" || value === null) {
      result = value;
    }
    else if(value.toString().indexOf(',') > -1) {
      var values = value.toString().split(',');
      
      var results = []
      for(var v=0;v<values.length;++v) {
        var stripped = values[v].replace("{", "").replace("}", "");
        results.push(values[v].replace(stripped, this.translate(stripped)));
      }
      
      result = results.join(',');
    }
    else {
      result = this.data[value];
      if(typeof result === 'undefined') {
        if(typeof value === 'string') {
          if(value.indexOf('{') == 0) {
            var stripped = value.replace("{", "").replace("}", "");
            result = value.replace(stripped, this.translate(stripped));
          }
          else {
            result = value.toString();
          }
        }
        else {
          result = value;
        }
      }
      else if(typeof value === 'string' && result.indexOf('#N/A') == 0) {
        result = '';
      }
    }
    
    return result;
  }
  
  // function to read in the xml data
  // and store it as an array for fast access
  // once loaded it tries to store the data in UIStrings session storage
  this.process = function(xmlFileAsString, callback, complete) {
    this.data = {}
    var numItems = 0;
    
    // console.log("processing:");
    var parser = new DOMParser();
    var xmlData = parser.parseFromString(xmlFileAsString,"text/xml");
    var elements = xmlData.getElementsByTagName("message");
    
    for(var m=0;m<elements.length;++m) {
      var text = elements[m].textContent;
      if(this.sizeLimit === null || text.length < this.sizeLimit) {
        var mid = elements[m].getAttribute("mid");
        this.data[mid] = text;
        numItems++;
      }
    }
  
    try {
      var stringifiedData = JSON.stringify(this.data);
      sessionStorage.setItem('UIStrings', LZString.compressToUTF16(stringifiedData));
      callback('stored ui strings for later');
    }
    catch (ex) {
      console.log('error setting strings ' + ex);
      console.log(ex.stack);
    }
    
    callback('loaded ' + numItems + ' translations');
    complete();
  }
  
  this.loadFromSession = function() {
    try {
      this.data = null;
      
      var savedData = sessionStorage.getItem('UIStrings'); 
      if(savedData === null) {
        return false;
      }
      
      var stringifiedData = LZString.decompressFromUTF16(savedData);
      this.data = JSON.parse(stringifiedData);
      console.log('got ui strings from local storage');
      return true;
    }
    catch(ex) {
      console.log('couldnt get ui strings ' + ex);
      // no worries, just load the default
      return false;
    }
  }
  
  // function to load xml file from url
  // if the file is not found we look for a zip verison and then unzip it
  // it tries to find the already loaded data in UIStrings session storage
  // and uses this if it can
  this.loadDefaultFile = function(fileName, callback, complete, fail) {
    // console.log("about to load");
    
    this.loadFromSession();
    
    if(this.data != null && typeof this.data === 'object') {
      callback('using uistrings stored in local storage');
      complete();
    }
    else if(fileName === null) {
      callback('Translation location required');
    }
    else {
      console.log('data still not set');
      
      localStorage.setItem('UIStrings_file', fileName);
    
      var xhr = new XMLHttpRequest();
      xhr.open('GET', fileName, true);
      if(fileName.toUpperCase().lastIndexOf('.ZIP') === fileName.length-4) {
        xhr.responseType = 'blob';
      }
      else if(fileName.toUpperCase().lastIndexOf('.XML') === fileName.length-4) {
        xhr.responseType = 'document';
      }
      else {
        xhr.responseType = 'text';
      }
      
      callback('downloading translation file ' + fileName);
      
      var t = this;
      xhr.onerror = function(e) {
        console.log('what! error ', e);
        fail('Cannot load file' + e);
      }
      
      xhr.ontimeout = function(e) {
        console.log('what! timeout ', e);
        fail('Timeout loading file' + e);
      }
      
      xhr.onload = function(e) {
        
        if (this.status === 200) {
          
          callback('loading translations from ' + fileName);
          var start = new Date().getTime();
          
          var blobv = this.response;
          
          console.log("reading zip");
          if(fileName.toUpperCase().lastIndexOf('.LZJSON') === fileName.length-7) {
            sessionStorage.setItem('UIStrings', blobv);
            t.loadFromSession();
            callback('using lzjson translations');
            complete();
            
            var end = new Date().getTime();
            var time = end - start;
            console.log('translations process time: ' + time/1000 + 's');
          }
          else if(fileName.toUpperCase().lastIndexOf('.ZIP') === fileName.length-4) {
            unzipBlobToText(blobv, function(unZippedData) {
              console.log('got entry data');
              callback('loading xml');
              console.log("unzipped: " + unZippedData.length.toLocaleString() + " bytes");
              t.process(unZippedData, callback, complete);
            
            var end = new Date().getTime();
            var time = end - start;
              console.log('translations process time: ' + time/1000 + 's');
            });
          }
          else if(fileName.toUpperCase().lastIndexOf('.XML') === fileName.length-4) {
            callback('using xml translations');
            t.process(blobv, callback, complete);
            
            var end = new Date().getTime();
            var time = end - start;
            console.log('translations process time: ' + time/1000 + 's');
          }
          
        }
        else {
          // if we get an error we can try to see if there is a zip version there
          if(fileName.toUpperCase().lastIndexOf('.LZJSON') === fileName.length-7) {
            var baseFileName = fileName.substr(0,fileName.length-7);
            t.loadDefaultFile(baseFileName + '.zip', callback, complete, fail);
          }
          else if(fileName.toUpperCase().lastIndexOf('.ZIP') === fileName.length-4) {
            var baseFileName = fileName.substr(0,fileName.length-4);
            t.loadDefaultFile(baseFileName + '.xml', callback, complete, fail);
          }
          else {
            console.log('what status' + this.status + ' ' + fileName);
            fail(this.status + ': Cannot load file, couldnt load zip either: ' + fileName);
          }
        }
      };
      xhr.send();
    }
  }

  function unzipBlobToText(blob, callback) {
    // use a zip.BlobReader object to read zipped data stored into blob variable
    zip.createReader(new zip.BlobReader(blob), function(zipReader) {
      // get entries from the zip file
      zipReader.getEntries(function(entries) {
        // get data from the first file
        entries[0].getData(new zip.TextWriter("text/plain"), function(data) {
          // close the reader and calls callback function with uncompressed data as parameter
          zipReader.close();
          callback(data);
        });
      });
    }, onerror);
  }
  
  function onerror(message) {
    console.error(message);
  }
}

//# sourceMappingURL=dntviewer.min.js.map
